* これは何?

  麦汁さんの Emacs の設定ファイルの一部。

  一部の設定はこのファイルで記載しているコードブロックを export している。

  本当は全部やりたいけどまずは小さく少しずつ

* キーバインド系
** sticky-control

   指定したキーを2回叩いたら
   Control が押されてるような状態になってしてくれるプラグイン。

   その2回の間隔はデフォルトだと 0.5 秒以内となっている。
   そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる

   さらに ~sticky-control-shortcuts~ に指定されてる一部のキーについては
   sticky 用のキーを押した直後に shortcuts のキーを押すと
   Control を押している状態でそのキーを押したことになる。

   例えば私は ~,~ を sticky 用のキーにしていて
   shortcuts に ~c~ を入れているので
   ~,c~ と素早くタイプをすればそれだけで ~C-c~ が押された状態になる。

*** インストール

    まずは el-get-bundle でインストール。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (el-get-bundle sticky-control)
    #+end_src

    ちなみにレシピは公式ではなかったので
    とりあえず自分の環境で使えるように自作レシピを置いている。

    #+begin_src emacs-lisp :tangle recipes/sticky-control.rcp
    (:name sticky-control
           :description "save your left little finger"
           :type http
           :url "https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el"
           :features "sticky-control")
    #+end_src

    元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど
    最近そこからは取得できなくなったので
    https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el
    から取得して利用している

*** 設定

    まずは「2回叩いたら Control を押している状態になる」キーを指定する。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (sticky-control-set-key 'sticky-control-key ?,)
    #+end_src

    私は ~,~ を sticky-control のキーにしているのでこの指定。

    そして次に ~sticky-control-shortuts~ の指定。
    ここに指定しておくと、
    例えば ~,c~ と素早くタイプすることで ~C-c~ が入力された状態とすることができる。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (setq sticky-control-shortcuts
          '((?c . "\C-c")
            (?g . "\C-g")
            (?k . "\C-k")
            (?a . "\C-a")
            (?e . "\C-e")
            (?n . "\C-n")
            (?o . "\C-o")
            (?p . "\C-p")
            (?j . "\C-j")
            (?f . "\C-f")
            (?b . "\C-b")
            (?x . "\C-x")
            (?r . "\C-r")
            (?s . "\C-s")))
    #+end_src

    結構な数を指定しているけど、普段そんなに使えているわけでもない。
    まあ、大体 Control を押しながら使いそうなところは押さえてあるので
    何も考えずとも使えるようにしてある。

*** 有効化
    最後に有効化

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (sticky-control-mode)
    #+end_src

* フレームワーク系
** Ember.js 用の設定

   Ember.js 用の Emacs の拡張としては
   ~ember-mode~ と ~handlebars-mode~ が存在する

*** ember-mode                                                       :unused:

    https://github.com/madnificent/ember-mode

    Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。
    実は麦汁さんは使えてない。

    インストールするだけではダメで、
    ember-mode を明示的に起動しないといけない。

    そのためには dir-locals を使うとか
    projectile なんかがやってるように
    フォルダ構成から判定させるみたいなことが必要そう。だるい。

    というわけで死蔵中。

    ついでにいうとキーバインドもだるい系なので
    使う時は Hydra を用意した方が良さそう

    #+begin_src emacs-lisp :tangle inits/40-ember.el
    (el-get-bundle madnificent/ember-mode)
    #+end_src

*** handlebars-mode                                             :improvement:

    https://github.com/danielevans/handlebars-mode

    Handlebars を書くためのモード。

    syntax highlight と、いくつかの編集機能を備えている。
    が、今のところ麦汁さんは syntax highlight しか使えてない。

    編集コマンドは [[https://github.com/jerrypnz/major-mode-hydra.el][major-mode-hydra]] で使えるようにしてあげれば良さそう

    #+begin_src emacs-lisp :tangle inits/40-ember.el
    (el-get-bundle handlebars-mode)
    #+end_src

* 設定ファイルのテスト関係プラグイン

** mocker.el                                                         :unused:

   https://github.com/sigma/mocker.el

   Emacs Lisp のテストで使う Mock ライブラリ。

   使おうと思って導入したけど、
   自分のやりたいことはちょっと違ったので死蔵中

   便利そうなのでとりあえず置いといている。

   #+begin_src emacs-lisp :tangle inits/99-mocker.el
   (el-get-bundle sigma/mocker.el)
   #+end_src

** with-simulated-input.el

   https://github.com/DarwinAwardWinner/with-simulated-input

   入力をシミュレートするためのプラグイン。

   公式のドキュメントにあるように

   #+begin_src emacs-lisp
   (with-simulated-input
       "hello SPC world RET"
     (read-string "Say hello to the world: "))
   #+end_src

   を評価すると
   read-string に対して「hello world」を入力したことになるので
   echo エリアに「hello world」と表示される。

   これで何が嬉しいかというと
   Emacs Lisp でやっていることはインタラクティブな部分が大きいので
   そういった要素をテストできるようになる。

   具体的な使用例は [[*test:my/org-todo][test:my/org-todo]] で示す。

   #+begin_src emacs-lisp :tangle 99-with-simulated-input.el
   (el-get-bundle DarwinAwardWinner/with-simulated-input)
   #+end_src

* テストコード

  一部のコマンドなどの設定を書き始めているので設けたセクション。

  暫定的にここに置いているが設定と近い方が良さそうなので
  いずれドキュメント内の位置を移動しそう。

** 実行方法

   テストする時は以下のように叩いたら動く。

   #+begin_src sh
   emacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el
   #+end_src

   今まで ~.emacs.d~ にいる状態でしか叩いたことないので
   他の場所にいる時に実行しても大丈夫かはわからない。

   単体でテストしたい時は

   #+begin_example
   -l ~/.emacs.d/inits/test/*-test.el
   #+end_example

   の部分を書き換えたらいいんじゃないかな。やったことないけど。

** run-tests

   読み込んだテストをまるっとテストするためのコードをとりあえず置いている。

   #+begin_src emacs-lisp :tangle inits/test/run-tests.el
  (if noninteractive
      (let ((ert-quiet t))
        (ert-run-tests-batch-and-exit)))
   #+end_src

   後述の [[*テストライブラリの読み込み][テストライブラリの読み込み]] などはここで担うべきかとも考えるが
   今はテストファイルが1つしかないので気にしないことにする。

** 68-my-org-commands-test

   org-mode 用に定義したコマンドや関数のテストコード

*** Setup
**** テストライブラリの読み込み

     標準でついてくる ert を採用しているのでそれを読み込んでいる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (require 'ert)
     #+end_src

**** el-get の設定の読み込み

     プラグイン管理には el-get を利用しているので
     その設定ファイルを読み込んでいる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     ;; プラグイン読み込みの前準備
     (load (expand-file-name (concat user-emacs-directory "/init-el-get.el")))
     #+end_src

**** テスト補助のプラグイン読み込み
***** with-simulated-input

      上で説明しているが、
      入力をシミュレートするためのプラグインをテストで利用しているので
      ここで読み込んでいる。

      #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
      ;; 入力シミュレート用のプラグイン
      (load (expand-file-name (concat user-emacs-directory "/inits/99-with-simulated-input")))
      #+end_src

**** 依存プラグインの読み込み                                   :improvement:

     テスト対象が依存しているプラグインを読み込んでいる。
     本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが
     現状だとその状態で GitHub Actions で動かせる方法がわからないので
     一旦個別に読み込むようにしている。

***** swiper

      ivy-read を使った機能のテストをするので読み込んでいる。

      #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
      (el-get-bundle abo-abo/swiper)
      #+end_src

**** テスト対象の読み込み

     テストしたいファイルをここで読んでる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     ;; テスト対象の読み込み
     (load (expand-file-name (concat user-emacs-directory "/inits/68-my-org-commands.el")))
     #+end_src

*** ert-deftest
**** test:my/org-todo-keyword-strings

     ~org-todo-keywords~ から "|" という区切りを除外したり
     "(s)" とかのような高速アクセスのためのキーワードは
     ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (ert-deftest test:my/org-todo-keyword-strings ()
       "Test of `my/org-todo-keyword-strings'."
       (let ((org-todo-keywords '((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)"))))
         (should (equal '("TODO" "DOING" "WAIT" "DONE" "SOMEDAY")
                        (my/org-todo-keyword-strings)))))
     #+end_src

     なお、ここでテストしている関数では
     TODO キーワードを ivy で扱いやすいように整えているだけで
     実際の選択は別の関数が担っている

**** test:my/org-todo

     org-todo を ivy で選択する関数のテストを書いている。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (ert-deftest test:my/org-todo ()
       "Test of `my/org-todo'."
       (let ((org-todo-keywords '((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)")))
             (result))
         ;; org-mode を読まずに済むように org-todo を差し替えてテストしている
         (cl-letf (((symbol-function 'org-todo)
                    (lambda (keyword)
                      (setq result keyword))))
           (with-simulated-input "DOI RET" (my/org-todo))
           (should (equal "DOING" result)))))
     #+end_src

     ポイントは cl-letf を使って、内部で叩いている関数 ~org-todo~ を一時的に

     #+begin_src emacs-lisp
     (lambda (keyword)
       (setq result keyword))
     #+end_src

     に差し替えているところ。

     org-mode を呼び出さずに代わりの関数に差し替えているので
     テストがしやすくなっている。Stub 的なやつかな。

     何度も使うならこの差し替え処理自体をテストヘルパーにしても良いかもしれない。

     また ivy で選択するので with-simulated-input を使って入力操作を代替している。便利。
