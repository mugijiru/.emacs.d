#+TODO: TODO(t) | DONE(o)
#+HUGO_BASE_DIR: ./hugo/
#+HUGO_SECTION: ./
#+title: 麦汁三昧
#+author: mugijiru
#+chapter: true
#+toc: headlines 2
#+HUGO_LEVEL_OFFSET: 1

* Top
  :PROPERTIES:
  :END:

** 麦汁's Emacs Config
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :END:

   ここは @mugijiru の Emacs の設定ファイルの一部を解説しているページです。

   https://github.com/mugijiru/.emacs.d/blob/master/init.org から
   ox-hugo を使ってWebサイトに仕立て上げています。

*** 動作確認環境

    以下の環境で使用しています。が、動作を保証するものではありません。

    - macOS :: [[https://github.com/railwaycat/homebrew-emacsmacport][emacsmacport]] で用意されている Emacs
    - Ubuntu 20.04 LTS :: apt で手に入る Emacs 26.3

*** 注意点

    まだ全ての設定を init.org に記載できていない上に
    init.org からの出力設定も済ませていないので
    極一部の設定ファイルのみの解説となります。

* 基本設定
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: basics
  :END:

** 基本設定
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>1. </b>" :weight 1 :disableToc true
   :END:
   #+TOC: nil
   #+OPTIONS: toc:nil

   Emacs の基本動作に関わる部分をここでは設定している

   - [[*ガベージコレクション][ガベージコレクション]] :: メモリの開放関係の設定

** ガベージコレクション
   :PROPERTIES:
   :EXPORT_FILE_NAME: gcmh
   :END:

*** 概要
    ガベージコレクションには gcmh というのを利用してみている。

    https://github.com/emacsmirror/gcmh

    普段は GC を控えめにしながら
    操作してない間に GC が走るような作りになっている。便利そう。

*** インストール
    #+begin_src emacs-lisp :tangle inits/00-gc.el
    (el-get-bundle gcmh)
    #+end_src

    これだけで有効化もされる。

*** その他

    以前の設定も折り畳んで残しておく

    #+begin_details
    #+begin_summary
    使わなくなったコード
    #+end_summary
    gcmh を入れる前に設定していたコード。
    gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。

    #+begin_src emacs-lisp
    ;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf
    ;; Increase threshold to fire garbage collection
    (setq gc-cons-threshold 1073741824)
    (setq garbage-collection-messages t)

    ;; Run GC every 60 seconds if emacs is idle.
    (run-with-idle-timer 60.0 t #'garbage-collect)
    #+end_src
    #+end_details

* キーバインド
   :PROPERTIES:
   :EXPORT_HUGO_SECTION: keybinds
   :END:
** キーバインド
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>2. </b>" :weight 2 :disableToc true
   :END:

   ここでは全体に関わるキーバインド系の設定を記載している。

   - [[*sticky-control][sticky-control]] :: Control の入力を sticky にしてくれるやつ

** sticky-control
   :PROPERTIES:
   :EXPORT_FILE_NAME: sticky-control
   :END:

*** 概要
    指定したキーを2回叩いたら
    Control が押されてるような状態にしてくれるプラグイン。

    その2回の間隔はデフォルトだと 0.5 秒以内となっている。
    そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる

    さらに ~sticky-control-shortcuts~ に指定されてる一部のキーについては
    sticky 用のキーを押した直後に shortcuts のキーを押すと
    Control を押している状態でそのキーを押したことになる。

    例えば私は ~,~ を sticky 用のキーにしていて
    shortcuts に ~c~ を入れているので
    ~,c~ と素早くタイプをすればそれだけで ~C-c~ が押された状態になる。

*** インストール

    まずは el-get-bundle でインストール。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (el-get-bundle sticky-control)
    #+end_src

    ちなみにレシピは公式ではなかったので
    とりあえず自分の環境で使えるように自作レシピを置いている。

    #+begin_src emacs-lisp :tangle recipes/sticky-control.rcp
    (:name sticky-control
           :description "save your left little finger"
           :type http
           :url "https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el"
           :features "sticky-control")
    #+end_src

    元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど
    最近そこからは取得できなくなったので
    https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el
    から取得して利用している

*** 設定

    まずは「2回叩いたら Control を押している状態になる」キーを指定する。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (sticky-control-set-key 'sticky-control-key ?,)
    #+end_src

    私は ~,~ を sticky-control のキーにしているのでこの指定。

    そして次に ~sticky-control-shortuts~ の指定。
    ここに指定しておくと、
    例えば ~,c~ と素早くタイプすることで ~C-c~ が入力された状態とすることができる。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (setq sticky-control-shortcuts
          '((?c . "\C-c")
            (?g . "\C-g")
            (?k . "\C-k")
            (?a . "\C-a")
            (?e . "\C-e")
            (?n . "\C-n")
            (?o . "\C-o")
            (?p . "\C-p")
            (?j . "\C-j")
            (?f . "\C-f")
            (?b . "\C-b")
            (?x . "\C-x")
            (?r . "\C-r")
            (?s . "\C-s")))
    #+end_src

    結構な数を指定しているけど、普段そんなに使えているわけでもない。
    まあ、大体 Control を押しながら使いそうなところは押さえてあるので
    何も考えずとも使えるようにしてある。

*** 有効化
    最後に有効化

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (sticky-control-mode)
    #+end_src

* ファイル編集
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: editing
  :END:

** ファイル編集
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>3. </b>" :weight 3 :disableToc true
   :END:

   ここにはファイル編集系の設定をまとめている

   - [[*auto-insert][auto-insert]] :: ファイル新規作成時にテンプレートを挿入する機能

** auto-insert
   :PROPERTIES:
   :EXPORT_FILE_NAME: auto-insert
   :END:

*** 概要
    auto-insert はファイルを新規作成した時に
    ファイル名に応じたテンプレートを挿入する機能。

    Emacs が標準で持ってるライブラリなのでインストールは不要

*** 設定

    Emacs の設定は .emacs.d の中に閉じ込めたいので
    auto-insert のテンプレートも ~~/.emacs.d/insert~ に閉じ込める設定にしている。

    #+begin_src emacs-lisp :tangle inits/20-auto-insert.el
    (custom-set-variables '(auto-insert-directory "~/.emacs.d/insert/"))
    #+end_src

*** 有効化

    あとは単に有効化している。

    #+begin_src emacs-lisp :tangle inits/20-auto-insert.el
    (auto-insert-mode 1)
    #+end_src

*** 他の設定

    ファイル名を正規表現でマッチさせてテンプレートが選択されるので
    各言語やフレームワーク毎に設定を入れることにしている。

    実際は今のところ inits/41-vue.el でのみ追加設定を入れている。

* UI
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: ui
  :END:
** UI
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>4. </b>" :weight 4 :disableToc true
   :END:

   ここでは Emacs の UI を変更するようなものを載せている

   - [[*helm-posframe][helm-posframe]] :: Helm を posframe で使えるようにするやつ
   - [[*Neotree][Neotree]] :: フォルダ構造を IDE みたいにツリー表示するやつ
** Neotree                                                      :replacement:
   :PROPERTIES:
   :EXPORT_FILE_NAME: neotree
   :END:

*** 概要
    [[https://github.com/jaypei/emacs-neotree][Neotree]] は Emacs でフォルダのツリー表示ができるやつ。
    メンテは活発じゃないようなので、その内乗り換えたい。

*** レシピ

    Neotree でメンテされているのは dev ブランチだけど
    el-get の公式のレシピでは master ブランチを見ているので
    自前で recipe を用意してそれを使っている。

    #+begin_src emacs-lisp :tangle recipes/emacs-neotree-dev.rcp
    (:name emacs-neotree-dev
           :website "https://github.com/jaypei/emacs-neotree"
           :description "An Emacs tree plugin like NerdTree for Vim."
           :type github
           :branch "dev"
           :pkgname "jaypei/emacs-neotree")
    #+end_src

*** インストール

    上に書いたレシピを使ってインストールしている。

    #+begin_src emacs-lisp :tangle inits/40-neotree.el
    (el-get-bundle emacs-neotree-dev)
    #+end_src

*** 使わなくなったコード

    元々設定していたが、
    counsel-projectile を使ってると
    projectile-switch-project-action を設定していても反映されず
    意味がないのに気付いたので使わなくなった

    https://github.com/mugijiru/.emacs.d/pull/183/files#r541843206

    #+begin_src emacs-lisp
    (setq projectile-switch-project-action 'neotree-projectile-action)
    #+end_src

*** テーマの設定

    GUI で起動している時はアイコン表示し
    そうでない場合は ▾ とかで表示する

    #+begin_src emacs-lisp :tangle inits/40-neotree.el
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
    #+end_src

    のだけど、
    実際に今使ってるやつだともっとグラフィカルな表示なので
    all-the-icons の設定で上書きしている気がするので要確認

*** major-mode-hydra

    いちいちキーバインドを覚えてられないので
    [[https://github.com/jerrypnz/major-mode-hydra.el][major-mode-hydra]] を使って主要なキーバインドは [[https://github.com/abo-abo/hydra][hydra]] で使えるようにしている。

    とはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。

    #+begin_src emacs-lisp :tangle inits/40-neotree.el
    (with-eval-after-load 'major-mode-hydra
      (major-mode-hydra-define neotree-mode (:separator "-" :quit-key "q" :title (concat (all-the-icons-octicon "list-unordered") " Neotree"))
        ("Nav"
         (("u"   neotree-select-up-node   "Up")
          ("g"   neotree-refresh          "Refresh")
          ("Q"   neotree-hide             "Hide"))

         "File"
         (("a"   neo-open-file-ace-window "Ace")
          ("N"   neotree-create-node      "Create")
          ("R"   neotree-rename-node      "Rename")
          ("C"   neotree-copy-node        "Copy")
          ("D"   neotree-delete-node      "Delete")
          ("SPC" neotree-quick-look       "Look")
          ;; ("d" neo-open-dired "Dired")
          ;; ("O" neo-open-dir-recursive   "Recursive")
          )
         "Toggle"
         (("z" neotree-stretch-toggle     "Size"        :toggle (not (neo-window--minimize-p)))
          ("h" neotree-hidden-file-toggle "Hidden file" :toggle neo-buffer--show-hidden-file-p)))))
    #+end_src

**** キーバインド
***** ナビゲーション
      |-----+------------------|
      | Key | 効果             |
      |-----+------------------|
      | u   | 上のノードに移動 |
      | g   | 再描画           |
      | Q   | Neotree を隠す   |
      |-----+------------------|

***** ファイル操作

      |-----+--------------------------------------------------------------|
      | Key | 効果                                                         |
      |-----+--------------------------------------------------------------|
      | a   | ファイルを開く。その際に ace-window で開く window を指定する |
      | N   | 新しいノードを作る                                           |
      | R   | ノードの名前を変える                                         |
      | C   | ノードのコピー                                               |
      | D   | ノードの削除                                                 |
      | SPC | クイックルック                                               |
      |-----+--------------------------------------------------------------|

***** Toggle

      |-----+--------------------------------------------|
      | Key | 効果                                       |
      |-----+--------------------------------------------|
      | z   | Neotree のサイズを大きくしたり小さくしたり |
      | h   | 隠しファイルを表示したり隠したり           |
      |-----+--------------------------------------------|

** helm-posframe
   :PROPERTIES:
   :EXPORT_FILE_NAME: helm-posframe
   :END:

*** 概要

    [[https://github.com/tumashu/helm-posframe][helm-posframe]] は [[https://github.com/emacs-helm/helm][helm]] の拡張で
    Helm のバッファの表示を [[https://github.com/tumashu/posframe][posframe]] を使うようにしてくれるやつ。

    実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなので
    いずれ外すかもしれない。

    ただ確か本体の方の挙動が気に入らなかったような気はする。

*** インストール

    いつも通り el-get でインストール。
    GitHub にあるのでそれを取得するようにしている。

    #+begin_src emacs-lisp :tangle inits/21-helm-posframe.el
    (el-get-bundle tumashu/helm-posframe)
    #+end_src

*** 有効化

    #+begin_src emacs-lisp :tangle inits/21-helm-posframe.el
    (helm-posframe-enable)
    #+end_src

* ナビゲーション
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: nav
  :END:

** ナビゲーション
   :PROPERTIES:
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>5. </b>" :weight 5 :disableToc true
   :EXPORT_FILE_NAME: _index
   :END:

   ここではカーソル移動やファイル移動などのナビゲーション系の設定を記載していく

   - [[*avy][avy]] :: 表示されてるところの好きな場所にさくっとジャンプするためのパッケージ

** avy
   :PROPERTIES:
   :EXPORT_FILE_NAME: avy
   :END:

*** 概要
    [[https://github.com/abo-abo/avy][avy]] は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。
    Vimium の f とかに似てる。

*** インストール

    el-get で普通にインストールしている

    #+begin_src emacs-lisp :tangle inits/50-avy.el
    (el-get-bundle avy)
    #+end_src

*** 設定

    文字の上に重なると元の文字列がよくわからなくなるので、
    移動先の文字の前に表示するようにしている

    #+begin_src emacs-lisp :tangle inits/50-avy.el
    (setq avy-style 'pre)
    #+end_src
*** キーバインド

    グローバルなキーバインドを汚染したくなかったので
    ひとまず Hydra を定義している。

    #+begin_src emacs-lisp :tangle inits/50-avy.el
    (with-eval-after-load 'pretty-hydra
      (pretty-hydra-define avy-hydra
        (:separator "-" :title "avy" :foreign-key warn :quit-key "q" :exit t)
        ("Char"
         (("c" avy-goto-char       "Char")
          ("C" avy-goto-char-2     "Char 2")
          ("x" avy-goto-char-timer "Char Timer"))

         "Word"
         (("w" avy-goto-word-1 "Word")
          ("W" avy-goto-word-0 "Word 0"))

         "Line"
         (("l" avy-goto-line "Line"))

         "Other"
         (("r" avy-resume "Resume")))))
    #+end_src


    |-----+-------------------------------|
    | Key | 効果                          |
    |-----+-------------------------------|
    | c   | 1文字からの絞り込み           |
    | C   | 2文字から絞り込み             |
    | x   | 任意の文字列からの絞り込み    |
    | w   | 1文字絞り込んで単語先頭に移動 |
    | W   | 絞り込みなしの単語移動        |
    | l   | 列移動                        |
    | r   | 繰り返し同じコマンドを実行    |
    |-----+-------------------------------|

* フレームワーク用の設定
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: framework-config
  :END:

** フレームワーク用の設定
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>6. </b>" :weight 6 :disableToc true
   :END:

   開発に使っている各フレームワーク用の設定をここにまとめている。

   - [[*Ember.js][Ember.js]] :: Web フロントエンド MVC フレームワークである Ember.js 用の設定を書いている

** Ember.js
   :PROPERTIES:
   :EXPORT_FILE_NAME: ember-js
   :END:

*** 概要

    Ember.js 用の Emacs の拡張としては
    ~ember-mode~ と ~handlebars-mode~ が存在する

*** ember-mode                                                       :unused:

    [[https://github.com/madnificent/ember-mode][ember-mode]] は
    Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。
    実は麦汁さんは使えてない。

    インストールするだけではダメで、
    ember-mode を明示的に起動しないといけない。

    そのためには dir-locals を使うとか
    projectile なんかがやってるように
    フォルダ構成から判定させるみたいなことが必要そう。だるい。

    というわけで死蔵中。

    ついでにいうとキーバインドもだるい系なので
    使う時は Hydra を用意した方が良さそう

    #+begin_src emacs-lisp :tangle inits/40-ember.el
    (el-get-bundle madnificent/ember-mode)
    #+end_src

*** handlebars-mode                                             :improvement:

    [[https://github.com/danielevans/handlebars-mode][handlebars-mode]] は Ember.js のテンプレートエンジンとして採用されている
    Handlebars を書くためのモード。

    syntax highlight と、いくつかの編集機能を備えている。
    が、今のところ麦汁さんは syntax highlight しか使えてない。

    編集コマンドは [[https://github.com/jerrypnz/major-mode-hydra.el][major-mode-hydra]] で使えるようにしてあげれば良さそう

    #+begin_src emacs-lisp :tangle inits/40-ember.el
    (el-get-bundle handlebars-mode)
    #+end_src

* テスト用ツール
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: testing-tool
  :END:

** テスト用ツール
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>7. </b>" :weight 7 :disableToc true
   :END:

   自動テストを実行するにあたり、追加インストールしているパッケージをここに載せている

   - [[*with-simulated-input][with-simulated-input]] :: 入力処理をシミュレートしてくれるパッケージ
   - [[*mocker.el][mocker.el]] :: Mock/Stub するためのパッケージ。まだ使ってない

** with-simulated-input
   :PROPERTIES:
   :EXPORT_FILE_NAME: with-simulated-input
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :weight 1
   :END:

*** 概要
    [[https://github.com/DarwinAwardWinner/with-simulated-input][with-simulated-input]] は入力処理をシミュレートするためのプラグイン。

    公式のドキュメントにあるように

    #+begin_src emacs-lisp
    (with-simulated-input
        "hello SPC world RET"
      (read-string "Say hello to the world: "))
    #+end_src

    を評価すると
    read-string に対して「hello world」を入力したことになるので
    echo エリアに「hello world」と表示される。

    これで何が嬉しいかというと
    Emacs Lisp でやっていることはインタラクティブな部分が大きいので
    そういった要素をテストできるようになる。

    具体的な使用例は [[*test:my/org-todo][test:my/org-todo]] で示す。

*** インストール
    el-get-bundle で GitHub からインストールしている

    #+begin_src emacs-lisp :tangle inits/99-with-simulated-input.el
    (el-get-bundle DarwinAwardWinner/with-simulated-input)
    #+end_src

** mocker.el                                                         :unused:
   :PROPERTIES:
   :EXPORT_FILE_NAME: mocker-el
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :weight 2
   :END:

*** 概要
    [[https://github.com/sigma/mocker.el][mocker.el]] は Emacs Lisp のテストで使う Mock ライブラリ。

    使おうと思って導入したけど、
    自分のやりたいことはちょっと違ったので死蔵中

    便利そうなのでとりあえず置いといている。

*** インストール

    el-get で GitHub から取得している。

    #+begin_src emacs-lisp :tangle inits/99-mocker.el
    (el-get-bundle sigma/mocker.el)
    #+end_src

* テストコード
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: testing
  :END:

** テストコード
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>8. </b>" :weight 8 :disableToc true
   :END:

   一部のコマンドなどの設定を書き始めているので設けたセクション。

   暫定的にここに置いているが設定と近い方が良さそうなので
   いずれドキュメント内の位置を移動しそう。

   - [[*実行方法][実行方法]] :: とりあえず書かれているテストを動かす方法を書いている。
   - [[*run-tests][run-tests]] :: テスト全体を動かすための共通設定ファイルの説明
   - [[*my-org-commands-test][my-org-commands-test]] :: org-mode 用に自分が生やしたコマンドのテストファイルの解説

** 実行方法
   :PROPERTIES:
   :EXPORT_FILE_NAME: execution
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :weight 1
   :END:

   テストする時は以下のように叩いたら動く。

   #+begin_src sh
   emacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el
   #+end_src

   今まで ~.emacs.d~ にいる状態でしか叩いたことないので
   他の場所にいる時に実行しても大丈夫かはわからない。

   単体でテストしたい時は

   #+begin_example
   -l ~/.emacs.d/inits/test/*-test.el
   #+end_example

   の部分を書き換えたらいいんじゃないかな。やったことないけど。

** run-tests
   :PROPERTIES:
   :EXPORT_FILE_NAME: run-tests
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :weight 2
   :END:

   読み込んだテストをまるっとテストするためのコードをとりあえず置いている。

   #+begin_src emacs-lisp :tangle inits/test/run-tests.el
  (if noninteractive
      (let ((ert-quiet t))
        (ert-run-tests-batch-and-exit)))
   #+end_src

   後述の [[*テストライブラリの読み込み][テストライブラリの読み込み]] などはここで担うべきかとも考えるが
   今はテストファイルが1つしかないので気にしないことにする。

** my-org-commands-test
   :PROPERTIES:
   :EXPORT_FILE_NAME: my-org-commands-test
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :weight 3
   :END:

   org-mode 用に定義したコマンドや関数のテストコード

*** Setup
**** テストライブラリの読み込み

     標準でついてくる ert を採用しているのでそれを読み込んでいる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (require 'ert)
     #+end_src

**** el-get の設定の読み込み

     プラグイン管理には el-get を利用しているので
     その設定ファイルを読み込んでいる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     ;; プラグイン読み込みの前準備
     (load (expand-file-name (concat user-emacs-directory "/init-el-get.el")))
     #+end_src

**** テスト補助のプラグイン読み込み
***** with-simulated-input

      上で説明しているが、
      入力をシミュレートするためのプラグインをテストで利用しているので
      ここで読み込んでいる。

      #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
      ;; 入力シミュレート用のプラグイン
      (load (expand-file-name (concat user-emacs-directory "/inits/99-with-simulated-input")))
      #+end_src

**** 依存プラグインの読み込み                                   :improvement:

     テスト対象が依存しているプラグインを読み込んでいる。
     本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが
     現状だとその状態で GitHub Actions で動かせる方法がわからないので
     一旦個別に読み込むようにしている。

***** swiper

      ivy-read を使った機能のテストをするので読み込んでいる。

      #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
      (el-get-bundle abo-abo/swiper)
      #+end_src

**** テスト対象の読み込み

     テストしたいファイルをここで読んでる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     ;; テスト対象の読み込み
     (load (expand-file-name (concat user-emacs-directory "/inits/68-my-org-commands.el")))
     #+end_src

*** ert-deftest
**** test:my/org-todo-keyword-strings

     ~org-todo-keywords~ から "|" という区切りを除外したり
     "(s)" とかのような高速アクセスのためのキーワードは
     ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (ert-deftest test:my/org-todo-keyword-strings ()
       "Test of `my/org-todo-keyword-strings'."
       (let ((org-todo-keywords '((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)"))))
         (should (equal '("TODO" "DOING" "WAIT" "DONE" "SOMEDAY")
                        (my/org-todo-keyword-strings)))))
     #+end_src

     なお、ここでテストしている関数では
     TODO キーワードを ivy で扱いやすいように整えているだけで
     実際の選択は別の関数が担っている

**** test:my/org-todo

     org-todo を ivy で選択する関数のテストを書いている。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (ert-deftest test:my/org-todo ()
       "Test of `my/org-todo'."
       (let ((org-todo-keywords '((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)")))
             (result))
         ;; org-mode を読まずに済むように org-todo を差し替えてテストしている
         (cl-letf (((symbol-function 'org-todo)
                    (lambda (keyword)
                      (setq result keyword))))
           (with-simulated-input "DOI RET" (my/org-todo))
           (should (equal "DOING" result)))))
     #+end_src

     ポイントは cl-letf を使って、内部で叩いている関数 ~org-todo~ を一時的に

     #+begin_src emacs-lisp
     (lambda (keyword)
       (setq result keyword))
     #+end_src

     に差し替えているところ。

     org-mode を呼び出さずに代わりの関数に差し替えているので
     テストがしやすくなっている。Stub 的なやつかな。

     何度も使うならこの差し替え処理自体をテストヘルパーにしても良いかもしれない。

     また ivy で選択するので with-simulated-input を使って入力操作を代替している。便利。

* 未整理

  ここにはとりあえず inits 以下に出力できるようにしただけの記述を連ねていきます。
  あとで移動する。

** exec-path

   #+begin_src emacs-lisp :tangle inits/00-exec-path.el
   ;; for exec path
   ;; use .bashrc setted path
   (el-get-bundle exec-path-from-shell)
   (when (memq window-system '(mac ns))
     (exec-path-from-shell-initialize))
   #+end_src

** load-path

   #+begin_src emacs-lisp :tangle inits/00-load-path.el
   (add-to-list 'load-path (expand-file-name "~/.emacs.d/secret"))
   (defun my/load-config (file)
     (condition-case nil
         (load file)
       (file-missing (message "Load error: %s" file))))
   #+end_src

** savehist

   #+begin_src emacs-lisp :tangle inits/00-savehist.el
   (savehist-mode 1)
   (setq savehist-additional-variables '(kill-ring))
   #+end_src

** load-libraries

   #+begin_src emacs-lisp :tangle inits/01-load-libraries.el
   (el-get-bundle s)
   (require 's)
   #+end_src

** override

   #+begin_src emacs-lisp :tangle inits/01-override.el
   ;; posframe が最初に空行があると最後の行を表示しないため
   ;; 一時的にこちらを直してみている
   (with-eval-after-load 'pretty-hydra
     (defun pretty-hydra--maybe-add-title (title docstring)
     "Add TITLE to the DOCSTRING if it's not nil, other return DOCSTRING unchanged."
     (if (null title)
         docstring
       (format "%s\n%s"
               (cond
                ((char-or-string-p title) title)
                ((symbolp title)          (format "%%s`%s" title))
                ((listp title)            (format "%%s%s" (prin1-to-string title)))
                (t                        ""))
               docstring))))
   #+end_src

** auto-save

   #+begin_src emacs-lisp :tangle inits/10-auto-save.el
   (setq auto-save-timeout 15)
   (setq auto-save-interval 60)
   (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/backup/" t)))
   (setq backup-directory-alist '((".*" . "~/.emacs.d/backup")
                                  (,tramp-file-name-regexp . nil)))

   (setq version-control t)
   (setq delete-old-versions t)
   #+end_src

** migemo

   #+begin_src emacs-lisp :tangle inits/10-migemo.el
   (el-get-bundle migemo)
   (load "migemo")

   ;; Mac
   (let ((path "/usr/local/share/migemo/utf-8/migemo-dict"))
     (if (file-exists-p path)
         (setq migemo-dictionary path)))

   ;; Ubuntu
   (let ((path "/usr/share/cmigemo/utf-8/migemo-dict"))
     (if (file-exists-p path)
         (setq migemo-dictionary path)))

   (let ((path (s-chomp (shell-command-to-string "which cmigemo"))))
     (if (s-ends-with? "not found" path)
         (message "cmigemo not found")
       (setq migemo-command path)))

   (setq migemo-options '("-q" "--emacs"))
   (setq migemo-coding-system 'utf-8-unix)
   (migemo-init)
   #+end_src

** ace-window

   #+begin_src emacs-lisp :tangle inits/20-ace-window.el
   (el-get-bundle ace-window)
   #+end_src

** alert

   #+begin_src emacs-lisp :tangle inits/20-alert.el
   ;; alert.el configuration
   ;; https://github.com/jwiegley/alert
   (el-get-bundle alert)
   (setq alert-default-style 'notifier) ;; use terminal-notifier
   #+end_src

** all-the-icons

   #+begin_src emacs-lisp :tangle inits/20-all-the-icons.el
   (el-get-bundle all-the-icons)
   (require 'all-the-icons)
   ;; (all-the-icons-install-fonts) unless installed

   (with-eval-after-load 'pretty-hydra
     (pretty-hydra-define all-the-icons-hydra (:separator "-" :title "All the icons" :exit t :quit-key "q")
       ("Insert"
        (("a" all-the-icons-insert-alltheicon "All the icons")
         ("f" all-the-icons-insert-fileicon   "File icons")
         ("F" all-the-icons-insert-faicons    "FontAwesome")
         ("m" all-the-icons-insert-material   "Material")
         ("o" all-the-icons-insert-octicon    "Octicon")
         ("w" all-the-icons-insert-wicon      "Weather")
         ("*" all-the-icons-insert            "All")))))
   #+end_src

** browse-url

   #+begin_src emacs-lisp :tangle inits/20-browse-url.el
   (setq browse-url-generic-program "vivaldi")
   #+end_src

** emojify

   #+begin_src emacs-lisp :tangle inits/20-emojify.el
   (el-get-bundle emojify)
   (el-get-bundle dash)
   (global-emojify-mode 1)
   (global-emojify-mode-line-mode 1)
   #+end_src

** google-this

   #+begin_src emacs-lisp :tangle inits/20-google-this.el
   (el-get-bundle google-this)

   (with-eval-after-load 'pretty-hydra
     (pretty-hydra-define google-this-pretty-hydra
       (:foreign-keys warn :title "Google" :quit-key "q" :color blue :separator "-")
       ("Current"
        (("SPC" google-this-noconfirm "No Confirm")
         ("RET" google-this           "Auto")
         ("w"   google-this-word      "Word")
         ("l"   google-this-line      "Line")
         ("s"   google-this-symbol    "Symbol")
         ("r"   google-this-region    "Region")
         ("e"   google-this-error     "Error"))

        "Feeling Lucky"
        (("L"   google-this-lucky-search         "Lucky")
         ("i"   google-this-lucky-and-insert-url "Insert URL"))

        "Tool"
        (("W" google-this-forecast "Weather")))))
   #+end_src

** google-translate

   #+begin_src emacs-lisp :tangle inits/20-google-translate.el
   (el-get-bundle google-translate)
   #+end_src

** helm

   #+begin_src emacs-lisp :tangle inits/20-helm.el
   ;; helm 系の設定は他の部分への影響も大きそうなので先に持って来た
   (el-get-bundle helm)
   (el-get-bundle helm-descbinds)
   (el-get-bundle helm-ag)
   (require 'helm-config)
   (helm-descbinds-mode)
   (helm-migemo-mode 1)
   #+end_src

** lsp

   #+begin_src emacs-lisp :tangle inits/20-lsp.el
   (el-get-bundle lsp-mode)
   (el-get-bundle lsp-ui)
   (add-hook 'lsp-mode-hook 'lsp-ui-mode)
   (setq lsp-ui-doc-alignment 'window)
   #+end_src

** posframe

   #+begin_src emacs-lisp :tangle inits/20-posframe.el
   (el-get-bundle posframe)
   #+end_src

** smartparens

   #+begin_src emacs-lisp :tangle inits/20-smartparens.el
   (el-get-bundle smartparens)
   (require 'smartparens-config)
   #+end_src

** uniquify

   #+begin_src emacs-lisp :tangle inits/20-uniquify.el
   ;; 同じ名前のファイルを開いている時に祖先ディレクトリ名を表示してくれてわかりやすくしてくれるやつ
   (require 'uniquify) ;; includes Emacs
   (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
   #+end_src

** 20-yasnippet.el

   #+begin_src emacs-lisp :tangle inits/20-yasnippet.el
   (el-get-bundle yasnippet)
   (yas-global-mode 1)

   (with-eval-after-load 'pretty-hydra
     (pretty-hydra-define
       yasnippet-hydra (:separator "-" :title "Yasnippet" :foreign-key warn :quit-key "q" :exit t)
       ("Edit"
        (("n" yas-new-snippet        "New")
         ("v" yas-visit-snippet-file "Visit"))

        "Other"
        (("i" yas-insert-snippet  "Insert")
         ("l" yas-describe-tables "List")
         ("r" yas-reload-all      "Reload all")))))
   #+end_src

** company

   #+begin_src emacs-lisp :tangle inits/30-company.el
   (el-get-bundle company-mode)
   (with-eval-after-load 'company
     ;; active
     (define-key company-active-map (kbd "C-s") 'company-search-candidates))
   #+end_src

** 30-flycheck.el

   #+begin_src emacs-lisp :tangle inits/30-flycheck.el
   (el-get-bundle flycheck)
   (el-get-bundle flycheck-pos-tip)

   (with-eval-after-load 'flycheck
     (flycheck-pos-tip-mode))
   #+end_src

** 30-git-gutter-fringe.el

   #+begin_src emacs-lisp :tangle inits/30-git-gutter-fringe.el
   (el-get-bundle git-gutter-fringe)
   (global-git-gutter-mode t)
   #+end_src

** 30-highlight-indent-guides.el

   #+begin_src emacs-lisp :tangle inits/30-highlight-indent-guides.el
   (el-get-bundle DarthFennec/highlight-indent-guides)
   (setq highlight-indent-guides-responsive "stack")
   #+end_src

** 30-notify-slack.el

   #+begin_src emacs-lisp :tangle inits/30-notify-slack.el
   (my/load-config "my-notify-slack-config")

   (setq my/notify-slack-enable-p t)

   (defun my/notify-slack-toggle ()
     (interactive)
     (if my/notify-slack-enable-p
         (setq my/notify-slack-enable-p nil)
       (setq my/notify-slack-enable-p t)))

   (defun my/notify-slack (channel text)
     (if my/notify-slack-enable-p
         (start-process "my/org-clock-slack-notifier" "*my/org-clock-slack-notifier*" "my-slack-notifier" channel text)))

   (defun my/notify-slack-times (text)
     (my/notify-slack my/notify-slack-times-channel text))
   #+end_src

** 30-projectile.el

   #+begin_src emacs-lisp :tangle inits/30-projectile.el
   (el-get-bundle projectile)

   (el-get-bundle helm-projectile)
   (helm-projectile-on)

   (projectile-mode)

   ;; 無視するディレクトリ
   (add-to-list 'projectile-globally-ignored-directories "tmp")
   (add-to-list 'projectile-globally-ignored-directories ".tmp")
   (add-to-list 'projectile-globally-ignored-directories "vendor")
   (add-to-list 'projectile-globally-ignored-directories ".sass-cache")
   (add-to-list 'projectile-globally-ignored-directories "coverage")
   (add-to-list 'projectile-globally-ignored-directories "cache")
   (add-to-list 'projectile-globally-ignored-directories "log")

   ;; 無視するファイル
   (add-to-list 'projectile-globally-ignored-files "gems.tags")
   (add-to-list 'projectile-globally-ignored-files "project.tags")
   (add-to-list 'projectile-globally-ignored-files "manifest.json")

   (setq projectile-completion-system 'ivy)
   (el-get-bundle counsel-projectile)

   (with-eval-after-load 'pretty-hydra
     (pretty-hydra-define
       projectile-hydra (:separator "-" :title "Projectile" :foreign-key warn :quit-key "q" :exit t)
       ("File"
        (("f" counsel-projectile-find-file "Find File")
         ("d" counsel-projectile-find-dir "Find Dir")
         ("r" projectile-recentf "Recentf"))

        "Other"
        (("p" (counsel-projectile-switch-project 'neotree-dir) "Switch Project")))))
   #+end_src

** 30-show-paren.el

   #+begin_src emacs-lisp :tangle inits/30-show-paren.el
   (show-paren-mode 1) ;; http://syohex.hatenablog.com/entry/20110331/1301584188
   #+end_src

** 30-skk.el

   #+begin_src emacs-lisp :tangle inits/30-skk.el
   (el-get-bundle ddskk)
   (add-hook 'skk-load-hook
             (lambda ()
               ;; コード中では自動的に英字にする。
               (require 'context-skk)

               (setq skk-comp-mode t) ;; 動的自動補完
               (setq skk-auto-insert-paren t) ;; 閉じ括弧の自動補完
               (setq skk-delete-implies-kakutei nil) ;; ▼モードで BS を押した時に一つ前の候補を表示
               (setq skk-sticky-key ";") ;; sticky-shift key
               (setq skk-henkan-strict-okuri-precedence t) ;; 見出し語と送り仮名がマッチした候補を優先して表示
               (setq skk-show-annotation t) ;; 単語の意味をアノテーションとして表示。例) いぜん /以前;previous/依然;still/

               ;; 半角で入力したい文字
               (setq skk-rom-kana-rule-list
                     (nconc skk-rom-kana-rule-list
                            '((";" nil nil)
                              (":" nil nil)
                              ("?" nil nil)
                              ("!" nil nil))))))

   (setq skk-extra-jisyo-file-list (list '("~/.emacs.d/skk-jisyo/SKK-JISYO.lisp" . japanese-iso-8bit-unix)))

   ;; AquaSKKのL辞書をつかうようにする
   (let ((l-dict (expand-file-name "~/Library/Application Support/AquaSKK/SKK-JISYO.L")))
     (if (file-exists-p l-dict)
         (setq skk-large-jisyo l-dict)))

   (el-get-bundle conao3/ddskk-posframe.el)
   (ddskk-posframe-mode 1)
   #+end_src

** 30-whitespace.el

   #+begin_src emacs-lisp :tangle inits/30-whitespace.el
   (require 'whitespace)
   (setq whitespace-style '(face           ; faceで可視化
                            trailing       ; 行末
                            tabs           ; タブ
                            spaces         ; スペース
                            empty          ; 先頭/末尾の空行
                            space-mark     ; 表示のマッピング
                            tab-mark))

   (setq whitespace-display-mappings
         '((space-mark ?\u3000 [?\u25a1])
           ;; WARNING: the mapping below has a problem.
           ;; When a TAB occupies exactly one column, it will display the
           ;; character ?\xBB at that column followed by a TAB which goes to
           ;; the next TAB column.
           ;; If this is a problem for you, please, comment the line below.
           (tab-mark ?\t [?\u00BB ?\t] [?\\ ?\t])))

   ;; スペースは全角のみを可視化
   (setq whitespace-space-regexp "\\(\u3000+\\)")

   ;; 行末の空白も表示
   (setq whitespace-trailing-regexp  "\\([ \u00A0]+\\)$")

   ;; 保存前に自動でクリーンアップ
   (setq whitespace-action '(auto-cleanup))
   (global-whitespace-mode 1)
   #+end_src

** 35-magit.el

   #+begin_src emacs-lisp :tangle inits/35-magit.el
   (el-get-bundle magit)
   #+end_src

** 36-forge.el

   #+begin_src emacs-lisp :tangle inits/36-forge.el
   ;; magit と github を連携させるやつ
   (el-get-bundle forge)

   (with-eval-after-load 'magit
     (require 'forge))
   #+end_src

** 40-dumb-jump.el

   #+begin_src emacs-lisp :tangle inits/40-dumb-jump.el
   (el-get-bundle dumb-jump)
   (setq dumb-jump-default-project "~/projects")
   (setq dumb-jump-selector 'ivy)

   (with-eval-after-load 'pretty-hydra
     (pretty-hydra-define dumb-jump-pretty-hydra
       (:foreign-keys warn :title "Dumb jump" :quit-key "q" :color blue :separator "-")
       ("Go"
        (("j" dumb-jump-go "Jump")
         ("o" dumb-jump-go-other-window "Other window"))

        "External"
        (("e" dumb-jump-go-prefer-external "Go external")
         ("x" dumb-jump-go-prefer-external-other-window "Go external other window"))

        "Lock"
        (("l" dumb-jump-quick-look "Quick look"))

        "Other"
        (("b" dumb-jump-back "Back")))))
   #+end_src

** 40-emacs-lisp.el

   #+begin_src emacs-lisp :tangle inits/40-emacs-lisp.el
   (defun my/emacs-lisp-mode-hook ()
     (display-line-numbers-mode 1)
     (company-mode 1)
     (smartparens-mode 1)
     (turn-on-smartparens-strict-mode))
   (add-hook 'emacs-lisp-mode-hook 'my/emacs-lisp-mode-hook)

   (defun my/insert-all-the-icons-code (family)
     (let* ((candidates (all-the-icons--read-candidates-for-family family))
            (prompt     (format "%s Icon: " (funcall (all-the-icons--family-name family))))
            (selection  (completing-read prompt candidates nil t)))
       (insert "(all-the-icons-" (symbol-name family) " \"" selection "\")")))

   (with-eval-after-load 'major-mode-hydra
     (major-mode-hydra-define emacs-lisp-mode (:separator "-" :quit-key "q" :title (concat (all-the-icons-fileicon "elisp") " Emacs Lisp"))
       ("Describe"
        (("F" counsel-describe-function "Function")
         ("V" counsel-describe-variable "Variable"))

        "Insert Icon Code"
        (("@a" (my/insert-all-the-icons-code 'alltheicon) "All the icons")
         ("@f" (my/insert-all-the-icons-code 'fileicon)   "File icons")
         ("@F" (my/insert-all-the-icons-code 'faicon)     "FontAwesome")
         ("@m" (my/insert-all-the-icons-code 'material)   "Material")
         ("@o" (my/insert-all-the-icons-code 'octicon)    "Octicon")
         ("@w" (my/insert-all-the-icons-code 'wicon)      "Weather")))))
   #+end_src

** 40-es6.el

   #+begin_src emacs-lisp :tangle inits/40-es6.el
   (el-get-bundle js2-mode)
   (defun my/js2-mode-hook ()
     (flycheck-mode 1)
     (setq flycheck-disabled-checkers '(javascript-standard javascript-jshint))

     (company-mode 1)
     (turn-on-smartparens-strict-mode)

     (setq js2-basic-offset 2))
   (add-to-list 'auto-mode-alist '("\\.es6$" . js2-mode))
   (add-hook 'js2-mode-hook 'my/js2-mode-hook)
   #+end_src

** 40-gnuplot.el

   #+begin_src emacs-lisp :tangle inits/40-gnuplot.el
   (el-get-bundle gnuplot-mode)
   #+end_src

** 40-markdown.el

   #+begin_src emacs-lisp :tangle inits/40-markdown.el
   (el-get-bundle markdown-mode)
   #+end_src

** 40-ruby.el

   #+begin_src emacs-lisp :tangle inits/40-ruby.el
   (el-get-bundle rbenv)
   (global-rbenv-mode)
   (el-get-bundle enh-ruby-mode)

   (with-eval-after-load 'enh-ruby-mode
     (setq enh-ruby-add-encoding-comment-on-save nil)
     (setq enh-ruby-deep-indent-paren nil) ;; 有効にするとインデントが気持ち悪いのでOFF
     (setq enh-ruby-bounce-deep-indent t))

   ;; TODO: flycheck-mode 用の設定。単に有効にすると警告が多過ぎて無理
   (defun my/enh-ruby-mode-hook ()
     (company-mode 1)
     (lsp)
     (lsp-ui-mode 1)
     (turn-on-smartparens-strict-mode)
     (display-line-numbers-mode 1))

   (add-hook 'enh-ruby-mode-hook 'my/enh-ruby-mode-hook)
   (add-to-list 'context-skk-programming-mode 'enh-ruby-mode)

   (with-eval-after-load 'major-mode-hydra
     (major-mode-hydra-define enh-ruby-mode (:quit-key "q" :title (concat (all-the-icons-alltheicon "ruby-alt") " Ruby commands"))
       ("Enh Ruby"
        (("{" enh-ruby-toggle-block "Toggle block")
         ("e" enh-ruby-insert-end "Insert end"))

        "LSP"
        (("i" lsp-ui-imenu "Imenu")
         ("f" lsp-ui-flycheck-list "Flycheck list"))

        "RSpec"
        (("s" rspec-verify "Run associated spec")
         ("m" rspec-verify-method "Run method spec")
         ("r" rspec-rerun "Rerun")
         ("l" rspec-run-last-failed "Run last failed"))

        "REPL"
        (("I" inf-ruby "inf-ruby"))

        "Other"
        (("j" dumb-jump-go "Dumb Jump")))))
   #+end_src

** 40-scss.el

   #+begin_src emacs-lisp :tangle inits/40-scss.el
   (el-get-bundle rainbow-mode)
   (with-eval-after-load 'scss-mode
     (setq css-indent-offset 2))
   (defun my/scss-mode-hook ()
     (flycheck-mode 1)

     (setq-local lsp-prefer-flymake nil) ;; flycheck が有効にならなくなるのを防ぐ
     (lsp)
     (lsp-ui-mode -1) ;; lsp-ui が有効だと画面上でガチャガチャ height とかの説明をしてうざいので

     ;; lsp-ui とかより後に設定しないと上書きされるのでここに移動した
     (setq-local flycheck-checker 'scss-stylelint)
     (setq-local flycheck-check-syntax-automatically '(save new-line idle-change))

     (company-mode 1)
     (display-line-numbers-mode 1)

     (rainbow-mode))
   (add-hook 'scss-mode-hook 'my/scss-mode-hook)

   (with-eval-after-load 'major-mode-hydra
     (major-mode-hydra-define scss-mode (:quit-key "q" :title (concat (all-the-icons-alltheicon "css3") " CSS"))
       ("Edit"
        (("v" my/replace-var "replace-var")))))
   #+end_src

** 40-view.el

   #+begin_src emacs-lisp :tangle inits/40-view.el
   ;; view-mode 用の設定

   ;; (define-key projectile-rails-mode-map (kbd "C-c r") 'pretty-hydra-projectile-rails-find/body)

   (defun my/setup-view-mode-keymap ()
       (let ((keymap view-mode-map))
         (define-key keymap (kbd "h") 'backward-char)
         (define-key keymap (kbd "j") 'next-line)
         (define-key keymap (kbd "k") 'previous-line)
         (define-key keymap (kbd "l") 'forward-char)

         (define-key keymap (kbd "e") 'forward-word)

         (define-key keymap (kbd "b")   'scroll-down)
         (define-key keymap (kbd "SPC") 'scroll-up)

         (define-key keymap (kbd "g") 'beginning-of-buffer)
         (define-key keymap (kbd "G") 'end-of-buffer)
         (define-key keymap (kbd "<") 'beginning-of-buffer)
         (define-key keymap (kbd ">") 'end-of-buffer)))

   (defun my/view-mode-hook ()
     (my/setup-view-mode-keymap))

   (add-hook 'view-mode-hook 'my/view-mode-hook)

   (defun my/toggle-view-mode ()
     "view-mode と通常モードの切り替えコマンド"
     (interactive)
     (cond (view-mode
            (hl-line-mode -1)
            (view-mode -1))
           (t
            (hl-line-mode 1)
            (view-mode 1))))
   #+end_src

** 40-yaml.el

   #+begin_src emacs-lisp :tangle inits/40-yaml.el
   (el-get-bundle yaml-mode)
   (defun my/yaml-mode-hook ()
     (highlight-indent-guides-mode 1))

   (add-hook 'yaml-mode-hook 'my/yaml-mode-hook)
   #+end_src

** 41-rails.el

   #+begin_src emacs-lisp :tangle inits/41-rails.el
   (el-get-bundle haml-mode)
   (el-get-bundle projectile-rails)
   (projectile-rails-global-mode 1)

   (defun my/projectile-rails-find-uploader ()
     "Find a Uploader."
     (interactive)
     (projectile-rails-find-resource
      "uploader: "
      '(("app/uploaders/" "\\(.+\\)\\.rb$"))
      "app/uploaders/${filename}.rb"))

   (defun my/projectile-rails-find-admin ()
     "Find a ActiveAdmin file."
     (interactive)
     (projectile-rails-find-resource
      "admin: "
      '(("app/admin/" "\\(.+\\)\\.rb$"))
      "app/admin/${filename}.rb"))

   (defun my/projectile-rails-find-form-object ()
     "Find a Form Object."
     (interactive)
     (projectile-rails-find-resource
      "form object: "
      '(("app/models/forms/" "\\(.+\\)\\.rb$"))
      "app/models/forms/${filename}.rb"))

   (defun my/projectile-rails-find-vue ()
     "Find a Vue."
     (interactive)
     (projectile-rails-find-resource
      "vue: "
      '(("app/javascript/" "\\(.+\\)\\.vue$"))
      "app/javascript/${filename}.vue"))

   (defun my/projectile-rails-find-webpack-js ()
     "Find a Webpack js."
     (interactive)
     (projectile-rails-find-resource
      "webpack js: "
      '(("app/javascript/" "\\(.+\\)\\.js$"))
      "app/javascript/${filename}.js"))

   (with-eval-after-load 'pretty-hydra
     (pretty-hydra-define pretty-hydra-projectile-rails-find (:separator "-" :color blue :foreign-keys warn :title "Projectile Rails" :quit-key "q")
       ("Current"
        (("M" projectile-rails-find-current-model      "Current model")
         ("V" projectile-rails-find-current-view       "Current view")
         ("C" projectile-rails-find-current-controller "Current controller")
         ("H" projectile-rails-find-current-helper     "Current helper")
         ("P" projectile-rails-find-current-spec       "Current spec")
         ("Z" projectile-rails-find-current-serializer "Current serializer"))

        "App"
        (("m" projectile-rails-find-model           "Model")
         ("v" projectile-rails-find-view            "View")
         ("c" projectile-rails-find-controller      "Controller")
         ("h" projectile-rails-find-helper          "Helper")
         ("a" my/projectile-rails-find-admin        "ActiveAdmin")
         ("f" my/projectile-rails-find-form-object  "Form object")
         ("@" projectile-rails-find-mailer          "Mailer")
         ("V" my/projectile-rails-find-vue          "Vue")
         ("J" my/projectile-rails-find-webpack-js   "Webpack js")
         ("u" my/projectile-rails-find-uploader     "Controller")
         ("!" projectile-rails-find-validator       "Validator")
         ;; ("y" projectile-rails-find-layout       "Layout")
         ("z" projectile-rails-find-serializer      "Serializer"))

        "Assets"
        (("j" projectile-rails-find-javascript  "Javascript")
         ;; ("w" projectile-rails-find-component)
         ("s" projectile-rails-find-stylesheet  "CSS"))

        "Other"
        (("n" projectile-rails-find-migration    "Migration")
         ("r" projectile-rails-find-rake-task    "Rake task")
         ("i" projectile-rails-find-initializer  "Initializer")
         ("l" projectile-rails-find-lib          "Lib")
         ("p" projectile-rails-find-spec         "Spec")
         ("t" projectile-rails-find-locale       "Translation"))

        "Single Files"
        (("R" projectile-rails-goto-routes   "routes.rb")
         ("G" projectile-rails-goto-gemfile  "Gemfile")
         ("D" projectile-rails-goto-schema   "schema.rb"))))
     (define-key projectile-rails-mode-map (kbd "C-c r") 'pretty-hydra-projectile-rails-find/body))
   #+end_src

** 41-vue.el

   #+begin_src emacs-lisp :tangle inits/41-vue.el
   (define-auto-insert "\\.vue$" "template.vue")

   (el-get-bundle vue-mode)
   (el-get-bundle hlissner/emacs-pug-mode)
   (defun my/css-mode-hook ()
     ;; vue-mode では scss は css-mode が適用される
     ;; https://github.com/AdamNiederer/vue-mode/blob/031edd1f97db6e7d8d6c295c0e6d58dd128b9e71/vue-mode.el#L63
     (setq-local flycheck-checker 'css-stylelint)
     (rainbow-mode 1))

   (defun my/vue-mode-hook ()
     (display-line-numbers-mode t)
     (lsp)
     (flycheck-mode 1))

   (add-hook 'css-mode-hook 'my/css-mode-hook)
   (add-hook 'vue-mode-hook 'my/vue-mode-hook)

   (with-eval-after-load 'major-mode-hydra
     (major-mode-hydra-define css-mode (:quit-key "q" :title (concat (all-the-icons-alltheicon "css3") " CSS"))
       ("Edit"
        (("v" my/replace-var "replace-var")))))
   #+end_src

** 42-rspec.el

   #+begin_src emacs-lisp :tangle inits/42-rspec.el
   (el-get-bundle rspec-mode)

   ;; rspec 実行バッファで byebug などで止った際に
   ;; C-x C-q したら inf-ruby が動くようにする
   ;; byebug か binding.irb 推奨。
   ;; binding.pry は何故かまともに動かない
   (add-hook 'after-init-hook 'inf-ruby-switch-setup)

   ;; C-c C-c で現在の行のテストを実行
   (define-key rspec-mode-map (kbd "C-c C-c") 'rspec-verify-single)
   #+end_src

** 50-browse-at-point.el

   #+begin_src emacs-lisp :tangle inits/50-browse-at-point.el
   (el-get-bundle browse-at-remote)
   #+end_src

** 50-ido.el

   #+begin_src emacs-lisp :tangle inits/50-ido.el
   (ido-mode 1) ;; includes Emacs
   (setq ido-enable-flex-matching t)
   #+end_src

** 50-multiple-cursor.el

   #+begin_src emacs-lisp :tangle inits/50-multiple-cursor.el
   (el-get-bundle multiple-cursors)
   #+end_src
* Footnotes
* COMMENT Local Variables                          :ARCHIVE:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:
