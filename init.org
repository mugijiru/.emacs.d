#+TODO: TODO(t) | DONE(o)
#+HUGO_BASE_DIR: ./hugo/
#+HUGO_SECTION: ./
#+title: 麦汁三昧
#+author: mugijiru
#+chapter: true
#+toc: headlines 2
#+HUGO_LEVEL_OFFSET: 1

* Top
  :PROPERTIES:
  :EXPORT_FILE_NAME: _index
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :chapter true
  :END:

** Emacs の設定

   麦汁の Emacs の設定ファイルの一部を解説しているページです。

   https://github.com/mugijiru/.emacs.d/blob/master/init.org に記載している内容を
   ox-hugo を使って Webサイトに仕立て上げています。

*** 注意点

    まだ全ての設定を init.org に記載できていないので
    極一部の設定ファイルのみの解説となります。

    他の設定については順次移行していきます。

* 基本設定
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: basics
  :END:

** 基本設定
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>1. </b>" :weight 1 :disableToc true
   :END:
   #+TOC: nil
   #+OPTIONS: toc:nil

   Emacs の基本動作に関わる部分をここでは設定している

   - [[*ガベージコレクション][ガベージコレクション]] :: メモリの開放関係の設定

** ガベージコレクション
   :PROPERTIES:
   :EXPORT_FILE_NAME: gcmh
   :END:

*** 概要
    ガベージコレクションには gcmh というのを利用してみている。

    https://github.com/emacsmirror/gcmh

    普段は GC を控えめにしながら
    操作してない間に GC が走るような作りになっている。便利そう。

*** インストール
    #+begin_src emacs-lisp :tangle inits/00-gc.el
    (el-get-bundle gcmh)
    #+end_src

    これだけで有効化もされる。

*** その他

    以前の設定も折り畳んで残しておく

    #+begin_details
    #+begin_summary
    使わなくなったコード
    #+end_summary
    gcmh を入れる前に設定していたコード。
    gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。

    #+begin_src emacs-lisp
    ;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf
    ;; Increase threshold to fire garbage collection
    (setq gc-cons-threshold 1073741824)
    (setq garbage-collection-messages t)

    ;; Run GC every 60 seconds if emacs is idle.
    (run-with-idle-timer 60.0 t #'garbage-collect)
    #+end_src
    #+end_details


* 編集系
** auto-insert
   ファイルを新規作成した時に
   ファイル名に応じたテンプレートを挿入する機能。
   Emacs が標準で持ってるライブラリなのでインストールは不要

*** 設定

    Emacs の設定は .emacs.d の中に閉じ込めたいので
    auto-insert のテンプレートも ~~/.emacs.d/insert~ に閉じ込める設定にしている。

    #+begin_src emacs-lisp :tangle inits/20-auto-insert.el
    (custom-set-variables '(auto-insert-directory "~/.emacs.d/insert/"))
    #+end_src

*** 有効化

    あとは単に有効化している。

    #+begin_src emacs-lisp :tangle inits/20-auto-insert.el
    (auto-insert-mode 1)
    #+end_src

*** 他の設定

    ファイル名を正規表現でマッチさせてテンプレートが選択されるので
    各言語やフレームワーク毎に設定を入れることにしている。

    実際は今のところ inits/41-vue.el でのみ追加設定を入れている。

* キーバインド
   :PROPERTIES:
   :EXPORT_HUGO_SECTION: keybinds
   :END:
** キーバインド
   :PROPERTIES:
   :EXPORT_FILE_NAME: _index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pre "<b>2. </b>" :weight 2 :disableToc true
   :END:

   ここでは全体に関わるキーバインド系の設定を記載している。

   - [[*sticky-control][sticky-control]] :: Control の入力を sticky にしてくれるやつ

** sticky-control
   :PROPERTIES:
   :EXPORT_FILE_NAME: sticky-control
   :END:

*** 概要
    指定したキーを2回叩いたら
    Control が押されてるような状態にしてくれるプラグイン。

    その2回の間隔はデフォルトだと 0.5 秒以内となっている。
    そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる

    さらに ~sticky-control-shortcuts~ に指定されてる一部のキーについては
    sticky 用のキーを押した直後に shortcuts のキーを押すと
    Control を押している状態でそのキーを押したことになる。

    例えば私は ~,~ を sticky 用のキーにしていて
    shortcuts に ~c~ を入れているので
    ~,c~ と素早くタイプをすればそれだけで ~C-c~ が押された状態になる。

*** インストール

    まずは el-get-bundle でインストール。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (el-get-bundle sticky-control)
    #+end_src

    ちなみにレシピは公式ではなかったので
    とりあえず自分の環境で使えるように自作レシピを置いている。

    #+begin_src emacs-lisp :tangle recipes/sticky-control.rcp
    (:name sticky-control
           :description "save your left little finger"
           :type http
           :url "https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el"
           :features "sticky-control")
    #+end_src

    元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど
    最近そこからは取得できなくなったので
    https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el
    から取得して利用している

*** 設定

    まずは「2回叩いたら Control を押している状態になる」キーを指定する。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (sticky-control-set-key 'sticky-control-key ?,)
    #+end_src

    私は ~,~ を sticky-control のキーにしているのでこの指定。

    そして次に ~sticky-control-shortuts~ の指定。
    ここに指定しておくと、
    例えば ~,c~ と素早くタイプすることで ~C-c~ が入力された状態とすることができる。

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (setq sticky-control-shortcuts
          '((?c . "\C-c")
            (?g . "\C-g")
            (?k . "\C-k")
            (?a . "\C-a")
            (?e . "\C-e")
            (?n . "\C-n")
            (?o . "\C-o")
            (?p . "\C-p")
            (?j . "\C-j")
            (?f . "\C-f")
            (?b . "\C-b")
            (?x . "\C-x")
            (?r . "\C-r")
            (?s . "\C-s")))
    #+end_src

    結構な数を指定しているけど、普段そんなに使えているわけでもない。
    まあ、大体 Control を押しながら使いそうなところは押さえてあるので
    何も考えずとも使えるようにしてある。

*** 有効化
    最後に有効化

    #+begin_src emacs-lisp :tangle inits/80-sticky-control.el
    (sticky-control-mode)
    #+end_src

* ナビゲーション系
** avy

   https://github.com/abo-abo/avy
   好きな文字とか単語の場所にジャンプするためのパッケージ。
*** インストール

    #+begin_src emacs-lisp :tangle inits/50-avy.el
    (el-get-bundle avy)
    #+end_src
*** 設定

    文字の上に重なると元の文字列がよくわからなくなるので、
    移動先の文字の前に表示するようにしている

    #+begin_src emacs-lisp :tangle inits/50-avy.el
    (setq avy-style 'pre)
    #+end_src
*** キーバインド

    グローバルなキーバインドを汚染したくなかったので
    ひとまず Hydra を定義している。

    #+begin_src emacs-lisp :tangle inits/50-avy.el
    (with-eval-after-load 'pretty-hydra
      (pretty-hydra-define avy-hydra
        (:separator "-" :title "avy" :foreign-key warn :quit-key "q" :exit t)
        ("Char"
         (("c" avy-goto-char       "Char")
          ("C" avy-goto-char-2     "Char 2")
          ("x" avy-goto-char-timer "Char Timer"))

         "Word"
         (("w" avy-goto-word-1 "Word")
          ("W" avy-goto-word-0 "Word 0"))

         "Line"
         (("l" avy-goto-line "Line"))

         "Other"
         (("r" avy-resume "Resume")))))
    #+end_src


    |-----+-------------------------------|
    | Key | 効果                          |
    |-----+-------------------------------|
    | c   | 1文字からの絞り込み           |
    | C   | 2文字から絞り込み             |
    | x   | 任意の文字列からの絞り込み    |
    | w   | 1文字絞り込んで単語先頭に移動 |
    | W   | 絞り込みなしの単語移動        |
    | l   | 列移動                        |
    | r   | 繰り返し同じコマンドを実行    |
    |-----+-------------------------------|

* UI 系
** Neotree                                                      :replacement:

   https://github.com/jaypei/emacs-neotree

   Emacs でフォルダのツリー表示ができるやつ。
   メンテは活発じゃないようなので、その内乗り換えたい。

*** レシピ

    Neotree でメンテされているのは dev ブランチだけど
    el-get の公式のレシピでは master ブランチを見ているので
    自前で recipe を用意してそれを使っている。

    #+begin_src emacs-lisp :tangle recipes/emacs-neotree-dev.rcp
    (:name emacs-neotree-dev
           :website "https://github.com/jaypei/emacs-neotree"
           :description "An Emacs tree plugin like NerdTree for Vim."
           :type github
           :branch "dev"
           :pkgname "jaypei/emacs-neotree")
    #+end_src

*** インストール
    #+begin_src emacs-lisp :tangle inits/40-neotree.el
    (el-get-bundle emacs-neotree-dev)
    #+end_src

*** 使わなくなったコード

    元々設定していたが、
    counsel-projectile を使ってると
    projectile-switch-project-action を設定していても反映されず
    意味がないのに気付いたので使わなくなった

    https://github.com/mugijiru/.emacs.d/pull/183/files#r541843206

    #+begin_src emacs-lisp
    (setq projectile-switch-project-action 'neotree-projectile-action)
    #+end_src

*** テーマの設定

    GUI で起動している時はアイコン表示し
    そうでない場合は ▾ とかで表示する

    #+begin_src emacs-lisp :tangle inits/40-neotree.el
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
    #+end_src

    のだけど、
    実際に今使ってるやつだともっとグラフィカルな表示なので
    all-the-icons の設定で上書きしている気がするので要確認

*** major-mode-hydra

    いちいちキーバインドを覚えてられないので
    major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。

    とはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。

    #+begin_src emacs-lisp :tangle inits/40-neotree.el
    (with-eval-after-load 'major-mode-hydra
      (major-mode-hydra-define neotree-mode (:separator "-" :quit-key "q" :title (concat (all-the-icons-octicon "list-unordered") " Neotree"))
        ("Nav"
         (("u"   neotree-select-up-node   "Up")
          ("g"   neotree-refresh          "Refresh")
          ("Q"   neotree-hide             "Hide"))

         "File"
         (("a"   neo-open-file-ace-window "Ace")
          ("N"   neotree-create-node      "Create")
          ("R"   neotree-rename-node      "Rename")
          ("C"   neotree-copy-node        "Copy")
          ("D"   neotree-delete-node      "Delete")
          ("SPC" neotree-quick-look       "Look")
          ;; ("d" neo-open-dired "Dired")
          ;; ("O" neo-open-dir-recursive   "Recursive")
          )
         "Toggle"
         (("z" neotree-stretch-toggle     "Size"        :toggle (not (neo-window--minimize-p)))
          ("h" neotree-hidden-file-toggle "Hidden file" :toggle neo-buffer--show-hidden-file-p)))))
    #+end_src

**** キーバインド
***** ナビゲーション
      |-----+------------------|
      | Key | 効果             |
      |-----+------------------|
      | u   | 上のノードに移動 |
      | g   | 再描画           |
      | Q   | Neotree を隠す   |
      |-----+------------------|

***** ファイル操作

      |-----+--------------------------------------------------------------|
      | Key | 効果                                                         |
      |-----+--------------------------------------------------------------|
      | a   | ファイルを開く。その際に ace-window で開く window を指定する |
      | N   | 新しいノードを作る                                           |
      | R   | ノードの名前を変える                                         |
      | C   | ノードのコピー                                               |
      | D   | ノードの削除                                                 |
      | SPC | クイックルック                                               |
      |-----+--------------------------------------------------------------|

***** Toggle

      |-----+--------------------------------------------|
      | Key | 効果                                       |
      |-----+--------------------------------------------|
      | z   | Neotree のサイズを大きくしたり小さくしたり |
      | h   | 隠しファイルを表示したり隠したり           |
      |-----+--------------------------------------------|

* フレームワーク系
** Ember.js 用の設定

   Ember.js 用の Emacs の拡張としては
   ~ember-mode~ と ~handlebars-mode~ が存在する

*** ember-mode                                                       :unused:

    https://github.com/madnificent/ember-mode

    Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。
    実は麦汁さんは使えてない。

    インストールするだけではダメで、
    ember-mode を明示的に起動しないといけない。

    そのためには dir-locals を使うとか
    projectile なんかがやってるように
    フォルダ構成から判定させるみたいなことが必要そう。だるい。

    というわけで死蔵中。

    ついでにいうとキーバインドもだるい系なので
    使う時は Hydra を用意した方が良さそう

    #+begin_src emacs-lisp :tangle inits/40-ember.el
    (el-get-bundle madnificent/ember-mode)
    #+end_src

*** handlebars-mode                                             :improvement:

    https://github.com/danielevans/handlebars-mode

    Handlebars を書くためのモード。

    syntax highlight と、いくつかの編集機能を備えている。
    が、今のところ麦汁さんは syntax highlight しか使えてない。

    編集コマンドは [[https://github.com/jerrypnz/major-mode-hydra.el][major-mode-hydra]] で使えるようにしてあげれば良さそう

    #+begin_src emacs-lisp :tangle inits/40-ember.el
    (el-get-bundle handlebars-mode)
    #+end_src

* 設定ファイルのテスト関係プラグイン
** mocker.el                                                         :unused:

   https://github.com/sigma/mocker.el

   Emacs Lisp のテストで使う Mock ライブラリ。

   使おうと思って導入したけど、
   自分のやりたいことはちょっと違ったので死蔵中

   便利そうなのでとりあえず置いといている。

   #+begin_src emacs-lisp :tangle inits/99-mocker.el
   (el-get-bundle sigma/mocker.el)
   #+end_src

** with-simulated-input.el

   https://github.com/DarwinAwardWinner/with-simulated-input

   入力をシミュレートするためのプラグイン。

   公式のドキュメントにあるように

   #+begin_src emacs-lisp
   (with-simulated-input
       "hello SPC world RET"
     (read-string "Say hello to the world: "))
   #+end_src

   を評価すると
   read-string に対して「hello world」を入力したことになるので
   echo エリアに「hello world」と表示される。

   これで何が嬉しいかというと
   Emacs Lisp でやっていることはインタラクティブな部分が大きいので
   そういった要素をテストできるようになる。

   具体的な使用例は [[*test:my/org-todo][test:my/org-todo]] で示す。

   #+begin_src emacs-lisp :tangle inits/99-with-simulated-input.el
   (el-get-bundle DarwinAwardWinner/with-simulated-input)
   #+end_src

* テストコード

  一部のコマンドなどの設定を書き始めているので設けたセクション。

  暫定的にここに置いているが設定と近い方が良さそうなので
  いずれドキュメント内の位置を移動しそう。

** 実行方法

   テストする時は以下のように叩いたら動く。

   #+begin_src sh
   emacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el
   #+end_src

   今まで ~.emacs.d~ にいる状態でしか叩いたことないので
   他の場所にいる時に実行しても大丈夫かはわからない。

   単体でテストしたい時は

   #+begin_example
   -l ~/.emacs.d/inits/test/*-test.el
   #+end_example

   の部分を書き換えたらいいんじゃないかな。やったことないけど。

** run-tests

   読み込んだテストをまるっとテストするためのコードをとりあえず置いている。

   #+begin_src emacs-lisp :tangle inits/test/run-tests.el
  (if noninteractive
      (let ((ert-quiet t))
        (ert-run-tests-batch-and-exit)))
   #+end_src

   後述の [[*テストライブラリの読み込み][テストライブラリの読み込み]] などはここで担うべきかとも考えるが
   今はテストファイルが1つしかないので気にしないことにする。

** 68-my-org-commands-test

   org-mode 用に定義したコマンドや関数のテストコード

*** Setup
**** テストライブラリの読み込み

     標準でついてくる ert を採用しているのでそれを読み込んでいる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (require 'ert)
     #+end_src

**** el-get の設定の読み込み

     プラグイン管理には el-get を利用しているので
     その設定ファイルを読み込んでいる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     ;; プラグイン読み込みの前準備
     (load (expand-file-name (concat user-emacs-directory "/init-el-get.el")))
     #+end_src

**** テスト補助のプラグイン読み込み
***** with-simulated-input

      上で説明しているが、
      入力をシミュレートするためのプラグインをテストで利用しているので
      ここで読み込んでいる。

      #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
      ;; 入力シミュレート用のプラグイン
      (load (expand-file-name (concat user-emacs-directory "/inits/99-with-simulated-input")))
      #+end_src

**** 依存プラグインの読み込み                                   :improvement:

     テスト対象が依存しているプラグインを読み込んでいる。
     本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが
     現状だとその状態で GitHub Actions で動かせる方法がわからないので
     一旦個別に読み込むようにしている。

***** swiper

      ivy-read を使った機能のテストをするので読み込んでいる。

      #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
      (el-get-bundle abo-abo/swiper)
      #+end_src

**** テスト対象の読み込み

     テストしたいファイルをここで読んでる。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     ;; テスト対象の読み込み
     (load (expand-file-name (concat user-emacs-directory "/inits/68-my-org-commands.el")))
     #+end_src

*** ert-deftest
**** test:my/org-todo-keyword-strings

     ~org-todo-keywords~ から "|" という区切りを除外したり
     "(s)" とかのような高速アクセスのためのキーワードは
     ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (ert-deftest test:my/org-todo-keyword-strings ()
       "Test of `my/org-todo-keyword-strings'."
       (let ((org-todo-keywords '((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)"))))
         (should (equal '("TODO" "DOING" "WAIT" "DONE" "SOMEDAY")
                        (my/org-todo-keyword-strings)))))
     #+end_src

     なお、ここでテストしている関数では
     TODO キーワードを ivy で扱いやすいように整えているだけで
     実際の選択は別の関数が担っている

**** test:my/org-todo

     org-todo を ivy で選択する関数のテストを書いている。

     #+begin_src emacs-lisp :tangle inits/test/68-my-org-commands-test.el
     (ert-deftest test:my/org-todo ()
       "Test of `my/org-todo'."
       (let ((org-todo-keywords '((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)")))
             (result))
         ;; org-mode を読まずに済むように org-todo を差し替えてテストしている
         (cl-letf (((symbol-function 'org-todo)
                    (lambda (keyword)
                      (setq result keyword))))
           (with-simulated-input "DOI RET" (my/org-todo))
           (should (equal "DOING" result)))))
     #+end_src

     ポイントは cl-letf を使って、内部で叩いている関数 ~org-todo~ を一時的に

     #+begin_src emacs-lisp
     (lambda (keyword)
       (setq result keyword))
     #+end_src

     に差し替えているところ。

     org-mode を呼び出さずに代わりの関数に差し替えているので
     テストがしやすくなっている。Stub 的なやつかな。

     何度も使うならこの差し替え処理自体をテストヘルパーにしても良いかもしれない。

     また ivy で選択するので with-simulated-input を使って入力操作を代替している。便利。
