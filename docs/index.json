[
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/",
	"title": "with-simulated-input",
	"tags": [],
	"description": "",
	"content": "概要 with-simulated-input は入力処理をシミュレートするためのプラグイン。\n公式のドキュメントにあるように\n(with-simulated-input \u0026#34;hello SPC world RET\u0026#34; (read-string \u0026#34;Say hello to the world: \u0026#34;)) を評価すると read-string に対して「hello world」を入力したことになるので echo エリアに「hello world」と表示される。\nこれで何が嬉しいかというと Emacs Lisp でやっていることはインタラクティブな部分が大きいのでそういった要素をテストできるようになる。\n具体的な使用例は test:my/org-todo で示す。\nインストール el-get-bundle で GitHub からインストールしている\n(el-get-bundle DarwinAwardWinner/with-simulated-input) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/",
	"title": "基本設定",
	"tags": [],
	"description": "",
	"content": "Emacs の基本動作に関わる部分をここでは設定している\n exec-path PATH などの環境変数を shell と合わせる設定 auto-save 編集中状態の自動保存や編集前の状態のバックアップに関する設定 load-path Emacs Lisp が読み込める path の設定 savehist ミニバッファの履歴などを保存してくれる機能。 ガベージコレクション メモリの開放関係の設定  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/execution/",
	"title": "実行方法",
	"tags": [],
	"description": "",
	"content": "テストする時は以下のように叩いたら動く。\nemacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el 今まで .emacs.d にいる状態でしか叩いたことないので他の場所にいる時に実行しても大丈夫かはわからない。\n単体でテストしたい時は\n-l ~/.emacs.d/inits/test/*-test.el の部分を書き換えたらいいんじゃないかな。やったことないけど。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/",
	"title": "mocker.el",
	"tags": ["unused"],
	"description": "",
	"content": "概要 mocker.el は Emacs Lisp のテストで使う Mock ライブラリ。\n使おうと思って導入したけど、自分のやりたいことはちょっと違ったので死蔵中\n便利そうなのでとりあえず置いといている。\nインストール el-get で GitHub から取得している。\n(el-get-bundle sigma/mocker.el) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/run-tests/",
	"title": "run-tests",
	"tags": [],
	"description": "",
	"content": "読み込んだテストをまるっとテストするためのコードをとりあえず置いている。\n(if noninteractive (let ((ert-quiet t)) (ert-run-tests-batch-and-exit))) 後述の テストライブラリの読み込み などはここで担うべきかとも考えるが今はテストファイルが1つしかないので気にしないことにする。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/",
	"title": "キーバインド",
	"tags": [],
	"description": "",
	"content": "ここでは全体に関わるキーバインド系の設定を記載している。\n key-chord 同時押しというキーバインドを提供してくれるやつ sticky-control Control の入力を sticky にしてくれるやつ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/",
	"title": "my-org-commands-test",
	"tags": [],
	"description": "",
	"content": "org-mode 用に定義したコマンドや関数のテストコード\nSetup テストライブラリの読み込み 標準でついてくる ert を採用しているのでそれを読み込んでいる。\n(require \u0026#39;ert) el-get の設定の読み込み プラグイン管理には el-get を利用しているのでその設定ファイルを読み込んでいる。\n;; プラグイン読み込みの前準備 (load (expand-file-name (concat user-emacs-directory \u0026#34;/init-el-get.el\u0026#34;))) テスト補助のプラグイン読み込み with-simulated-input 上で説明しているが、入力をシミュレートするためのプラグインをテストで利用しているのでここで読み込んでいる。\n;; 入力シミュレート用のプラグイン (load (expand-file-name (concat user-emacs-directory \u0026#34;/inits/99-with-simulated-input\u0026#34;))) 依存プラグインの読み込み テスト対象が依存しているプラグインを読み込んでいる。本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが現状だとその状態で GitHub Actions で動かせる方法がわからないので一旦個別に読み込むようにしている。\nswiper ivy-read を使った機能のテストをするので読み込んでいる。\n(el-get-bundle abo-abo/swiper) テスト対象の読み込み テストしたいファイルをここで読んでる。\n;; テスト対象の読み込み (load (expand-file-name (concat user-emacs-directory \u0026#34;/inits/68-my-org-commands.el\u0026#34;))) ert-deftest test:my/org-todo-keyword-strings org-todo-keywords から \u0026ldquo;|\u0026rdquo; という区切りを除外したり \u0026ldquo;(s)\u0026rdquo; とかのような高速アクセスのためのキーワードは ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。\n(ert-deftest test:my/org-todo-keyword-strings () \u0026#34;Test of `my/org-todo-keyword-strings\u0026#39;.\u0026#34; (let ((org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;)))) (should (equal \u0026#39;(\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;DONE\u0026#34; \u0026#34;SOMEDAY\u0026#34;) (my/org-todo-keyword-strings))))) なお、ここでテストしている関数では TODO キーワードを ivy で扱いやすいように整えているだけで実際の選択は別の関数が担っている\ntest:my/org-todo org-todo を ivy で選択する関数のテストを書いている。\n(ert-deftest test:my/org-todo () \u0026#34;Test of `my/org-todo\u0026#39;.\u0026#34; (let ((org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;))) (result)) ;; org-mode を読まずに済むように org-todo を差し替えてテストしている (cl-letf (((symbol-function \u0026#39;org-todo) (lambda (keyword) (setq result keyword)))) (with-simulated-input \u0026#34;DOI RET\u0026#34; (my/org-todo)) (should (equal \u0026#34;DOING\u0026#34; result))))) ポイントは cl-letf を使って、内部で叩いている関数 org-todo を一時的に\n(lambda (keyword) (setq result keyword)) に差し替えているところ。\norg-mode を呼び出さずに代わりの関数に差し替えているのでテストがしやすくなっている。Stub 的なやつかな。\n何度も使うならこの差し替え処理自体をテストヘルパーにしても良いかもしれない。\nまた ivy で選択するので with-simulated-input を使って入力操作を代替している。便利。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/",
	"title": "ファイル編集",
	"tags": [],
	"description": "",
	"content": "ここにはファイル編集系の設定をまとめている\n auto-insert ファイル新規作成時にテンプレートを挿入する機能  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/",
	"title": "UI",
	"tags": [],
	"description": "",
	"content": "ここでは Emacs の UI を変更するようなものを載せている\n all-the-icons Emacs で様々なアイコンを表示できるようにするやつ helm 絞り込みインターフェースを提供するやつ helm-posframe Helm を posframe で使えるようにするやつ highlight-indent-guides インデント毎にラインを引いたりして見易くしてくれるやつ Neotree フォルダ構造を IDE みたいにツリー表示するやつ posframe いい感じの位置に child frame を表示する機能を提供するやつ toolbar Emacs 標準のボタンなどの UI 部分の設定 uniquify 同名ファイルを開いている時にどこのファイルかまで表示してくれるやつ zoom フォーカスが当たってるウインドウを大きく表示してくれるやつ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/",
	"title": "ナビゲーション",
	"tags": [],
	"description": "",
	"content": "ここではカーソル移動やファイル移動などのナビゲーション系の設定を記載していく\n ace-window 3つ以上にウインドウを分割している際のウインドウ切替を楽にしてくれるパッケージ avy 表示されてるところの好きな場所にさくっとジャンプするためのパッケージ dumb-jump カーソル下の関数とかの定義場所にジャンプしてくれるパッケージ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/framework-config/",
	"title": "フレームワーク用の設定",
	"tags": [],
	"description": "",
	"content": "開発に使っている各フレームワーク用の設定をここにまとめている。\n Ember.js Web フロントエンド MVC フレームワークである Ember.js 用の設定を書いている  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/",
	"title": "テスト用ツール",
	"tags": [],
	"description": "",
	"content": "自動テストを実行するにあたり、追加インストールしているパッケージをここに載せている\n with-simulated-input 入力処理をシミュレートしてくれるパッケージ mocker.el Mock/Stub するためのパッケージ。まだ使ってない  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/",
	"title": "テストコード",
	"tags": [],
	"description": "",
	"content": "一部のコマンドなどの設定を書き始めているので設けたセクション。\n暫定的にここに置いているが設定と近い方が良さそうなのでいずれドキュメント内の位置を移動しそう。\n 実行方法 とりあえず書かれているテストを動かす方法を書いている。 run-tests テスト全体を動かすための共通設定ファイルの説明 my-org-commands-test org-mode 用に自分が生やしたコマンドのテストファイルの解説  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/ace-window/",
	"title": "ace-window",
	"tags": [],
	"description": "",
	"content": "概要 Window 間の移動を ace-jump や avy のように表示されてる文字の Window に移動するやつ。\nWindow が2分割の時は文字も出ないで別の Window に移動してくれる。\nC-x o にデフォルトで設定されている other-window は別の window に順番に移動するコマンドなので大量に分割していると移動がしんどいのだが ace-window を使うと起動して 1 ストロークで移動できるので C-x o をデフォルトの other-window から ace-window そのまま置き換えても便利に使える。\nインストール いつも通り el-get でインストールしている。\n(el-get-bundle ace-window) 設定 キーバインドは別の箇所で定義しているが C-x o で ace-window が起動するようにしている。\nまた Hydra からは ace-swap-window が起動できるようにしている。\nace-window には色々な機能があるからそれ用の Hydra を別途定義してもいいかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/all-the-icons/",
	"title": "all-the-icons",
	"tags": [],
	"description": "",
	"content": "概要 all-the-icons は Emacs で様々なアイコンを表示できるようにして華やかにしてくれるパッケージです。 Neotree などでも対応していてアイコンでファイルの種類が表示されるようになってモダンな雰囲気が出ます。\nインストール いつも通り el-get-bundle で入れている。明示的に require している理由は忘れました。\n(el-get-bundle all-the-icons) (require \u0026#39;all-the-icons) フォントのインストール 以下のコマンドを叩くことでフォントをインストールすることができる。 all-the-icons のインストール直後に叩いておいたら普段は叩かなくて良いはず。\n(all-the-icons-install-fonts) all-the-icons の更新後は叩いた方がいいかもしれない\nキーバインド キーバインドは覚えられないし、使えるキーも大分埋まってるので、 pretty-hydra を使って all-the-icons 用の Hydra を用意している。\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define all-the-icons-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;All the icons\u0026#34; :exit t :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Insert\u0026#34; ((\u0026#34;a\u0026#34; all-the-icons-insert-alltheicon \u0026#34;All the icons\u0026#34;) (\u0026#34;f\u0026#34; all-the-icons-insert-fileicon \u0026#34;File icons\u0026#34;) (\u0026#34;F\u0026#34; all-the-icons-insert-faicons \u0026#34;FontAwesome\u0026#34;) (\u0026#34;m\u0026#34; all-the-icons-insert-material \u0026#34;Material\u0026#34;) (\u0026#34;o\u0026#34; all-the-icons-insert-octicon \u0026#34;Octicon\u0026#34;) (\u0026#34;w\u0026#34; all-the-icons-insert-wicon \u0026#34;Weather\u0026#34;) (\u0026#34;*\u0026#34; all-the-icons-insert \u0026#34;All\u0026#34;)))))    Key 効果     a all-the-icons で追加されてるアイコンを検索して挿入   f ファイルアイコンを検索して挿入   F FontAwesome アイコンを検索して挿入   m Material アイコンを検索して挿入   o Octicon のアイコンを検索して挿入   w 天気アイコンを検索して挿入   * 全てのアイコンを検索して挿入    フォントのインストールコマンドもここに収めてしまうのが良さそうな気がする\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/auto-insert/",
	"title": "auto-insert",
	"tags": [],
	"description": "",
	"content": "概要 auto-insert はファイルを新規作成した時にファイル名に応じたテンプレートを挿入する機能。\nEmacs が標準で持ってるライブラリなのでインストールは不要\n設定 Emacs の設定は .emacs.d の中に閉じ込めたいので auto-insert のテンプレートも ~/.emacs.d/insert に閉じ込める設定にしている。\n(custom-set-variables \u0026#39;(auto-insert-directory \u0026#34;~/.emacs.d/insert/\u0026#34;)) 有効化 あとは単に有効化している。\n(auto-insert-mode 1) 他の設定 ファイル名を正規表現でマッチさせてテンプレートが選択されるので各言語やフレームワーク毎に設定を入れることにしている。\n実際は今のところ inits/41-vue.el でのみ追加設定を入れている。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/auto-save/",
	"title": "auto-save",
	"tags": ["replacement"],
	"description": "",
	"content": "概要 編集中状態の自動保存や、編集前や保存直後の状態のバックアップに関する設定をここでは書いている。\nEmacs ではデフォルトでも編集中ファイルの自動保存や、編集前の状態の自動バックアップもしてくれるが開いているファイルとは違う場所に保存したりすることで、より便利になるのでいくつかの設定を入れている。\n設定 自動保存設定 デフォルトだと #hoge.txt# みたいなファイル名で作られる、自動保存に関する設定。\nまあこの自動保存されてやつを活用できてる気がしないのでこの自動保存自体不要な気はしているが、とりあえず場所を移動して邪魔にはならないようにはしている。\n自動保存のタイミング 自動保存のタイミングは\n auto-save-timeout auto-save-interval  で制御されている。\nまず auto-save-timeout で設定した秒数が経過すると再度自動保存が実行される。\nこれがデフォルトだと 30 秒なのだが、ちょっと長いのでその半分の 15 秒で保存されるように設定を変更している。\n(setq auto-save-timeout 15) また auto-save-interval で設定した回数のキーイベントが発生すると再度自動保存を実行する。\nこれもデフォルトだと 300 と結構なキーを叩く必要があるので 60 回としている。\n(setq auto-save-interval 60) 自動保存先を変更する 自動保存はそのままだと弄ってるファイルの場所に作られる。が、これは以下のようにすると ~/.emacs.d/backup/ 一応変更可能。\n(setq auto-save-file-name-transforms \u0026#39;((\u0026#34;.*\u0026#34; \u0026#34;~/.emacs.d/backup/\u0026#34; t))) ただ、デフォルト値が\n((\u0026#34;\\\\`/[^/]*:\\\\([^/]*/\\\\)*\\\\([^/]*\\\\)\\\\\u0026#39;\u0026#34; \u0026#34;/tmp/\\\\2\u0026#34; t)) なので .* にしているのは乱暴そうな気がしている。\nというわけで https://masutaka.net/chalow/2014-05-11-1.html に書かれているのを真似して\n((\u0026#34;~/\\\\([^/]*/\\\\)*\\\\([^/]*\\\\)$\u0026#34; \u0026#34;~/.emacs.d/backup/\\\\2\u0026#34; t)) とでもした方が良いかもしれない。\nバックアップファイル 自動保存とは別に、ファイルを開いた時点のバージョンや保存した時点のバージョンを取っておいてくれる自動バックアップ機能もあるのでその設定も弄っている。\nバックアップ先のフォルダ指定 デフォルトでは編集しているファイルと同じフォルダにバックアップファイルを作成するようになっている。\nだけど、こいつが結構邪魔なのでバックアップファイルは ~/.emacs.d/backup/ に全部保存するようにしている。\nまた、普段 tramp は使っていないが何かの拍子で使った時にバックアップが取られると邪魔そうなのでそれは保存しないようにしている。\n(setq backup-directory-alist \u0026#39;((\u0026#34;.*\u0026#34; . \u0026#34;~/.emacs.d/backup\u0026#34;) (,tramp-file-name-regexp . nil))) バージョン管理 バックアップにはバージョン管理機能もある。が、標準では無効化されている。\nとりあえず古いバージョンを引っ張り出せると便利かもと思って有効化している。\n(setq version-control t) が、実際それを使ったことはない。。。\nまた、古過ぎるバックアップファイルは要らないので、自動的に消されるように設定している。\n(setq delete-old-versions t) その他 Emacs の自動保存などについては http://yohshiy.blog.fc2.com/blog-entry-319.html によくまとめられているので、いずれその内容を設定に反映させたい。\nまた super-save というやつを使って実ファイルに自動保存したりしたらこれも不要になると思われる。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/avy/",
	"title": "avy",
	"tags": [],
	"description": "",
	"content": "概要 avy は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。 Vimium の f とかに似てる。\nインストール el-get で普通にインストールしている\n(el-get-bundle avy) 設定 文字の上に重なると元の文字列がよくわからなくなるので、移動先の文字の前に表示するようにしている\n(setq avy-style \u0026#39;pre) キーバインド グローバルなキーバインドを汚染したくなかったのでひとまず Hydra を定義している。\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define avy-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;avy\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Char\u0026#34; ((\u0026#34;c\u0026#34; avy-goto-char \u0026#34;Char\u0026#34;) (\u0026#34;C\u0026#34; avy-goto-char-2 \u0026#34;Char 2\u0026#34;) (\u0026#34;x\u0026#34; avy-goto-char-timer \u0026#34;Char Timer\u0026#34;)) \u0026#34;Word\u0026#34; ((\u0026#34;w\u0026#34; avy-goto-word-1 \u0026#34;Word\u0026#34;) (\u0026#34;W\u0026#34; avy-goto-word-0 \u0026#34;Word 0\u0026#34;)) \u0026#34;Line\u0026#34; ((\u0026#34;l\u0026#34; avy-goto-line \u0026#34;Line\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;r\u0026#34; avy-resume \u0026#34;Resume\u0026#34;)))))    Key 効果     c 1文字からの絞り込み   C 2文字から絞り込み   x 任意の文字列からの絞り込み   w 1文字絞り込んで単語先頭に移動   W 絞り込みなしの単語移動   l 列移動   r 繰り返し同じコマンドを実行    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/dumb-jump/",
	"title": "dumb-jump",
	"tags": [],
	"description": "",
	"content": "概要 dumb-jump は関数とかの定義されてる場所にお手軽にジャンプできるようにするパッケージ。めっちゃ色々な言語をサポートしている。\nインストール いつも通り el-get でインストールしている。\n(el-get-bundle dumb-jump) 設定 デフォルトプロジェクトの変更 デフォルトだと ~/ がデフォルトプロジェクトらしいがそんなに上の階層から調べられてもしょうがない気がするのでソースコードを置いているフォルダを指定している。\n(setq dumb-jump-default-project \u0026#34;~/projects\u0026#34;) 複数マッチした時に使う絞り込み 最近はできるだけ ivy を使うようにしているので dumb-jump でも ivy を使うように指定している。\n(setq dumb-jump-selector \u0026#39;ivy) キーバインド README に書いている hydra の設定をほぼパクってるけど pretty-hydra を使ってキーを定義している\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define dumb-jump-pretty-hydra (:foreign-keys warn :title \u0026#34;Dumb jump\u0026#34; :quit-key \u0026#34;q\u0026#34; :color blue :separator \u0026#34;-\u0026#34;) (\u0026#34;Go\u0026#34; ((\u0026#34;j\u0026#34; dumb-jump-go \u0026#34;Jump\u0026#34;) (\u0026#34;o\u0026#34; dumb-jump-go-other-window \u0026#34;Other window\u0026#34;)) \u0026#34;External\u0026#34; ((\u0026#34;e\u0026#34; dumb-jump-go-prefer-external \u0026#34;Go external\u0026#34;) (\u0026#34;x\u0026#34; dumb-jump-go-prefer-external-other-window \u0026#34;Go external other window\u0026#34;)) \u0026#34;Lock\u0026#34; ((\u0026#34;l\u0026#34; dumb-jump-quick-look \u0026#34;Quick look\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;b\u0026#34; dumb-jump-back \u0026#34;Back\u0026#34;)))))    Key 効果     j 定義場所にジャンプ   o 定義場所を別 window で開く   e 定義場所にジャンプ。ただし同じファイルより外部ファイルとのマッチを優先   x 定義場所を別 window で開く。ただし同じファイルより外部ファイルとのマッチを優先   l クイックルック。定義をツールチップ表示する   b 最後にジャンプされた場所に戻る。今は既に obsolute 扱い    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/framework-config/ember-js/",
	"title": "Ember.js",
	"tags": [],
	"description": "",
	"content": "概要 Ember.js 用の Emacs の拡張としては ember-mode と handlebars-mode が存在する\nember-mode ember-mode は Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。実は麦汁さんは使えてない。\nインストールするだけではダメで、 ember-mode を明示的に起動しないといけない。\nそのためには dir-locals を使うとか projectile なんかがやってるようにフォルダ構成から判定させるみたいなことが必要そう。だるい。\nというわけで死蔵中。\nついでにいうとキーバインドもだるい系なので使う時は Hydra を用意した方が良さそう\n(el-get-bundle madnificent/ember-mode) handlebars-mode handlebars-mode は Ember.js のテンプレートエンジンとして採用されている Handlebars を書くためのモード。\nsyntax highlight と、いくつかの編集機能を備えている。が、今のところ麦汁さんは syntax highlight しか使えてない。\n編集コマンドは major-mode-hydra で使えるようにしてあげれば良さそう\n(el-get-bundle handlebars-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/exec-path/",
	"title": "exec-path",
	"tags": [],
	"description": "",
	"content": "概要 Emacs は通常最小限の環境変数しか利用しないようになっている。\nが、それだと普段使う上で「ああ、このコマンドが使えなくてもどかしい……!」と感じてしまう。\nそこで exec-path-from-shell というのを使って Emacs が見える PATH 環境変数をシェルが見てる PATH 環境変数と揃うようにしている。\nインストール いつも通り el-get からインストールしている\n(el-get-bundle exec-path-from-shell) 有効化 理由は忘れたが Mac の環境でのみ有効化している。その内 Linux 環境でも有効化を試みた方が良さそう\n(when (memq window-system \u0026#39;(mac ns)) (exec-path-from-shell-initialize)) なお、これでシェルと共通の環境変数が使われるようになるのは デフォルトでは PATH と MANPATH のみである\nその他 なぜか以下のようなコメントを書いていた。普段使っている zsh で持ってる PATH は使わないのだろうか? :thinking_face:\n;; for exec path ;; use .bashrc setted path "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/helm/",
	"title": "helm",
	"tags": [],
	"description": "",
	"content": "概要 helm は anything.el の後継であり、インクリメンタルに候補の絞り込みをしたりする UI を提供する便利なパッケージ。\npeco とか fzf とかと似ているっちゃ似ているかな? fzf 使ったことないけど。\n一時期開発が止まってるようだったけど最近(2021年)はまた更新が活発になっている。\nただ、麦汁さんは ivy に乗り換えようとしているので helm の設定は頑張っていない。 helm-for-files が便利なのでまだ捨てられてないけど……。\nインストール helm で使いたい拡張として helm-descbinds と helm-ag というのがあるのでそれらも同時に入れている。\n(el-get-bundle helm) (el-get-bundle helm-descbinds) (el-get-bundle helm-ag) ただ descbinds は counsel-descbinds に置き換えたし helm-ag ももう使ってない気がする\n設定 オススメの設定が helm に同梱されている helm-config に入ってるのでまずはそれを読み込んでいる。\n(require \u0026#39;helm-config) また helm-descbinds を使えるように有効にしている。けど、上にも書いたけどもう counsel-descbinds に置き換えちゃったのよね……。\n(helm-descbinds-mode) あとは helm-migemo-mode というのを有効にしている。これがあると helm で検索する時に migemo れて便利。\n(helm-migemo-mode 1) ivy の方でも migemo 対応したいけどまだできてない……。\nその他 helm 系の設定は他の設定にも色々影響も大きそうなので読み込み順は結構早いタイミングにしている(init-loader で 20 を prefix にしている)\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/helm-posframe/",
	"title": "helm-posframe",
	"tags": [],
	"description": "",
	"content": "概要 helm-posframe は helm の拡張で Helm のバッファの表示を posframe を使うようにしてくれるやつ。\n実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなのでいずれ外すかもしれない。\nただ確か本体の方の挙動が気に入らなかったような気はする。\nインストール いつも通り el-get でインストール。 GitHub にあるのでそれを取得するようにしている。\n(el-get-bundle tumashu/helm-posframe) 有効化 (helm-posframe-enable) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/",
	"title": "highlight-indent-guides",
	"tags": [],
	"description": "",
	"content": "概要 highlight-indent-guides はインデント毎にラインを引いたりして見易くしてくれるパッケージ。通常のプログラムを書く時にも便利だけど、 YAML などのインデントがそのまま構造になるような言語を弄る時にとても便利。\nインストール これもいつも通り el-get でインストールしている。また GitHub にあるので、そこから直接インストールしている。\n(el-get-bundle DarthFennec/highlight-indent-guides) 設定 今いる行がどのインデントにいるのかをわかりやすくするために responsive モードを有効にしている。\n(setq highlight-indent-guides-responsive \u0026#34;stack\u0026#34;) defcustom で定義されてる変数なので custom-set-variables で設定した方がいいかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/key-chord/",
	"title": "key-chord",
	"tags": [],
	"description": "",
	"content": "概要 key-chord はキーを同時に押した時にコマンドを発動させるということができるようにしてくれるパッケージ。\nなのですが本家の方だと誤爆が多いということなのでそれを改善した zk-phi/key-chord の方を利用している。\nまあほとんど使えてないので改良版の恩恵をまだ受けてないけど……。\nインストール いつも通り el-get でインストールしている。本家の方じゃないので GitHub のリポジトリから突っ込んでいる。\n(el-get-bundle zk-phi/key-chord) 設定 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。\n(setq key-chord-two-keys-delay 0.15 key-chord-safety-interval-backward 0.1 key-chord-safety-interval-forward 0.15) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。\n改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動に使っている上に Hydra で叩けるやつでよく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。\n有効化 設定を入れた後は有効にするだけである。\n(key-chord-mode 1) 実際のキーバインド設定は各モードだったりグローバルキーバインドを設定しているファイルだったりで書く感じ。\nといいつつ現状では Hydra 起動のやつしか使ってないので、グローバルキーバインド設定でしか書いてない。\nその他 sticky-control も control 限定で似たようなことをしているので key-chord に全部置き換えできるかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/load-path/",
	"title": "load-path",
	"tags": [],
	"description": "",
	"content": "概要 load-path は Emacs の設定でも重要な項目でこのリストに追加されている path は load または require する際に走査される path となっている。\n即ち load-path を通しておけば、そこに置いている emacs lisp のファイルは簡単に読み出せるようになる。\nなお package-install や el-get を使っておけば基本的に自分で load-path を通す必要はない。\n秘匿情報を入れてるフォルダを読み込み可能にする パスワードなどの秘匿情報を持っている部分は ~/.emacs.d/secret というフォルダで管理している。そのためここに入ってる emacs lisp のファイルも読み込めるように load-path に追加している。\n(add-to-list \u0026#39;load-path (expand-file-name \u0026#34;~/.emacs.d/secret\u0026#34;)) my/load-config ~/.emacs.d/secret は個人マシンか会社マシンかによって置いてるデータが異なったりするためもしもファイルがなくてもエラーにならないような方法で load する方法が必要だった。\nというわけでファイルがなかったら読み込まずにメッセージを出力して終了するような関数を用意している。\n(defun my/load-config (file) (condition-case nil (load file) (file-missing (message \u0026#34;Load error: %s\u0026#34; file)))) ただ、これって結局\n(load file nil t) で十分な気もするので、置き換えを検討した方が良さそう。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/neotree/",
	"title": "Neotree",
	"tags": ["replacement"],
	"description": "",
	"content": "概要 Neotree は Emacs でフォルダのツリー表示ができるやつ。メンテは活発じゃないようなので、その内乗り換えたい。\nレシピ Neotree でメンテされているのは dev ブランチだけど el-get の公式のレシピでは master ブランチを見ているので自前で recipe を用意してそれを使っている。\n(:name emacs-neotree-dev :website \u0026#34;https://github.com/jaypei/emacs-neotree\u0026#34; :description \u0026#34;An Emacs tree plugin like NerdTree for Vim.\u0026#34; :type github :branch \u0026#34;dev\u0026#34; :pkgname \u0026#34;jaypei/emacs-neotree\u0026#34;) インストール 上に書いたレシピを使ってインストールしている。\n(el-get-bundle emacs-neotree-dev) 使わなくなったコード 元々設定していたが、 counsel-projectile を使ってると projectile-switch-project-action を設定していても反映されず意味がないのに気付いたので使わなくなった\nhttps://github.com/mugijiru/.emacs.d/pull/183/files#r541843206\n(setq projectile-switch-project-action \u0026#39;neotree-projectile-action) テーマの設定 GUI で起動している時はアイコン表示しそうでない場合は ▾ とかで表示する\n(setq neo-theme (if (display-graphic-p) \u0026#39;icons \u0026#39;arrow)) のだけど、実際に今使ってるやつだともっとグラフィカルな表示なので all-the-icons の設定で上書きしている気がするので要確認\nmajor-mode-hydra いちいちキーバインドを覚えてられないので major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。\nとはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define neotree-mode (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-octicon \u0026#34;list-unordered\u0026#34;) \u0026#34; Neotree\u0026#34;)) (\u0026#34;Nav\u0026#34; ((\u0026#34;u\u0026#34; neotree-select-up-node \u0026#34;Up\u0026#34;) (\u0026#34;g\u0026#34; neotree-refresh \u0026#34;Refresh\u0026#34;) (\u0026#34;Q\u0026#34; neotree-hide \u0026#34;Hide\u0026#34;)) \u0026#34;File\u0026#34; ((\u0026#34;a\u0026#34; neo-open-file-ace-window \u0026#34;Ace\u0026#34;) (\u0026#34;N\u0026#34; neotree-create-node \u0026#34;Create\u0026#34;) (\u0026#34;R\u0026#34; neotree-rename-node \u0026#34;Rename\u0026#34;) (\u0026#34;C\u0026#34; neotree-copy-node \u0026#34;Copy\u0026#34;) (\u0026#34;D\u0026#34; neotree-delete-node \u0026#34;Delete\u0026#34;) (\u0026#34;SPC\u0026#34; neotree-quick-look \u0026#34;Look\u0026#34;) ;; (\u0026#34;d\u0026#34; neo-open-dired \u0026#34;Dired\u0026#34;) ;; (\u0026#34;O\u0026#34; neo-open-dir-recursive \u0026#34;Recursive\u0026#34;) ) \u0026#34;Toggle\u0026#34; ((\u0026#34;z\u0026#34; neotree-stretch-toggle \u0026#34;Size\u0026#34; :toggle (not (neo-window--minimize-p))) (\u0026#34;h\u0026#34; neotree-hidden-file-toggle \u0026#34;Hidden file\u0026#34; :toggle neo-buffer--show-hidden-file-p))))) キーバインド ナビゲーション    Key 効果     u 上のノードに移動   g 再描画   Q Neotree を隠す    ファイル操作    Key 効果     a ファイルを開く。その際に ace-window で開く window を指定する   N 新しいノードを作る   R ノードの名前を変える   C ノードのコピー   D ノードの削除   SPC クイックルック    Toggle    Key 効果     z Neotree のサイズを大きくしたり小さくしたり   h 隠しファイルを表示したり隠したり    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/posframe/",
	"title": "posframe",
	"tags": [],
	"description": "",
	"content": "概要 posframe は child frame を表示させるためのパッケージ。 Emacs のど真ん中に表示したり、今あるカーソル位置のすぐそばに出したりできる。\nivy なんかを使う時に ivy-posframe ど真ん中に出すと、いつもそこに表示されるし真ん中なの視線移動が少なくて済むし ddskk-posframe なんかで変換候補をカーソル位置のそばに出て来るので一般的な日本語変換ソフトと同様にこれまた視線移動が少なくて便利。\nという感じで色々なものの拡張として使わているやつ。\nインストール いつも通り el-get で入れているだけ。\n(el-get-bundle posframe) こいつ自体には特に設定を入れてない。というか設定項目自体2個しか存在していない。\nま、こいつ単体で使うものでもないしね。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/replacement/",
	"title": "replacement",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/savehist/",
	"title": "savehist",
	"tags": [],
	"description": "",
	"content": "概要 Emacs 標準でついている、ミニバッファの履歴などを保存してくれる機能。\n有効化 標準でついているので以下のようにするだけで有効化可能。\n(savehist-mode 1) 設定 標準で保存されるもの以外だと kill-ring だけを保存対象にしている。これで Emacs を終了させても kill-ring は残るようになるはず。だけど最近使えてない気がするな……。検証が必要そう。\n(setq savehist-additional-variables \u0026#39;(kill-ring)) 他にも有効にしたら便利そうなのがあれば追加したい。が、ぱっとは思い付かない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/",
	"title": "sticky-control",
	"tags": [],
	"description": "",
	"content": "概要 指定したキーを2回叩いたら Control が押されてるような状態にしてくれるプラグイン。\nその2回の間隔はデフォルトだと 0.5 秒以内となっている。そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる\nさらに sticky-control-shortcuts に指定されてる一部のキーについては sticky 用のキーを押した直後に shortcuts のキーを押すと Control を押している状態でそのキーを押したことになる。\n例えば私は , を sticky 用のキーにしていて shortcuts に c を入れているので ,c と素早くタイプをすればそれだけで C-c が押された状態になる。\nインストール まずは el-get-bundle でインストール。\n(el-get-bundle sticky-control) ちなみにレシピは公式ではなかったのでとりあえず自分の環境で使えるように自作レシピを置いている。\n(:name sticky-control :description \u0026#34;save your left little finger\u0026#34; :type http :url \u0026#34;https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el\u0026#34; :features \u0026#34;sticky-control\u0026#34;) 元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど最近そこからは取得できなくなったので https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el から取得して利用している\n設定 まずは「2回叩いたら Control を押している状態になる」キーを指定する。\n(sticky-control-set-key \u0026#39;sticky-control-key ?,) 私は , を sticky-control のキーにしているのでこの指定。\nそして次に sticky-control-shortuts の指定。ここに指定しておくと、例えば ,c と素早くタイプすることで C-c が入力された状態とすることができる。\n(setq sticky-control-shortcuts \u0026#39;((?c . \u0026#34;\\C-c\u0026#34;) (?g . \u0026#34;\\C-g\u0026#34;) (?k . \u0026#34;\\C-k\u0026#34;) (?a . \u0026#34;\\C-a\u0026#34;) (?e . \u0026#34;\\C-e\u0026#34;) (?n . \u0026#34;\\C-n\u0026#34;) (?o . \u0026#34;\\C-o\u0026#34;) (?p . \u0026#34;\\C-p\u0026#34;) (?j . \u0026#34;\\C-j\u0026#34;) (?f . \u0026#34;\\C-f\u0026#34;) (?b . \u0026#34;\\C-b\u0026#34;) (?x . \u0026#34;\\C-x\u0026#34;) (?r . \u0026#34;\\C-r\u0026#34;) (?s . \u0026#34;\\C-s\u0026#34;))) 結構な数を指定しているけど、普段そんなに使えているわけでもない。まあ、大体 Control を押しながら使いそうなところは押さえてあるので何も考えずとも使えるようにしてある。\n有効化 最後に有効化\n(sticky-control-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/toolbar/",
	"title": "toolbar",
	"tags": [],
	"description": "",
	"content": "概要 Emacs 標準の toolbar の設定。麦汁さんは使わないし幅を取るので隠す派。\n設定 単に無効にして隠している\n(tool-bar-mode -1) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/uniquify/",
	"title": "uniquify",
	"tags": [],
	"description": "",
	"content": "概要 同じ名前のファイルを開いている時に祖先のディレクトリ名を表示してくれてどこのファイルかわかりやすくしてくれるやつ。\nすぐ親とかも同名でも、名前が違うところまで遡って表示してくれる。\n有効化 Emacs に標準で入ってるので require するだけで有効にできる\n(require \u0026#39;uniquify) 設定 自分は ファイル名\u0026lt;フォルダ名\u0026gt; みたいな表示になる形式にしている。その方がファイル名が主という感じになって使いやすそうだなって。\nそういう意味では post-foward の方が幅を使わない分良いかもしれない。いつか検討しても良いかもしれない。\n(setq uniquify-buffer-name-style \u0026#39;post-forward-angle-brackets) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/unused/",
	"title": "unused",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/zoom/",
	"title": "zoom",
	"tags": [],
	"description": "",
	"content": "概要 zoom はフォーカスが当たっている Window が大きく表示されるようにするやつ。最近流行りのビデオチャットツールではない。\nどこにフォーカスが当たっているかわかりやすくなるし、狭い画面でも見たい部分を広げて表示できるので便利。\nインストール いつも通り el-get から入れる。 GitHub から直接取得するように設定している。\n(el-get-bundle cyrus-and/zoom) 設定  起動時に有効化 1画面しか使えない時は必須なので 比率を黄金比に変更 この方が使いやすいっぽい。  という設定をしている。\n(custom-set-variables \u0026#39;(zoom-mode t) \u0026#39;(zoom-size \u0026#39;(0.618 . 0.618))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/gcmh/",
	"title": "ガベージコレクション",
	"tags": [],
	"description": "",
	"content": "概要 ガベージコレクションには gcmh というのを利用してみている。\nhttps://github.com/emacsmirror/gcmh\n普段は GC を控えめにしながら操作してない間に GC が走るような作りになっている。便利そう。\nインストール (el-get-bundle gcmh) これだけで有効化もされる。\nその他 以前の設定も折り畳んで残しておく\n  使わなくなったコード  gcmh を入れる前に設定していたコード。 gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。\n;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf ;; Increase threshold to fire garbage collection (setq gc-cons-threshold 1073741824) (setq garbage-collection-messages t) ;; Run GC every 60 seconds if emacs is idle. (run-with-idle-timer 60.0 t #\u0026#39;garbage-collect) \n "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/",
	"title": "麦汁&#39;s Emacs Config",
	"tags": [],
	"description": "",
	"content": "ここは @mugijiru の Emacs の設定ファイルの一部を解説しているページです。\nhttps://github.com/mugijiru/.emacs.d/blob/master/init.org から ox-hugo を使ってWebサイトに仕立て上げています。\n動作確認環境 以下の環境で使用しています。が、動作を保証するものではありません。\n macOS emacsmacport で用意されている Emacs Ubuntu 20.04 LTS apt で手に入る Emacs 26.3  注意点 まだ全ての設定を init.org に記載できていない上に init.org からの出力設定も済ませていないので極一部の設定ファイルのみの解説となります。\n"
}]