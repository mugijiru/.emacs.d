[
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/",
	"title": "with-simulated-input",
	"tags": [],
	"description": "",
	"content": "概要 with-simulated-input は入力処理をシミュレートするためのプラグイン。\n公式のドキュメントにあるように\n(with-simulated-input \u0026#34;hello SPC world RET\u0026#34; (read-string \u0026#34;Say hello to the world: \u0026#34;)) を評価すると read-string に対して「hello world」を入力したことになるので echo エリアに「hello world」と表示される。\nこれで何が嬉しいかというと Emacs Lisp でやっていることはインタラクティブな部分が大きいのでそういった要素をテストできるようになる。\n具体的な使用例は test:my/org-todo で示す。\nインストール レシピは自前で用意している\n(:name with-simulated-input :type github :description \u0026#34;A macro to simulate user input non-interactively.\u0026#34; :pkgname \u0026#34;DarwinAwardWinner/with-simulated-input\u0026#34; :minimum-emacs-version (24 4)) そして el-get-bundle で GitHub からインストールしている\n(el-get-bundle DarwinAwardWinner/with-simulated-input) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/",
	"title": "基本設定",
	"tags": [],
	"description": "",
	"content": "Emacs の基本動作に関わる部分をここでは設定している\nauth-source 認証情報の取り扱いファイルの設定 auto-format ファイル保存時に自動で整形してくれるやつ auto-save 編集中状態の自動保存や編集前の状態のバックアップに関する設定 custom-file カスタマイズ変数などの保存先を変更している ddskk ちょっと変わった日本語入力 SKK の Emacs Lisp 版 exec-path PATH などの環境変数を shell と合わせる設定 font-config フォントの設定 load-path Emacs Lisp が読み込める path の設定 migemo 日本語入力オフのままローマ字で検索できるようにするやつ savehist ミニバッファの履歴などを保存してくれる機能 server 起動した Emacs がサーバとしても動くように設定している ガベージコレクション メモリの開放関係の設定 ライブラリの読み込み Emacs Lisp を書く上で便利なライブラリの読み込み "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/editing-base/",
	"title": "基本設定",
	"tags": [],
	"description": "",
	"content": "概要 なんか編集周りの基本的な設定としてまとめられていたのでここに置いとく\nインデントにタブを使わないようにする 最近の開発スタイルではインデントにタブを混ぜないスタイルなのでそのように設定している。\n(setq indent-tabs-mode nil) 以前に開いていた位置を保存/復元する save-place-mode を有効にしていると以前に開いたことのあるファイルの、開いていた場所を覚えておいてくれる。\n一度閉じてまた開いた時なんかに再度移動しないで済んで地味に便利なやつ\n(save-place-mode 1) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/base/",
	"title": "基本設定",
	"tags": [],
	"description": "",
	"content": "概要 ここでは org-mode 周りのベースとなる設定を書いているつもり。といいつつ、まだ書き方が雑だなと思っている。またその内にでも修正しよう\norg-mode のインストール Emacs に標準で入っている org-mode は古かったりするのでとりあえずデフォルトで入ってるやつは削除しちゃって el-get でインストールしている。\n(el-get-bundle org-mode) とりあえず今は Emacs 29.1 に標準で bundle されているバージョンを入れておいている。バージョンを固定するために el-get についているレシピをコピーして書き換えて使っている。\n(:name org-mode :website \u0026#34;http://orgmode.org/\u0026#34; :description \u0026#34;Org-mode is for keeping notes, maintaining ToDo lists, doing project planning, and authoring with a fast and effective plain-text system.\u0026#34; :type git :url \u0026#34;https://git.savannah.gnu.org/git/emacs/org-mode.git\u0026#34; :checkout \u0026#34;release_9.6.6\u0026#34; :info \u0026#34;doc\u0026#34; :build/berkeley-unix `,(mapcar (lambda (target) (list \u0026#34;gmake\u0026#34; target (concat \u0026#34;EMACS=\u0026#34; (shell-quote-argument el-get-emacs)))) \u0026#39;(\u0026#34;oldorg\u0026#34;)) :build `,(mapcar (lambda (target) (list \u0026#34;make\u0026#34; target (concat \u0026#34;EMACS=\u0026#34; (shell-quote-argument el-get-emacs)))) \u0026#39;(\u0026#34;oldorg\u0026#34;)) :load-path (\u0026#34;.\u0026#34; \u0026#34;lisp\u0026#34;) :load (\u0026#34;lisp/org-loaddefs.el\u0026#34;)) その内もっと新しいのにするけど [2023-10-30 月] に main ブランチのものを入れたら agenda が動かなくなって焦ったのでまた落ち着いた時にトライする\norg 用ディレクトリの指定 org-mode のファイルを保存するデフォルトのディレクトリを指定している。\nデフォルトだと ~/org なのだけどホームディレクトリを汚したくないのと基本的に Mac を使ってるので ~/Documents/org というディレクトリを用意してそこにファイルを置いている。\n(setq org-directory (expand-file-name \u0026#34;~/Documents/org/\u0026#34;)) タスク管理ファイルのフォルダの指定 タスク管理ファイルがいくつかに分かれているがそれらをまとめて ~/Documents/org/tasks フォルダに置いている。\n(setq my/org-tasks-directory (concat org-directory \u0026#34;tasks/\u0026#34;)) とりあえずこの my/org-tasks-directory という変数を用意することであちらこちらでこれを使い回している。\nタスクの状態管理のキーワード指定 org-mode といえば TODO 管理で使ってる人も多いと思う。自分も最初はそういう使い方から始めたし、今でもそれをメインにして使っている。\nそして TODO の状態がデフォルトでは\nTODO DONE の2つしかないけど、それでは足りないので昔見たインターネットのどこかの記事を参考に以下のように設定している。\n(setq org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;EXAMINATION(e)\u0026#34; \u0026#34;READY(r)\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;))) 初期状態は TODO で、作業開始時点で DOING にして待ちが発生したら WAIT にして完了したら DONE にしている。\nSOMEDAY は「いつかやる」に付与しているけど最近ほとんど使ってない。\norg-todo-keywords は複数の sequence を指定したり type を指定したりもできるがそこまでの活用ができていないので、どこかで見直したいですね。\n完了時間の記録 org-clock を使うようにしているしあんまり要らない気がする。もしかしたら habits で必要かもしれないけど。\n(setq org-log-done \u0026#39;time) (setq org-log-into-drawer \u0026#34;LOGBOOK\u0026#34;) org ファイルを開いた時の折り畳み デフォルト設定では全展開だけど、基本的に見出しだけ見れれば良いかなと思うのでそのように設定した。\n(custom-set-variables \u0026#39;(org-startup-folded t)) journal ファイルはもう少し展開してても良い気がするので journal のテンプレートか何かを弄っておくのも良さそう\nタグ設定時の補完候補設定 agenda ファイルに使われているタグは全部補完対象になってほしいのでそのように設定している\n(custom-set-variables \u0026#39;(org-complete-tags-always-offer-all-agenda-tags t)) org-mode 読み込み後の追加実行コード まず org-protocol を使って Firefox と連携したいのでこれを読み込むようにしている。また org-mode のリンク先の拡張子が xlsx の時に OS 側で指定した標準アプリを開くようにしている。\n(with-eval-after-load \u0026#39;org (require \u0026#39;org-protocol) (add-to-list \u0026#39;org-modules \u0026#39;org-protocol) (add-to-list \u0026#39;org-file-apps \u0026#39;(\u0026#34;\\\\.xlsx?\\\\\u0026#39;\u0026#34; . default))) 第二引数に default を指定すると、内部的には Mac なら open コマンドが使われることを利用している。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/execution/",
	"title": "実行方法",
	"tags": [],
	"description": "",
	"content": "テストする時は以下のように叩いたら動く。\nemacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el 今まで .emacs.d にいる状態でしか叩いたことないので他の場所にいる時に実行しても大丈夫かはわからない。\n単体でテストしたい時は\n-l ~/.emacs.d/inits/test/*-test.el の部分を書き換えたらいいんじゃないかな。やったことないけど。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/",
	"title": "mocker.el",
	"tags": ["unused"],
	"description": "",
	"content": "概要 mocker.el は Emacs Lisp のテストで使う Mock ライブラリ。\n使おうと思って導入したけど、自分のやりたいことはちょっと違ったので死蔵中\n便利そうなのでとりあえず置いといている。\nインストール レシピを自前で用意して\n(:name mocker.el :type github :description \u0026#34;Mocker.el is a mocking framework for Emacs lisp.\u0026#34; :pkgname \u0026#34;sigma/mocker.el\u0026#34; :minimum-emacs-version (25 1)) el-get で GitHub から取得している。\n(el-get-bundle mocker.el) 副作用を伴う関数の扱い 基本的に入出力を置き換えるためのものなので副作用が処理の主体になるような関数には向いてなさそう。\nただ https://github.com/sigma/mocker.el#examples を見ていると output-generator で副作用と同じ処理を書いてやるなどの逃げ道はありそう\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-babel/",
	"title": "org-babel",
	"tags": [],
	"description": "",
	"content": "概要 ここでは org-babel の設定をまとめている。\norg-babel で評価可能な言語の指定 なんか普段から使いそうな奴をとりあえず選定しているつもり。\n(org-babel-do-load-languages \u0026#39;org-babel-load-languages \u0026#39;((plantuml . t) (sql . t) (gnuplot . t) (emacs-lisp . t) (shell . t) (js . t) (org . t) (ruby . t))) js, ruby 仕事でメインで使ってる言語なので入れている。 shell 入れてる方が便利そう、ぐらいの雑な理由。 sql メモしておいて手元から実行できると便利そう plantuml 図の出力。一番使ってる。 gnuplot 趣味で入れてみているけど実際使う機会ほとんどないよなって気がしてきている。 org-babel-execute 後に画像を再表示 PlantUML の処理をすることが多いので以下の hook を設定することで実行後に画像を再表示するようにしている\n(add-hook \u0026#39;org-babel-after-execute-hook \u0026#39;org-redisplay-inline-images) org-babel の非同期実行 improvement 非同期に org-babel の source を実行するために ob-async を入れている\nレシピは自前で用意している\n(:name ob-async :description \u0026#34;Asynchronous org-babel src block execution\u0026#34; :type github :pkgname \u0026#34;astahlman/ob-async\u0026#34; :depends (emacs-async org-mode dash) :minimum-emacs-version (24 4)) そして el-get-bundle でインストール。\n(el-get-bundle ob-async) (require \u0026#39;ob-async) で、ob-async を何のために入れているかというと PlantUML の図の出力である。画像まで作成するからね、時間かかりそうだしね。\nそんで、その時に org-plantuml-jar-path を強制的に指定している。\n(add-hook \u0026#39;ob-async-pre-execute-src-block-hook \u0026#39;(lambda () (setq org-plantuml-jar-path \u0026#34;~/bin/plantuml.jar\u0026#34;))) 多分 custom-set-variables でちゃんと設定したらいいんだろうなあ。\nカスタム変数の設定 org-id-link-to-org-use-id を t にしていると org-store-link を実行した時に自動で id を発行してそれを store してくれるようになる\nまた archive ファイルを同じフォルダに archives フォルダを掘ってそこに格納したいので org-archive-location を設定している\n(custom-set-variables \u0026#39;(org-id-link-to-org-use-id t) \u0026#39;(org-archive-location \u0026#34;./archives/%s_archive::\u0026#34;)) habit 完了時に Appt を refresh Appt + alert.el + Dunst で通知を行っているが、完了後も通知対象として残っていると困るので完了時に refresh するように調整している\n(defun my/org-refresh-appt-on-complete-habit (args) \u0026#34;習慣タスクを完了した時に Appt を refresh する\u0026#34; (let* ((element (org-element-at-point)) (style (org-element-property :STYLE element)) (to (plist-get args :to))) (if (and (string= style \u0026#34;habit\u0026#34;) (string= \u0026#34;TODO\u0026#34; to)) (my/org-refresh-appt)))) (add-hook \u0026#39;org-trigger-hook \u0026#39;my/org-refresh-appt-on-complete-habit) org-mode-map の override windmove-mode とキーバインドがかぶってるのでそれと同居できるように override している。\n具体的には org-mode のコマンドが動く場所であればそれを実行しそれがないなら windmove のコマンドを実行する\nまた org-read-date はデフォルトでシフト+カーソルキーで日付を選択できるが、 windmove にそれを奪われてしまうので、カーソルキー単体でカレンダー選択ができるようにしている。\n(defun my/org-mode-map-override-windmove-mode-map () (let ((oldmap windmove-mode-map) (newmap (make-sparse-keymap))) (make-local-variable \u0026#39;minor-mode-overriding-map-alist) (add-to-list \u0026#39;minor-mode-overriding-map-alist `(windmove-mode . ,newmap)) (add-hook \u0026#39;org-shiftup-final-hook \u0026#39;windmove-up) (add-hook \u0026#39;org-shiftleft-final-hook \u0026#39;windmove-left) (add-hook \u0026#39;org-shiftdown-final-hook \u0026#39;windmove-down) (add-hook \u0026#39;org-shiftright-final-hook \u0026#39;windmove-right))) (defun my/org-mode-hook () (my/org-mode-map-override-windmove-mode-map) (define-key org-mode-map [remap org-set-tags-command] #\u0026#39;counsel-org-tag) ;; http://yitang.uk/2022/07/05/move-between-window-using-builtin-package/ (define-key org-read-date-minibuffer-local-map (kbd \u0026#34;\u0026lt;left\u0026gt;\u0026#34;) (lambda () (interactive) (org-eval-in-calendar \u0026#39;(calendar-backward-day 1)))) (define-key org-read-date-minibuffer-local-map (kbd \u0026#34;\u0026lt;right\u0026gt;\u0026#34;) (lambda () (interactive) (org-eval-in-calendar \u0026#39;(calendar-forward-day 1)))) (define-key org-read-date-minibuffer-local-map (kbd \u0026#34;\u0026lt;up\u0026gt;\u0026#34;) (lambda () (interactive) (org-eval-in-calendar \u0026#39;(calendar-backward-week 1)))) (define-key org-read-date-minibuffer-local-map (kbd \u0026#34;\u0026lt;down\u0026gt;\u0026#34;) (lambda () (interactive) (org-eval-in-calendar \u0026#39;(calendar-forward-week 1))))) (add-hook \u0026#39;org-mode-hook \u0026#39;my/org-mode-hook) (with-eval-after-load \u0026#39;org-mode (my/org-mode-map-override-windmove-mode-map)) org-src の設定 関数内とかで分割して init.org に書いた時にデフォルト設定だとインデントが消失してしまって不便なのでコードブロック内のインデントがそのまま反映されるように org-src-preserve-indentation を有効にして、さらにコードブロック内で自動で2文字下げられるとまあ面倒なので org-edit-src-content-indentation を 0 に設定している\n(custom-set-variables \u0026#39;(org-src-preserve-indentation t) \u0026#39;(org-edit-src-content-indentation 0)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/run-tests/",
	"title": "run-tests",
	"tags": [],
	"description": "",
	"content": "読み込んだテストをまるっとテストするためのコードをとりあえず置いている。\n(if noninteractive (let ((ert-quiet t)) (ert-run-tests-batch-and-exit))) 後述の テストライブラリの読み込み などはここで担うべきかとも考えるが今はテストファイルが1つしかないので気にしないことにする。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/buffer-management/",
	"title": "バッファ管理",
	"tags": [],
	"description": "",
	"content": "ここではバッファ管理関係の設定を記載している\nscratch-log scratch バッファを自動的に永続化してくれるパッケージ tempbuf 不要になったと思われるバッファを自動的に kill してくれるパッケージ "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/",
	"title": "my-org-commands-test",
	"tags": [],
	"description": "",
	"content": "org-mode 用に定義したコマンドや関数のテストコード\nSetup テストライブラリの読み込み 標準でついてくる ert を採用しているのでそれを読み込んでいる。\n(require \u0026#39;ert) el-get の設定の読み込み プラグイン管理には el-get を利用しているのでその設定ファイルを読み込んでいる。\n;; プラグイン読み込みの前準備 (load (expand-file-name (concat user-emacs-directory \u0026#34;/init-el-get.el\u0026#34;))) テスト補助のプラグイン読み込み with-simulated-input 上で説明しているが、入力をシミュレートするためのプラグインをテストで利用しているのでここで読み込んでいる。\n;; 入力シミュレート用のプラグイン (load (expand-file-name (concat user-emacs-directory \u0026#34;/inits/99-with-simulated-input\u0026#34;))) 依存プラグインの読み込み テスト対象が依存しているプラグインを読み込んでいる。本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが現状だとその状態で GitHub Actions で動かせる方法がわからないので一旦個別に読み込むようにしている。\nswiper ivy-read を使った機能のテストをするので読み込んでいる。\n(el-get-bundle abo-abo/swiper) テスト対象の読み込み テストしたいファイルをここで読んでる。\n;; テスト対象の読み込み (load (expand-file-name (concat user-emacs-directory \u0026#34;/inits/68-my-org-commands.el\u0026#34;))) ert-deftest test:my/org-todo-keyword-strings org-todo-keywords から \u0026ldquo;|\u0026rdquo; という区切りを除外したり \u0026ldquo;(s)\u0026rdquo; とかのような高速アクセスのためのキーワードは ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。\n(ert-deftest test:my/org-todo-keyword-strings () \u0026#34;Test of `my/org-todo-keyword-strings\u0026#39;.\u0026#34; (let ((org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;)))) (should (equal \u0026#39;(\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;DONE\u0026#34; \u0026#34;SOMEDAY\u0026#34;) (my/org-todo-keyword-strings))))) なお、ここでテストしている関数では TODO キーワードを ivy で扱いやすいように整えているだけで実際の選択は別の関数が担っている\ntest:my/org-todo org-todo を ivy で選択する関数のテストを書いている。\n(ert-deftest test:my/org-todo () \u0026#34;Test of `my/org-todo\u0026#39;.\u0026#34; (let ((org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;))) (result)) ;; org-mode を読まずに済むように org-todo を差し替えてテストしている (cl-letf (((symbol-function \u0026#39;org-todo) (lambda (keyword) (setq result keyword)))) (with-simulated-input \u0026#34;DOI RET\u0026#34; (my/org-todo)) (should (equal \u0026#34;DOING\u0026#34; result))))) ポイントは cl-letf を使って、内部で叩いている関数 org-todo を一時的に\n(lambda (keyword) (setq result keyword)) に差し替えているところ。\norg-mode を呼び出さずに代わりの関数に差し替えているのでテストがしやすくなっている。Stub 的なやつかな。\n何度も使うならこの差し替え処理自体をテストヘルパーにしても良いかもしれない。\nまた ivy で選択するので with-simulated-input を使って入力操作を代替している。便利。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/",
	"title": "キーバインド",
	"tags": [],
	"description": "",
	"content": "ここでは全体に関わるキーバインド系の設定を記載している。\nGoogle 連携 Google 連携する機能のキーバインドをまとめている key-chord 同時押しというキーバインドを提供してくれるやつ sticky-control Control の入力を sticky にしてくれるやつ グローバルキーバインド いつでもどこでも使えるキーバインド周りの設定をここにまとめている "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/calendar/",
	"title": "予定のカレンダー表示",
	"tags": [],
	"description": "",
	"content": "概要 普段の予定をカレンダー表示で見れると嬉しいな〜と思って calfw で予定が見れるようにしている。\nが、今ここに書いているのはまだ設定の一部である。 agenda 部分と関わっていてまだうまく整理しきれてない。\n日本の休日 calfw に日本の休日を表示できるように japanese-holidays を入れている。\n(el-get-bundle japanese-holidays) (require \u0026#39;japanese-holidays) (setq calendar-holidays (append japanese-holidays)) もっとちゃんと設定したら Emacs のデフォルトのカレンダーでも休日表示がわかりやすくなって良いので今度設定し直す。\nその時には多分 org-mode カテゴリではないところに移動するはず。\ncalfw calfw を el-get で入れた上で、 org-mode と連携するように calfw-org も require している。\n(el-get-bundle calfw) (require \u0026#39;calfw) (require \u0026#39;calfw-org) ここではまだこれ以上のことはしてない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/agenda/",
	"title": "Agenda 関係の設定",
	"tags": [],
	"description": "",
	"content": "概要 org-mode の素晴らしい機能の1つに Agenda というものがある。\nこれは色々な org ファイルに散らばった情報を1つのビューに表示するための機能で、使いこなすとファイルがバラけていてもいい感じに情報が抽出できて便利なやつ。\nまあ麦汁さんはまだ使いこなせてないけど。\nそれでもいくつか Agenda 用の View を用意したりして日常業務に役立てている。\norg-super-agenda のインストール org-mode のデフォルトの agenda だと表示周りが物足りなかったので org-super-agenda を導入している。\n(el-get-bundle org-super-agenda) 週の始まりを日曜日に設定 麦汁さんは週のスタートを日曜日とする派なので org-agenda の週の始まりも日曜日に設定している\n(custom-set-variables \u0026#39;(org-agenda-start-on-weekday 0)) 1日単位をデフォルト表示に設定 1週間表示よりも「今日って何するんだっけ」みたいな使い方が多いので 1日を表示単位としている。\n(custom-set-variables \u0026#39;(org-agenda-span \u0026#39;day)) 週単位で何をするかについては今のところ記憶力で対応している。\nあと、基本的にカスタムビューを使ってるのでこれの影響は受けてるかどうか微妙。\nagenda の対象ファイルを指定 org-agenda を使う時に抽出対象とする org ファイルを指定している。\n(custom-set-variables \u0026#39;(org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/gcals/mugijiru.org\u0026#34; \u0026#34;~/Documents/org/tasks/\u0026#34;))) agenda の表示周りの設定 agenda に時間の区切りを入れない org-agenda-use-time-grid を t にしていると 10:00 とかのキリがいいところに区切り線を表示してくれるのだが日報提出時には邪魔だし、普段使いでもその区切り線はあっても邪魔っぽいので nil にして表示しないようにしている。\n(custom-set-variables \u0026#39;(org-agenda-use-time-grid nil)) ブロック間の区切り表示 ブロックとブロックの区切りをハイフン繋ぎの文字列で指定している。\n文字列を指定することで固定の長さの区切り文字になるが実は ?- とか指定して長さが無限に伸びるようにしてもいいかもしれない。と思いつつ、多分 zoom-mode とかでバッファの幅が切り替わる時に邪魔になるから固定でいいか。\n(custom-set-variables \u0026#39;(org-agenda-block-separator \u0026#34;------------------------------\u0026#34;)) org-super-agnda-mode の有効化 なんでここで有効化しているのかね。インストールのやつと近付けた方がいい気がする。\nとりあえず有効化して使えるようにしている。\n(org-super-agenda-mode 1) agenda で使う変数の初期化 my/org-agenda-calendar-files という変数でカレンダーの情報を取り込んで agenda を表示できるようにしている。けど今はカレンダー連携をしていないので空で初期化している。\n(setq my/org-agenda-calendar-files \u0026#39;()) カスタムビュー 色々なカスタムビューを定義している。かといって全部使ってるわけではないし、つまり使いこなせているかというと微妙。\nキー 内容 備考 hs 稼動日の始業直後に実施する習慣タスクの表示 よく使っている。その日やるタスクを決めたりしている hf 稼動日の退勤直前に実施する習慣タスクの表示 よく使っている。その日の日報を書くなどしている hw 週間隔または隔週で実施する習慣タスクの表示 週1で使う感じ。この中に放置しているタスクもある hh 休日の習慣タスク 最近使ってない。。。真面目にタスクを作り過ぎてだるくなってるやつ d 今日の予定などを表示 普段は会議部分しか見てないので改善が必要そう D 休日タスクの表示 使ってない。。。 pp GTD の Projects の表示 たまに使う程度。もうちょっと洗練させたい pP GTD の Projects の内、環境整備系以外 環境整備はやっても業務に直接寄与しないので忙しい時は見たくないでござる P GTD の Pointers の表示 たまーに使う。資料が貯まり過ぎて取り扱いに困っている X 終了したタスクを表示 まとめてお掃除する時に使っている z 日報用表示 毎日業務日報の提出が要求されているのでそれっぽく表示されるようにしている H GTD の Projects の中の家事を抽出 最近は使ってない EO org-mode 関連の環境整備タスク 最近見てない EE Emacs 関係かつ org-mode 以外の環境整備タスク 貯まる一方 Ee Emacs 以外の環境整備タスク これも貯まる。Emacs 設定ほどじゃないけど (custom-set-variables \u0026#39;(org-agenda-custom-commands \u0026#39;((\u0026#34;h\u0026#34; . \u0026#34;Habits\u0026#34;) (\u0026#34;hs\u0026#34; \u0026#34;Weekday Start\u0026#34; ((tags \u0026#34;Weekday\u0026amp;Start|Daily\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-super-agenda-groups \u0026#39;((:name \u0026#34;予定が過ぎてる作業\u0026#34; :scheduled past) (:name \u0026#34;今日の作業\u0026#34; :scheduled today) (:discard (:anything t)))))))) (\u0026#34;hf\u0026#34; \u0026#34;Weekday Finish\u0026#34; ((tags \u0026#34;Weekday\u0026amp;Finish\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-super-agenda-groups \u0026#39;((:name \u0026#34;予定が過ぎてる作業\u0026#34; :scheduled past) (:name \u0026#34;今日の作業\u0026#34; :scheduled today) (:discard (:anything t)))))))) (\u0026#34;hw\u0026#34; \u0026#34;Weekly\u0026#34; ((tags \u0026#34;Weekly\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-super-agenda-groups \u0026#39;((:name \u0026#34;予定が過ぎてる作業\u0026#34; :scheduled past) (:name \u0026#34;今週の作業\u0026#34; :scheduled today) (:discard (:anything t)))))))) (\u0026#34;hh\u0026#34; \u0026#34;Holiday\u0026#34; ((tags \u0026#34;Weekend|Holiday|Daily\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-super-agenda-groups \u0026#39;((:name \u0026#34;予定が過ぎてる作業\u0026#34; :scheduled past) (:name \u0026#34;今日の作業\u0026#34; :scheduled today) (:discard (:anything t)))))))) (\u0026#34;d\u0026#34; \u0026#34;Today\u0026#34; ((agenda \u0026#34;会議など\u0026#34; ((org-agenda-span \u0026#39;day) (org-agenda-files my/org-agenda-calendar-files))) (tags-todo \u0026#34;-Weekday-Daily-Holiday-Weekly-Weekend\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;今日の作業\u0026#34;) (org-habit-show-habits nil) (org-agenda-span \u0026#39;day) (org-agenda-prefix-format \u0026#34;%l%c: \u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/habits.org\u0026#34; \u0026#34;~/Documents/org/journal/\u0026#34; \u0026#34;~/Documents/org/tasks/reviews.org\u0026#34;)) (org-super-agenda-groups \u0026#39;((:name \u0026#34;仕掛かり中\u0026#34; :todo \u0026#34;DOING\u0026#34; :property (\u0026#34;agenda-group\u0026#34; \u0026#34;journal-task\u0026#34;)) (:name \u0026#34;TODO\u0026#34; :and (:todo \u0026#34;TODO\u0026#34; :property (\u0026#34;agenda-group\u0026#34; \u0026#34;journal-task\u0026#34;))) (:name \u0026#34;レビュー中\u0026#34; :todo \u0026#34;DOING\u0026#34; :category \u0026#34;レビュー\u0026#34;) (:name \u0026#34;レビュー待ち\u0026#34; :todo \u0026#34;WAIT\u0026#34; :property (\u0026#34;agenda-group\u0026#34; \u0026#34;journal-task\u0026#34;)) (:name \u0026#34;修正待ち\u0026#34; :todo \u0026#34;WAIT\u0026#34; :category \u0026#34;レビュー\u0026#34;) (:discard (:anything t)))))) (alltodo \u0026#34;\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;予定業務\u0026#34;) (org-habit-show-habits nil) (org-agenda-span \u0026#39;day) (org-agenda-prefix-format \u0026#34; %c: \u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)) (org-super-agenda-groups `((:name \u0026#34;〆切が過ぎてる作業\u0026#34; :and (:deadline past :property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;))) (:name \u0026#34;予定が過ぎてる作業\u0026#34; :and (:scheduled past :property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;))) (:name \u0026#34;今日〆切の作業\u0026#34; :and (:deadline today :property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;))) (:name \u0026#34;今日予定の作業\u0026#34; :and (:scheduled today :property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;))) (:name \u0026#34;今後1週間の作業\u0026#34; :and (:and (:scheduled (before ,(format-time-string \u0026#34;%Y-%m-%d\u0026#34; (time-add (current-time) (days-to-time 7)))) :scheduled (after ,(format-time-string \u0026#34;%Y-%m-%d\u0026#34; (current-time)))) :property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;))) (:discard (:anything t)))))) (tags-todo \u0026#34;Weekday-Finish|Daily\u0026#34; ((org-agenda-overriding-header \u0026#34;習慣\u0026#34;) (org-agenda-prefix-format \u0026#34; \u0026#34;) (org-habit-show-habits t) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/habits.org\u0026#34;)) (org-super-agenda-groups \u0026#39;((:name \u0026#34;予定が過ぎてる作業\u0026#34; :scheduled past) (:name \u0026#34;今日予定\u0026#34; :scheduled today) (:discard (:anything t)))))) (tags-todo \u0026#34;LEVEL=2\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)) (org-agenda-overriding-header \u0026#34;予定なし\u0026#34;) (org-super-agenda-groups \u0026#39;((:and (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;) :scheduled nil :deadline nil)) (:discard (:anything t)))))))) (\u0026#34;D\u0026#34; \u0026#34;Holiday\u0026#34; ((tags-todo \u0026#34;-Weekday-Daily-Holiday-Weekly-Weekend\u0026amp;LEVEL=3\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;休日の作業\u0026#34;) (org-habit-show-habits nil) (org-agenda-prefix-format \u0026#34; %c: \u0026#34;) (org-agenda-span \u0026#39;day) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/journal/\u0026#34;)) (org-super-agenda-groups \u0026#39;((:name \u0026#34;仕掛かり中\u0026#34; :and (:todo \u0026#34;DOING\u0026#34; :not (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;)))) (:name \u0026#34;TODO\u0026#34; :and (:todo \u0026#34;TODO\u0026#34; :not (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;)))) (:name \u0026#34;待ち\u0026#34; :and (:todo \u0026#34;WAIT\u0026#34; :not (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;)))) (:discard (:anything t)))))) (alltodo \u0026#34;\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;予定作業\u0026#34;) (org-habit-show-habits nil) (org-agenda-prefix-format \u0026#34; %c: \u0026#34;) (org-agenda-span \u0026#39;day) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34; \u0026#34;~/Documents/org/tasks/inbox.org\u0026#34;)) (org-super-agenda-groups `((:name \u0026#34;〆切が過ぎてる作業\u0026#34; :and (:deadline past :not (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;)))) (:name \u0026#34;予定が過ぎてる作業\u0026#34; :and (:scheduled past :not (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;)))) (:name \u0026#34;今日〆切の作業\u0026#34; :and (:deadline today :not (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;)))) (:name \u0026#34;今日予定の作業\u0026#34; :and (:scheduled today :not (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;)))) (:name \u0026#34;今後1週間の作業\u0026#34; :and (:and (:scheduled (before ,(format-time-string \u0026#34;%Y-%m-%d\u0026#34; (time-add (current-time) (days-to-time 7)))) :scheduled (after ,(format-time-string \u0026#34;%Y-%m-%d\u0026#34; (current-time)))) :not (:property (\u0026#34;agenda-group\u0026#34; \u0026#34;1. Work\u0026#34;)))) (:discard (:anything t)))))) (tags-todo \u0026#34;Holiday|Weekend|Daily\u0026#34; ((org-agenda-overriding-header \u0026#34;習慣\u0026#34;) (org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/habits.org\u0026#34;)) (org-super-agenda-groups \u0026#39;((:name \u0026#34;予定が過ぎてる作業\u0026#34; :scheduled past) (:name \u0026#34;今日予定の作業\u0026#34; :scheduled today) (:discard (:anything t)))))) (tags-todo \u0026#34;LEVEL=2\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)) (org-agenda-overriding-header \u0026#34;Private\u0026#34;) (org-super-agenda-groups \u0026#39;((:name \u0026#34;Priority \u0026gt;= B\u0026#34; :and (:priority\u0026gt;= \u0026#34;B\u0026#34; :property (\u0026#34;agenda-group\u0026#34; \u0026#34;7. Private\u0026#34;))) (:name \u0026#34;no priority\u0026#34; :and (:not (:priority\u0026gt;= \u0026#34;C\u0026#34;) :property (\u0026#34;agenda-group\u0026#34; \u0026#34;7. Private\u0026#34;))) (:discard (:anything t)))))) (tags-todo \u0026#34;Emacs\u0026amp;LEVEL=2\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)) (org-agenda-overriding-header \u0026#34;Emacs\u0026#34;) (org-super-agenda-groups \u0026#39;((:priority\u0026gt;= \u0026#34;B\u0026#34;) (:name \u0026#34;no priority\u0026#34; :not (:priority\u0026gt;= \u0026#34;C\u0026#34;)) (:discard (:anything t)))))) (tags-todo \u0026#34;Env\u0026amp;LEVEL=2\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)) (org-agenda-overriding-header \u0026#34;Env\u0026#34;) (org-super-agenda-groups \u0026#39;((:priority\u0026gt;= \u0026#34;B\u0026#34;) (:name \u0026#34;no priority\u0026#34; :not (:priority\u0026gt;= \u0026#34;C\u0026#34;)) (:discard (:anything t)))))))) (\u0026#34;p\u0026#34; . \u0026#34;Projects\u0026#34;) (\u0026#34;pA\u0026#34; \u0026#34;Projects Priority A\u0026#34; ((tags-todo \u0026#34;LEVEL=2\u0026amp;PRIORITY=\\\u0026#34;A\\\u0026#34;\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)))))) (\u0026#34;pc\u0026#34; \u0026#34;Category\u0026#34; ((tags-todo \u0026#34;LEVEL=2\u0026amp;CATEGORY=\\\u0026#34;Work\\\u0026#34;\u0026#34; ((org-agenda-overriding-header \u0026#34;お仕事タスク\u0026#34;) (org-agenda-overriding-columns-format \u0026#34;%25ITEM %TODO\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))))) (tags-todo \u0026#34;LEVEL=2\u0026amp;CATEGORY=\\\u0026#34;Housework\\\u0026#34;\u0026#34; ((org-agenda-overriding-header \u0026#34;家事\u0026#34;) (org-agenda-overriding-columns-format \u0026#34;%25ITEM %TODO\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))))) (tags-todo \u0026#34;LEVEL=2\u0026amp;CATEGORY=\\\u0026#34;Config\\\u0026#34;\u0026#34; ((org-agenda-overriding-header \u0026#34;設定弄り\u0026#34;) (org-agenda-overriding-columns-format \u0026#34;%25ITEM %TODO\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))))) (tags-todo \u0026#34;LEVEL=2\u0026amp;CATEGORY=\\\u0026#34;Research\\\u0026#34;\u0026#34; ((org-agenda-overriding-header \u0026#34;調査\u0026#34;) (org-agenda-overriding-columns-format \u0026#34;%25ITEM %TODO\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))))) (tags-todo \u0026#34;LEVEL=2\u0026amp;CATEGORY=\\\u0026#34;Indie hack\\\u0026#34;\u0026#34; ((org-agenda-overriding-header \u0026#34;個人開発\u0026#34;) (org-agenda-overriding-columns-format \u0026#34;%25ITEM %TODO\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))))) (tags-todo \u0026#34;LEVEL=2\u0026amp;CATEGORY=\\\u0026#34;Hoby\\\u0026#34;\u0026#34; ((org-agenda-overriding-header \u0026#34;趣味関係\u0026#34;) (org-agenda-overriding-columns-format \u0026#34;%25ITEM %TODO\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))))) (tags-todo \u0026#34;LEVEL=2\u0026amp;CATEGORY=\\\u0026#34;Private\\\u0026#34;\u0026#34; ((org-agenda-overriding-header \u0026#34;Private タスク\u0026#34;) (org-agenda-overriding-columns-format \u0026#34;%25ITEM %TODO\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))))))) (\u0026#34;pC\u0026#34; \u0026#34;Category auto\u0026#34; ((tags-todo \u0026#34;LEVEL=2\u0026#34; ((org-agenda-overriding-header \u0026#34;Categories\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))) (org-super-agenda-groups \u0026#39;((:auto-category t))))))) (\u0026#34;pg\u0026#34; \u0026#34;Agenda groups\u0026#34; ((tags-todo \u0026#34;LEVEL=2\u0026#34; ((org-agenda-overriding-header \u0026#34;Categories\u0026#34;) (org-agenda-files `(,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;))) (org-super-agenda-groups \u0026#39;((:auto-group t))))))) (\u0026#34;pp\u0026#34; \u0026#34;Projects\u0026#34; ((tags-todo \u0026#34;LEVEL=2\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;今日のタスク\u0026#34;) (org-habit-show-habits nil) (org-agenda-span \u0026#39;day) (org-agenda-todo-keyword-format \u0026#34;-\u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/habits.org\u0026#34; \u0026#34;~/Documents/org/journal/\u0026#34;)) (org-super-agenda-groups (append (mapcar (lambda (key) `(:name ,key :and (:category ,key :todo (\u0026#34;DOING\u0026#34; \u0026#34;WAIT\u0026#34;)))) (if (boundp \u0026#39;my/nippou-categories) my/nippou-categories nil)) \u0026#39;((:name \u0026#34;その他\u0026#34; :scheduled nil) (:discard (:anything t))))))) (tags-todo \u0026#34;LEVEL=2\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;予定に入ってる作業\u0026#34;) (org-habit-show-habits nil) (org-agenda-span \u0026#39;day) (org-agenda-todo-keyword-format \u0026#34;-\u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)) (org-super-agenda-groups \u0026#39;((:name \u0026#34;〆切が過ぎてる作業\u0026#34; :deadline past) (:name \u0026#34;予定が過ぎてる作業\u0026#34; :scheduled past) (:name \u0026#34;今日〆切の作業\u0026#34; :deadline today) (:name \u0026#34;今日予定の作業\u0026#34; :scheduled today) (:discard (:anything t)))))) (tags-todo \u0026#34;LEVEL=2\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)) (org-super-agenda-groups \u0026#39;((:name \u0026#34;待ち\u0026#34; :todo \u0026#34;WAIT\u0026#34;) (:name \u0026#34;仕掛かり中\u0026#34; :todo \u0026#34;DOING\u0026#34;) (:name \u0026#34;TODO\u0026#34; :todo \u0026#34;TODO\u0026#34;) (:discard (:anything t)))))))) (\u0026#34;pP\u0026#34; \u0026#34;Projects without Env\u0026#34; ((alltodo \u0026#34;\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;今日のタスク\u0026#34;) (org-habit-show-habits nil) (org-agenda-span \u0026#39;day) (org-agenda-todo-keyword-format \u0026#34;-\u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/habits.org\u0026#34; \u0026#34;~/Documents/org/journal/\u0026#34;)) (org-super-agenda-groups (append (mapcar (lambda (key) `(:name ,key :and (:category ,key :todo (\u0026#34;DOING\u0026#34; \u0026#34;WAIT\u0026#34;)))) (if (boundp \u0026#39;my/nippou-categories) my/nippou-categories nil)) \u0026#39;((:name \u0026#34;その他\u0026#34; :scheduled nil) (:discard (:anything t))))))) (alltodo \u0026#34;\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;予定に入ってる作業\u0026#34;) (org-habit-show-habits nil) (org-agenda-span \u0026#39;day) (org-agenda-todo-keyword-format \u0026#34;-\u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)) (org-super-agenda-groups \u0026#39;((:name \u0026#34;〆切が過ぎてる作業\u0026#34; :deadline past) (:name \u0026#34;予定が過ぎてる作業\u0026#34; :scheduled past) (:name \u0026#34;今日〆切の作業\u0026#34; :deadline today) (:name \u0026#34;今日予定の作業\u0026#34; :scheduled today) (:discard (:anything t)))))) (tags-todo \u0026#34;-Emacs-org-Env-Hugo\u0026amp;LEVEL=2\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)))))) (\u0026#34;pN\u0026#34; \u0026#34;No major tags\u0026#34; ((tags-todo \u0026#34;-Emacs-org-Env-Hugo-Kibela-Develop-ReviewLister-HouseWork-Private\u0026amp;LEVEL=2\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34;)))))) (\u0026#34;P\u0026#34; \u0026#34;Pointers\u0026#34; ((todo \u0026#34;DOING\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/pointers.org\u0026#34;)))) (todo \u0026#34;TODO\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/pointers.org\u0026#34;)))))) (\u0026#34;X\u0026#34; \u0026#34;Finished\u0026#34; ((tags \u0026#34;LEVEL=2\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34; \u0026#34;~/Documents/org/tasks/inbox.org\u0026#34; \u0026#34;~/Documents/org/tasks/reviews.org\u0026#34; \u0026#34;~/Documents/org/journal/\u0026#34; \u0026#34;~/Documents/org/tasks/habits.org\u0026#34;)) (org-super-agenda-groups \u0026#39;((:name \u0026#34;Finished\u0026#34; :todo \u0026#34;DONE\u0026#34;) (:name \u0026#34;Someday\u0026#34; :todo \u0026#34;SOMEDAY\u0026#34;) (:discard (:anything t)))))))) (\u0026#34;z\u0026#34; \u0026#34;日報\u0026#34; ((agenda \u0026#34;\u0026#34; ((org-agenda-span \u0026#39;day) (org-agenda-overriding-header \u0026#34;\u0026#34;) (org-habit-show-habits nil) (org-agenda-format-date \u0026#34;## %Y/%m/%d (%a) 日報\u0026#34;) (org-agenda-prefix-format \u0026#34; %?-12t\u0026#34;) (org-agenda-files my/org-agenda-calendar-files) (org-super-agenda-groups \u0026#39;((:name \u0026#34;会議など\u0026#34; :time-grid t) (:discard (:anything t)))))) (todo \u0026#34;DONE\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;対応済\u0026#34;) (org-habit-show-habits nil) (org-agenda-span \u0026#39;day) (org-agenda-todo-keyword-format \u0026#34;-\u0026#34;) (org-columns-default-format-for-agenda \u0026#34;%25ITEM %TODO %3PRIORITY\u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/habits.org\u0026#34; \u0026#34;~/Documents/org/journal/\u0026#34;)) (org-super-agenda-groups (append (mapcar (lambda (key) `(:name ,key :and (:category ,key :todo (\u0026#34;DONE\u0026#34;)))) (if (boundp \u0026#39;my/nippou-categories) my/nippou-categories nil)) \u0026#39;((:discard (:anything t :name \u0026#34;discard\u0026#34;))))))) (alltodo \u0026#34;\u0026#34; ((org-agenda-prefix-format \u0026#34; \u0026#34;) (org-agenda-overriding-header \u0026#34;仕掛かり中\u0026#34;) (org-habit-show-habits nil) (org-agenda-span \u0026#39;day) (org-agenda-todo-keyword-format \u0026#34;-\u0026#34;) (org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/habits.org\u0026#34; \u0026#34;~/Documents/org/journal/\u0026#34;)) (org-super-agenda-groups (append (mapcar (lambda (key) `(:name ,key :and (:category ,key :todo (\u0026#34;DOING\u0026#34; \u0026#34;WAIT\u0026#34;)))) (if (boundp \u0026#39;my/nippou-categories) my/nippou-categories nil)) \u0026#39;((:discard (:anything t :name \u0026#34;discard\u0026#34;))))))))) (\u0026#34;H\u0026#34; \u0026#34;HouseWork\u0026#34; ((tags \u0026#34;HouseWork\u0026#34;))) (\u0026#34;E\u0026#34; . \u0026#34;Env\u0026#34;) (\u0026#34;EO\u0026#34; \u0026#34;org\u0026#34; ((tags-todo \u0026#34;+org\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34; \u0026#34;~/Documents/org/tasks/inbox.org\u0026#34;)))))) (\u0026#34;EE\u0026#34; \u0026#34;Emacs without org\u0026#34; ((tags-todo \u0026#34;+Emacs-org\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34; \u0026#34;~/Documents/org/tasks/inbox.org\u0026#34;)))))) (\u0026#34;Ee\u0026#34; \u0026#34;without Emacs\u0026#34; ((tags-todo \u0026#34;+Env-Emacs-org\u0026#34; ((org-agenda-files \u0026#39;(\u0026#34;~/Documents/org/tasks/projects.org\u0026#34; \u0026#34;~/Documents/org/tasks/inbox.org\u0026#34;))))))))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/",
	"title": "ファイル編集/入力補助",
	"tags": [],
	"description": "",
	"content": "ここにはファイル編集や入力補助の設定をまとめている\n基本設定 編集周りの基本的な設定 auto-insert ファイル新規作成時にテンプレートを挿入する機能 company-mode プラグイン拡張方式を採用した、入力補完インターフェースを提供してくれるやつ copilot GitHub Copilot を使えるようにするパッケージ emojify Slack や GitHub みたいに :smile: とか入れると笑顔の絵文字を表示する、みたいなやつ flyspell スペルチェックをしてくれるパッケージ multiple-cursors カーソルを増やして複数箇所を同時に編集できるようになるやつ origami コードの折り畳みができるようになるやつ smartparens カッコや引用符などのペアになるやつの入力補助をしてくれるやつ textlint 文章校正に便利なやつ undo-fu シンプルな undo/redo の機能を提供してくれるやつ view-mode Emacs に組込まれてる閲覧専用のモード。コードリーディングの時に有効にすると便利 whitespace 空白文字を可視化したり自動的に消したりする便利なやつ yasnippet テンプレート挿入機能を提供してくれるやつ "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-capture/",
	"title": "org-capture",
	"tags": [],
	"description": "",
	"content": "概要 org-capture は org-mode 用にさくっとメモを取るための機能。\norg-capture-ical-file unused https://qiita.com/takaxp/items/0b717ad1d0488b74429d を参考に設定したやつ。\n今は別で Google Calendar 連携しているので使ってない……。\n;; org-capture (defvar org-capture-ical-file (concat org-directory \u0026#34;ical.org\u0026#34;)) (setq org-capture-ical-file (concat org-directory \u0026#34;ical.org\u0026#34;)) capture 用ファイルを変数定義 improvement 変数定義しなくてもいい気がしないでもないけどとりあえず変数定義している。バラバラの変数にするよりも alist とか plist とかにする方が適切な気がする\n(setq my/org-capture-interrupted-file (concat my/org-tasks-directory \u0026#34;interrupted.org\u0026#34;)) (setq my/org-capture-inbox-file (concat my/org-tasks-directory \u0026#34;inbox.org\u0026#34;)) (setq my/org-capture-pointers-file (concat my/org-tasks-directory \u0026#34;pointers.org\u0026#34;)) (setq my/org-capture-impediments-file (concat org-directory \u0026#34;work/scrum/impediments.org\u0026#34;)) (setq my/org-capture-memo-file (concat org-directory \u0026#34;memo.org\u0026#34;)) (setq my/org-capture-sql-file (concat org-directory \u0026#34;work/sql.org\u0026#34;)) (setq my/org-capture-shopping-file (concat my/org-tasks-directory \u0026#34;shopping.org\u0026#34;)) (setq my/org-capture-2020-summary-file (concat org-directory \u0026#34;private/2020_summary.org\u0026#34;)) (setq my/org-small-topic-file (concat org-directory \u0026#34;small-topic.org\u0026#34;)) テンプレートの定義 上記の変数を使って capture 用テンプレートを登録している。\nKey 効果 備考 g GTD でとりあえず最初に放り込む Inbox に相当するファイルに登録 Why?, Goal, How? 等の欄を設けることでそのタスクの諸々をハッキリさせようとしている m とりあえずメモっておきたいやつを放り込む 最近使ってない。使いにくいのかも p 資料を放り込むやつ あとで読むリストになってる。読み終わっても、便利そうなのは DONE のまま置いている i 割込みタスクの登録 org-modeで割り込みにも対応した時間記録をとる方法 のやつを流用している。たまに使う。 I 開発を進める上での障害をリストアップする用 最近使ってない。溜めても振り替えってないので溜める気すらなくなった R 2020年の振り返り用 もう2020年は過去の話なので不要でしょ s SQL 用のメモに登録 さくっと書いた SQL を後からまた使えないかな〜と思って溜めてみている S 買物リストに登録 Inbox から refile でもいい気がする b Blogネタにエントリー 最近使ってない……。ブログ止まってるしな。 P Firefox からページの一部を資料として放り込む用 https://github.com/sprig/org-capture-extension 関係。Win では設定できてない L Firefox からページURLを資料として放り込む用 https://github.com/sprig/org-capture-extension 関係。Win では設定できてない c スケジュール管理用ファイルに登録 使ってない。対象ファイルを変えて使ってみてもいいかも (setq org-capture-templates `((\u0026#34;g\u0026#34; \u0026#34;Inbox にエントリー\u0026#34; entry (file ,my/org-capture-inbox-file) \u0026#34;* TODO %? %^G\\n** Ready の定義 - Why?, Goal, How? が埋められていること - How がある程度具体的に書かれていること ** Why? ** Info ** Goal ** How? ** Result \\t\u0026#34;) (\u0026#34;m\u0026#34; \u0026#34;Memoにエントリー\u0026#34; entry (file+headline ,my/org-capture-memo-file \u0026#34;未分類\u0026#34;) \u0026#34;*** %?\\n\\t\u0026#34;) (\u0026#34;p\u0026#34; \u0026#34;Pointersにエントリー\u0026#34; entry (file+headline ,my/org-capture-pointers-file \u0026#34;Pointers\u0026#34;) \u0026#34;** %?\\n\\t\u0026#34;) (\u0026#34;i\u0026#34; \u0026#34;割り込みタスクにエントリー\u0026#34; entry ;; 参考: http://grugrut.hatenablog.jp/entry/2016/03/13/085417 (file+headline ,my/org-capture-interrupted-file \u0026#34;Interrupted\u0026#34;) \u0026#34;** %?\\n\\t\u0026#34; :clock-in t :clock-resume t) (\u0026#34;I\u0026#34; \u0026#34;障害リストにエントリー\u0026#34; entry (file+headline ,my/org-capture-impediments-file \u0026#34;Impediments\u0026#34;) \u0026#34;** TODO %?\\n\\t\u0026#34;) (\u0026#34;R\u0026#34; \u0026#34;2020ふりかえりにエントリー\u0026#34; entry (file+headline ,my/org-capture-2020-summary-file \u0026#34;Timeline\u0026#34;) \u0026#34;** %?\\n\\t\u0026#34;) (\u0026#34;z\u0026#34; \u0026#34;一言・雑談ネタ\u0026#34; entry (file+headline ,my/org-small-topic-file \u0026#34;Topic\u0026#34;) \u0026#34;** %?\\n\\t\u0026#34;) (\u0026#34;s\u0026#34; \u0026#34;SQL にエントリー\u0026#34; entry (file+headline ,my/org-capture-sql-file \u0026#34;SQL\u0026#34;) \u0026#34;** %?\\n\\t\u0026#34;) (\u0026#34;S\u0026#34; \u0026#34;買い物リストエントリー\u0026#34; entry (file ,my/org-capture-shopping-file) \u0026#34;* TODO %?\\n\\t\u0026#34;) (\u0026#34;b\u0026#34; \u0026#34;Blogネタにエントリー\u0026#34; entry (file+headline ,my/org-capture-memo-file \u0026#34;Blogネタ\u0026#34;) \u0026#34;** %?\\n\\t\u0026#34;) (\u0026#34;P\u0026#34; \u0026#34;Protocol\u0026#34; entry (file+headline ,my/org-capture-pointers-file \u0026#34;Pointers\u0026#34;) \u0026#34;** %?\\n #+BEGIN_QUOTE\\n %i\\n #+END_QUOTE\\n\\n Source: %u, [[%:link][%:description]]\\n\u0026#34;) (\u0026#34;L\u0026#34; \u0026#34;Protocol Link\u0026#34; entry (file+headline ,my/org-capture-pointers-file \u0026#34;Pointers\u0026#34;) \u0026#34;** %:description\\n %:link\\n %?\\n Captured On: %U\u0026#34;) (\u0026#34;c\u0026#34; \u0026#34;同期カレンダーにエントリー\u0026#34; entry (file+headline ,org-capture-ical-file \u0026#34;Schedule\u0026#34;) \u0026#34;** TODO %?\\n\\t\u0026#34;))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/",
	"title": "UI",
	"tags": [],
	"description": "",
	"content": "ここでは Emacs の UI を変更するようなものを載せている\nalert 共通インターフェースで色々な通知機能と連携して通知するやつ all-the-icons Emacs で様々なアイコンを表示できるようにするやつ color-theme-molokai ダークグレーベースのカラーテーマ dashboard Emacs 起動時の表示を便利にしてくれるパッケージ frame-cmds フレーム移動や拡縮などの操作をするコマンド群 fullscreen 起動時のフルスクリーン設定 git-gutter-fringe 最後のコミットからどう弄ったかを fringe 領域に表示してくれるやつ highlight-indent-guides インデント毎にラインを引いたりして見易くしてくれるやつ hydra サブコマンドをビジュアル的に表示してくれるメニューを提供してくれるやつ ido-mode Emacs 標準添付の補完インターフェース ivy 絞り込みインターフェーズを提供してくれるやつ。 mode-line モードラインに関する設定をここにまとめている Neotree フォルダ構造を IDE みたいにツリー表示するやつ posframe いい感じの位置に child frame を表示する機能を提供するやつ show-paren-mode 対応するカッコとコッカをハイライトしてくれたりするやつ toolbar Emacs 標準のボタンなどの UI 部分の設定 uniquify 同名ファイルを開いている時にどこのファイルかまで表示してくれるやつ yascroll 主張の大人しいスクロールバーを表示してくれるやつ zoom フォーカスが当たってるウインドウを大きく表示してくれるやつ zoom-window 見ている window を最大化したり戻したりしてくれるやつ "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-clock/",
	"title": "org-clock",
	"tags": [],
	"description": "",
	"content": "概要 org-clock 関係の設定をここにまとめている\nclocktable の設定 clocktable は report 表示などで使う表の設定。\n(setq org-clock-clocktable-default-properties \u0026#39;(:maxlevel 10 :lang \u0026#34;ja\u0026#34; :scope agenda-with-archives :block today :level 4)) 項目名 設定内容 maxlevel ツリーの何段目まで表示するかの設定。隠さないで欲しいので大きい値を指定している lang 日本語ネイティブなので日本語で scope agenda とそのアーカイブもチェック。結構するアーカイブするので block 基本的に退勤前に実行するので today にしている level 最低限表示するレベル。まあ適当 hooks clock-in 時の hook clock-in のタイミングで以下の処理をするための hook を用意している\n作業開始したことを Slack 通知する TODO ステータスを DOING に変更 (defun my/org-clock-in-hook () (let* ((task org-clock-current-task) (message (format \u0026#34;開始: %s\u0026#34; task))) (my/notify-slack-times message)) (if (org-clocking-p) (org-todo \u0026#34;DOING\u0026#34;))) (setq org-clock-in-hook \u0026#39;my/org-clock-in-hook) clock-out 時の hook clock-out のタイミングで以下の処理をするための hook を用意している\n作業終了を Slack 通知する 中断でも終了扱いになるのでちょっと悩み中。DONE にしたことを hook する必要があるかも。 (defun my/org-clock-out-hook () (let* ((task org-clock-current-task) (message (format \u0026#34;終了: %s\u0026#34; task))) (my/notify-slack-times message))) (setq org-clock-out-hook \u0026#39;my/org-clock-out-hook) org-pomodoro ポモドーロテクニックを使うために org-pomodoro を導入している\n(el-get-bundle org-pomodoro) そして以下の設定をしている\nsound は結構邪魔なのでそれは鳴らないようにしている デフォルトの 25 分だと短かいので倍の 50 分にしている 25 分だとノって来た時に終わるので集中できない それに合わせて short break も倍にしている 10 分休めると間で色々できて便利。Emacs のパッケージ更新とか。 long break も通常の 1.5 倍にしている とはいえ long break になる頃は定時が近いので無視しがち (custom-set-variables \u0026#39;(org-pomodoro-play-sounds nil) \u0026#39;(org-pomodoro-length 50) \u0026#39;(org-pomodoro-short-break-length 10) \u0026#39;(org-pomodoro-long-break-length 30)) 今のところこの運用で大体うまくいってて良い\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/",
	"title": "ナビゲーション",
	"tags": [],
	"description": "",
	"content": "ここではカーソル移動やファイル移動などのナビゲーション系の設定を記載していく\nace-window 3つ以上にウインドウを分割している際のウインドウ切替を楽にしてくれるパッケージ avy 表示されてるところの好きな場所にさくっとジャンプするためのパッケージ browse-at-remote 表示している行の GitHub などのサービス上の位置でブラウザで開いてくれるパッケージ dumb-jump カーソル下の関数とかの定義場所にジャンプしてくれるパッケージ projectile プロジェクト内のファイルなどを開いたりするのに便利なパッケージ "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-export/",
	"title": "org-export",
	"tags": [],
	"description": "",
	"content": "概要 ここではファイルへの出力用の設定をまとめている。というか昔書いた設定をとりあえずここに押し込めている\nfootnote や制作者などを出力しない HTML で記事を吐き出す時に邪魔だったの非表示にしている記憶。随分昔に設定したのであんまり覚えてない。\n;; フッターなくしたり (setq org-export-html-footnotes-section \u0026#34;\u0026#34;) (setq org-export-html-footnote-format \u0026#34;\u0026#34;) (setq org-export-with-footnotes nil) (setq org-export-with-creator nil) (setq org-export-with-author nil) (setq org-html-validation-link nil) 以下は seesaa blog への吐き出し用設定なのだけどもう向こうを更新することはないので消しても良さそう\n;; for seesaa blog settings (setq org-export-author-info nil) (setq org-export-email-info nil) (setq org-export-creator-info nil) (setq org-export-time-stamp-file nil) (setq org-export-with-timestamps nil) (setq org-export-with-section-numbers nil) (setq org-export-with-sub-superscripts nil) Table of Contents 出力抑制 これも自分の用途では要らなかったけどファイル単位とかで制御しても良い気がする\n(setq org-export-with-toc nil) サイト名の出力 seesaa blog 用に記事を吐き出していた時はページ全体ではなく記事部分だけ出力したかったのでつまり h1 とかはもうテンプレート側に埋め込まれているので出す必要がなかった\nというわけで h1 でサイト名を出さないようにしている\n(setq org-export-html-preamble nil) (setq org-html-preamble nil) bold, italic などの抑制 アスタリスクで囲ったりスラッシュでアンダースコアで囲ったりすると b タグや i タグ、 u タグにする機能があるが HTML 4.01 Strict 信者だったこともあって抑制している。\nアスタリスクで囲む時、重要と思って囲むので、そういう意味では em とかで出る方が適切だと思う。\n;;; *bold* とか /italic/ とか _underline_ とかを\u0026lt;b\u0026gt;とかにしないようにする (setq org-export-with-emphasize nil) export のデフォルト出力言語は日本語 まあ日本語しか書かないので……\n(setq org-export-default-language \u0026#34;ja\u0026#34;) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/",
	"title": "プログラミング関係の設定",
	"tags": [],
	"description": "",
	"content": "ここでは各言語やフレームワーク毎の設定をまとめている。 markdown-mode とか yaml-mode なんかはプログラム言語ではないけど面倒なので一旦ここにまとめている。\nDocker Dockerfile を書くための設定 emacs-lisp Emacs Lisp を書くための設定 Ember.js Web フロントエンド MVC フレームワークである Ember.js 用の設定を書いている es6 ES2015 以降の JS に関する設定。es6 としているのは過去の経緯のため。 flycheck Flycheck の設定について書いている gnuplot-mode グラフ作成ソフト gnuplot を使うための設定 GraphQL GraphQL ファイルを編集するための設定 Jest JS のテストツール Jest 関係の設定 JSON JSON ファイルを編集するための設定 lsp-mode Emacs の LSP クライアントの一種である lsp-mode に関する設定 markdown Markdown を書く時の設定 Mocha Mocha を使ったテストを動かすための設定 plantuml-mode PlantUML を書く時のメジャーモードの設定 rails Rails 開発をする上での設定 React.js React.js アプリを開発するための設定 rspec-mode Ruby のテストフレームワーク RSpec を書いたりするのに便利なモード ruby Ruby を書く上での設定 scss SCSS を書く上での設定 tree-sitter 軽量な文法解析ツールである tree-sitter を利用するための設定を書いている TypeScript TypeScript を書く上での設定 Vue.js Vue.js を書く上での設定 yaml-mode YAML を書く時のメジャーモードの設定 "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-gcal/",
	"title": "org-gcal",
	"tags": ["replacement"],
	"description": "",
	"content": "概要 org-gcal は org-mode と Google Calendar を連携させるためのパッケージ。\nオリジナルは https://github.com/myuhe/org-gcal.el なのだけど今は fork されてるやつが MELPA にも登録されていて el-get のレシピもそっちを見ている。\nインストール org-gcal が依存しているので parsist を入れている。\n(el-get-bundle persist) あとは当然 org-gcal 本体を入れないと動かない\n(el-get-bundle org-gcal) その際 el-get のレシピは自前で用意している\n(:name org-gcal :description \u0026#34;Org sync with Google Calendar.\u0026#34; :website \u0026#34;https://github.com/kidd/org-gcal.el\u0026#34; :type github :minimum-emacs-version \u0026#34;26\u0026#34; :depends (request alert cl-lib aio) :pkgname \u0026#34;kidd/org-gcal.el\u0026#34;) emacs-aio も recipe を自前で用意している\n(:name aio :website \u0026#34;https://github.com/skeeto/emacs-aio\u0026#34; :description \u0026#34;aio is to Emacs Lisp as asyncio is to Python.\u0026#34; :type github :pkgname \u0026#34;skeeto/emacs-aio\u0026#34;) のだけど確か org-gcal のレシピは修正されているし emacs-aio も recipe 追加されてたはずなので多分これは el-get 本体のものに切り替えても良いはず……\n設定 まずは org-gcal の設定が authinfo から読み込まれるようにする\n(custom-set-variables \u0026#39;(org-gcal-client-id (plist-get (nth 0 (auth-source-search :host \u0026#34;googleusercontent.com\u0026#34;)) :client)) \u0026#39;(org-gcal-client-secret (funcall (plist-get (nth 0 (auth-source-search :host \u0026#34;googleusercontent.com\u0026#34; :max 1)) :secret)))) そして org-gcal 本体を require する。\n(require \u0026#39;org-gcal) あとは passphrase を保存できるようにした方が良いみたいなのが確か README に比較的最近追加されたのでそれを入れている\n(setq plstore-cache-passphrase-for-symmetric-encryption t) あとは設定ファイルは公開したくないので別ファイルに分けてる。\n(my/load-config \u0026#34;my-org-gcal-config\u0026#34;) 隠したい部分だけ .authinfo.gpg にでも分離したら公開できるようになるかもしれない。\nappt Emacs にはデフォルトで約束の通知ができる機能が appt.el で定義されている。 org-gcal で取得したデータをそれで通知できるように appt の設定をここで行っている\n通知形式の設定 window 通知を使う設定にしている。\n(setq appt-display-format \u0026#39;window) これだけだと、通知する時間になったらピョコッと window が生えて来るのだけど、後の方で、この設定の時に使う関数を差し替えている\n通知用関数の定義 通知には alert.el を使いたいので自前で関数を定義。 alert.el は別のところで設定していてそこで dunst を使って通知するようにしている。\n(defun my/appt-alert (min-to-app _new-time msg) (interactive) (let ((title (format \u0026#34;あと %s 分\u0026#34; min-to-app))) (alert msg :title title))) この関数を使うように appt-disp-window-function を変更している。\n(setq appt-disp-window-function \u0026#39;my/appt-alert) 最後に org-gcal でカレンダーを取得した後に appt に登録されるように advice を設定した\n(advice-add #\u0026#39;org-gcal--sync-unlock :after #\u0026#39;my/org-refresh-appt) その他 gcal-org に乗り換えようかと思ってるがそっちの中身もよくわからないので躊躇している。自分の用途に合うのだろうか?\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/",
	"title": "外部連携ツール設定",
	"tags": [],
	"description": "",
	"content": "ここでは外部のサービスと連携するようなやつをまとめています\nemacs-w3m 和製テキストブラウザである w3m を Emacs で使えるようにするパッケージ esa.el esa.io と連携するためのパッケージ forge magit と GitHub を連携して Emacs 上で PR を眺めたりできるようにするパッケージ git-messenger 現在の行の最終コミットの情報を表示してくれるパッケージ google-this Google 検索機能を提供してくれるパッケージ google-translate Emacs から Google 翻訳するためのパッケージ magit Emacs 上で Git の操作をするのにとても便利なパッケージ notify-slack Emacs から外部コマンドを通じて Slack に通知するための関数周りの事を書いている openai Emacs から OpenAI API を利用するためのライブラリ todoist Todoist と連携して org-mode で扱えるようにするパッケージ twmode Emacs 上で動く Twitter クライアント wakatime-mode Emacs と WakaTime を連携してどのプロジェクトの作業をどのぐらいしてたかを計測するパッケージ ブラウザ設定 ブラウザ連携周りの設定 "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/",
	"title": "org-mode",
	"tags": [],
	"description": "",
	"content": "ここでは org-mode 周りの設定をまとめている。 org-mode だけでも書くことが多いからね……。\n基本設定 org-babel 予定のカレンダー表示 Agenda 関係の設定 org-capture org-clock org-export org-gcal org-ql org-refile org-trello ox-hugo org-mode 用の独自コマンド org-mode 関係の keybinds 日報用の設定(旧) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-ql/",
	"title": "org-ql",
	"tags": ["unused"],
	"description": "",
	"content": "概要 org-ql は org-mode の情報を検索するためのパッケージ。柔軟な検索ができるようになるので貴方好みの検索で業務効率向上ができちゃうかも!?\nインストール いつも透り el-get でインストールしている\n(el-get-bundle org-ql) その他 一時期は色々試していたけどこれを利用している org-super-agenda の方でなんとかするようにしたのでもう直接は使ってないでござる\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-refile/",
	"title": "org-refile",
	"tags": [],
	"description": "",
	"content": "概要 org-refile は org-mode の1機能で org-mode のエントリを別のファイルなどに移動するための機能。実はコピーもできるけど、コピーは使ったことがない。\n設定 org ファイル内の階層を選択候補に入れる これを nil に設定することでファイルの選択だけでなく、その中の PATH まで選択できるようになる\n(setq org-outline-path-complete-in-steps nil) refile ターゲットにファイル名を含める 以下のように設定すると refile のターゲット候補としてファイル名とその中の PATH が表示されるようになる。\n(setq org-refile-use-outline-path \u0026#39;file) nil だと移動先候補PATHの最後の部分しか表示されないのでどのファイルのどの場所かというのがわかりにくいのでこのように設定している。\nrefile 先の候補設定 いくつかの org ファイルを使っているのでターゲットを以下のように設定している。\nなお関数化することで hook で呼び出せるようにしている\n(defun my/reset-org-refile-targets () (setq org-refile-targets `((,(org-journal--get-entry-path) :regexp . \u0026#34;Tasks\u0026#34;) (,(concat org-directory \u0026#34;tasks/projects.org\u0026#34;) :level . 1) (,(concat org-directory \u0026#34;tasks/pointers.org\u0026#34;) :level . 1) (,(concat org-directory \u0026#34;tasks/someday.org\u0026#34;) :level . 1)))) (my/reset-org-refile-targets) ターゲット 目的 projects.org とりあえずその内やるタスクを放り込むところ。Work, Private の階層を設けているので :level 2 としている pointers.org 読物を突っ込むところとしている。 someday.org 遠い将来やるかもしれないリスト。放り込んで忘れるためにあるところ "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/",
	"title": "テスト用ツール",
	"tags": [],
	"description": "",
	"content": "自動テストを実行するにあたり、追加インストールしているパッケージをここに載せている\nwith-simulated-input 入力処理をシミュレートしてくれるパッケージ mocker.el Mock/Stub するためのパッケージ。まだ使ってない noflet ローカル定義の関数を用意するためのパッケージ。副作用の結果を含めて関数を置き換えたい時に便利 "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-trello/",
	"title": "org-trello",
	"tags": [],
	"description": "",
	"content": "概要 org-trello は org-mode を使って Trello のタスクを管理するためのパッケージ。\nインストール いつも通り el-get でインストールしている\n(el-get-bundle org-trello) 同期するコマンドの用意 バッファと Trello との同期する関数はあるのだけどコマンドにはなっていなかったので同期するためのコマンドを用意している\n(defun my/org-trello-fetch-buffer () (interactive) (org-trello-sync-buffer t)) キーバインド設定 キーバインドは覚えられないので、いつも通り pretty-hydra で Hydra のやつを用意している\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define org-trello-hydra (:separator \u0026#34;-\u0026#34; :color teal :foreign-key warn :title (concat (all-the-icons-faicon \u0026#34;trello\u0026#34;) \u0026#34; Org Trello commands\u0026#34;) :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Install\u0026#34; ((\u0026#34;i\u0026#34; org-trello-install-board-metadata \u0026#34;Board metadata\u0026#34;) (\u0026#34;I\u0026#34; org-trello-install-key-and-token \u0026#34;Setup\u0026#34;)) \u0026#34;Sync\u0026#34; ((\u0026#34;s\u0026#34; my/org-trello-fetch-buffer \u0026#34;← Trello\u0026#34;) (\u0026#34;S\u0026#34; org-trello-sync-buffer \u0026#34;→ Trello\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;V\u0026#34; org-trello-version \u0026#34;Version\u0026#34;))))) Key 効果 i Board のメタデータをインストールする I Key と トークンを設定する s Trello の情報を引っ張ってくる S Trello の情報を連携する V バージョン情報を表示 その他 まだ試していないが https://github.com/gizmomogwai/org-kanban と組み合わせるとビジュアル的に見れて嬉しいとかあるかもしれない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/",
	"title": "テストコード",
	"tags": [],
	"description": "",
	"content": "一部のコマンドなどの設定を書き始めているので設けたセクション。\n暫定的にここに置いているが設定と近い方が良さそうなのでいずれドキュメント内の位置を移動しそう。\n実行方法 とりあえず書かれているテストを動かす方法を書いている。 run-tests テスト全体を動かすための共通設定ファイルの説明 my-org-commands-test org-mode 用に自分が生やしたコマンドのテストファイルの解説 "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/ox-hugo/",
	"title": "ox-hugo",
	"tags": [],
	"description": "",
	"content": "概要 ox-hugo は org-mode から Hugo 用に md ファイルを出力できる便利なやつ。\n設定にもよるけど、1つのorgファイルに全部の記事を書いておいてツリー毎に md ファイルが生成される、というのがデフォルトの動きなので 1ファイルに詰めておくとファイルが分散しないで済んで良い。\nなお、この 麦汁\u0026rsquo;s Emacs Config も親サイトである 麦汁三昧 も ox-hugo を用いて構築している\nインストール・読み込み レシピは自前で用意している\n(:name ox-hugo :description \u0026#34;A carefully crafted Org exporter back-end for Hugo https://ox-hugo.scripter.co\u0026#34; :type github :pkgname \u0026#34;kaushalmodi/ox-hugo\u0026#34; :branch \u0026#34;main\u0026#34; :depends (org-mode tomelr)) 依存している tomelr のレシピも自前で用意している\n(:name tomelr :description \u0026#34;Emacs-Lisp Library for converting S-expressions to TOML\u0026#34; :type github :pkgname \u0026#34;kaushalmodi/tomelr\u0026#34; :branch \u0026#34;main\u0026#34;) そしていつも通り el-get でインスコしている。\n(el-get-bundle ox-hugo) そして org-mode の ox が先に読まれてないといけないので with-eval-after-load を使って、ox が読まれてから require するようにしている。\n(with-eval-after-load \u0026#39;ox (require \u0026#39;ox-hugo)) その他 デフォルト設定でいい感じに使えているので特に設定変更は加えていない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-commands/",
	"title": "org-mode 用の独自コマンド",
	"tags": [],
	"description": "",
	"content": "概要 org-mode を使う上で、標準で用意されているコマンド以外に自分でも適当にコマンドを用意しているのでここにまとめている。\norg-mode 用のファイルを作成するコマンド unused 指定したフォルダに org-mode なファイルを作るためのコマンドを用意している。\nが、使ってないし意味をあまり感じないし消して良さそう。\n(setq my/org-document-dir (expand-file-name \u0026#34;~/Documents/org/\u0026#34;)) (defun my/create-org-document () (interactive) (find-file-other-window my/org-document-dir)) 各ツリーの所要時間表示/非表示切替 org-clock-display で各ツリーにおける org-clock で記録された所要時間が表示でき、 org-clock-remove-overlays でそれを非表示にできるが、それを Toggle できるようにコマンド/関数を定義している。\n(defun my/org-clock-toggle-display () \u0026#34;各ツリーの末尾に掛かった作業時間を表示/非表示を切り替えるコマンド\u0026#34; (interactive) (if org-clock-overlays (org-clock-remove-overlays) (org-clock-display))) org-todo-keywords から装飾を省いた文字列のリストを返す関数 ivy で org-todo-keywords を選択可能にするために org-todo-keywords を加工してシンプルな文字列の配列にする関数を定義している。\n後述の my/org-todo で利用している\n(defun my/org-todo-keyword-strings () \u0026#34;org-todo-keywords から装飾を省いた文字列のリストを返す関数\u0026#34; (let* ((keywords (cl-rest (cl-first org-todo-keywords))) (without-delimiter (cl-remove-if (lambda (elm) (string= \u0026#34;|\u0026#34; elm)) keywords))) (mapcar (lambda (element) (replace-regexp-in-string \u0026#34;\\(.+\\)\u0026#34; \u0026#34;\u0026#34; element)) without-delimiter))) Ivy で TODO ステータスを選択し設定するコマンド 標準の org-todo だと画面がガチャガチャ動くのが気になったので ivy で選択できるようにしている。\n(defun my/org-todo () \u0026#34;ivy で TODO ステータスを切り替えるためのコマンド Hydra から利用するために定義している。\u0026#34; (interactive) (ivy-read \u0026#34;Org todo: \u0026#34; (my/org-todo-keyword-strings) :require-match t :sort nil :action (lambda (keyword) (org-todo keyword)))) タグ選択でそのタグがついたヘッドラインをリスト表示 タグ毎に見たいことがありそうなので用意したやつ。存在を忘れてしまっていたのであまり使ってない。\nカスタムアジェンダを頑張る方が良い気もする\n(defun my/org-tags-view-only-todo () (interactive) (org-tags-view t)) org-gcal で取得した情報を appt に登録 appt.el で通知されるように登録する必要があるのでコマンドを定義している。\n(defun my/org-refresh-appt () (interactive) (let ((org-agenda-files (append my/org-agenda-calendar-files org-agenda-files))) (org-agenda-to-appt t))) calfw で選択したカレンダーを表示 (defun my/open-calendar () (interactive) (ivy-read \u0026#34;Calendar: \u0026#34; my/calendar-targets :require-match t :sort nil :action (lambda (target) (progn (setq cfw:org-icalendars `(,(concat org-directory target \u0026#34;.org\u0026#34;))) (cfw:open-org-calendar))))) レビュー依頼がされてる PR を取得してバッファに挿入 review-requested-prs というコマンドでレビュー対象の PR を取得できるようにしているのでそれを Emacs から叩けるようにしているコマンド。\n(defun my/insert-review-requested-prs-as-string () (interactive) (let* ((cmd (concat \u0026#34;review-requested-prs \u0026#34; my/github-organization \u0026#34; \u0026#34; my/github-repository)) (response (shell-command-to-string cmd))) (insert response))) 実際のところこの Emacs のコマンドは使わず Terminal で review-requested-prs というコマンドを直で叩いているから何かしら工夫が必要そうである。\nあと、そもそも既にバッファにあるやつとマージしたいとか色々やりたいことはあるのでそれをなんとかしたいですね。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-mode-keybinds/",
	"title": "org-mode 関係の keybinds",
	"tags": [],
	"description": "",
	"content": "概要 ここでは org-mode 関係のキーバインド設定を書いている。キーバインドというか Hydra の設定になっているが。\nHydra を定義しておくことで様々なキーバインドを忘れることができるし左手小指を酷使しなくて済むので便利ということで Hydra で設定している。\nmajor-mode-hydra major-mode-hydra で、org-mode のファイルを開いている時によく使いそうなコマンドのキーバインドを定義している\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define org-mode (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-fileicon \u0026#34;org\u0026#34;) \u0026#34; Org commands\u0026#34;)) (\u0026#34;Navigation\u0026#34; ((\u0026#34;H\u0026#34; counsel-outline \u0026#34;Outline\u0026#34;)) \u0026#34;Insert\u0026#34; ((\u0026#34;l\u0026#34; org-insert-link \u0026#34;Link\u0026#34;) (\u0026#34;T\u0026#34; org-insert-todo-heading \u0026#34;Todo\u0026#34;) (\u0026#34;h\u0026#34; org-insert-heading-respect-content \u0026#34;Heading\u0026#34;) (\u0026#34;P\u0026#34; org-set-property \u0026#34;Property\u0026#34;) (\u0026#34;.\u0026#34; org-time-stamp \u0026#34;Timestamp\u0026#34;) (\u0026#34;!\u0026#34; org-time-stamp-inactive \u0026#34;Timestamp(inactive)\u0026#34;) (\u0026#34;S\u0026#34; org-insert-structure-template \u0026#34;Snippet\u0026#34;)) \u0026#34;Edit\u0026#34; ((\u0026#34;a\u0026#34; org-archive-subtree \u0026#34;Archive\u0026#34;) (\u0026#34;r\u0026#34; org-refile \u0026#34;Refile\u0026#34;) (\u0026#34;Q\u0026#34; org-set-tags-command \u0026#34;Tag\u0026#34;)) \u0026#34;View\u0026#34; ((\u0026#34;N\u0026#34; org-toggle-narrow-to-subtree \u0026#34;Toggle Subtree\u0026#34;) (\u0026#34;C\u0026#34; org-columns \u0026#34;Columns\u0026#34;) (\u0026#34;O\u0026#34; org-global-cycle \u0026#34;Toggle open\u0026#34;) (\u0026#34;D\u0026#34; my/org-clock-toggle-display \u0026#34;Toggle Display\u0026#34;)) \u0026#34;Task\u0026#34; ((\u0026#34;s\u0026#34; org-schedule \u0026#34;Schedule\u0026#34;) (\u0026#34;d\u0026#34; org-deadline \u0026#34;Deadline\u0026#34;) (\u0026#34;t\u0026#34; my/org-todo \u0026#34;Change state\u0026#34;) (\u0026#34;c\u0026#34; org-toggle-checkbox \u0026#34;Toggle checkbox\u0026#34;)) \u0026#34;Clock\u0026#34; ((\u0026#34;i\u0026#34; org-clock-in \u0026#34;In\u0026#34;) (\u0026#34;o\u0026#34; org-clock-out \u0026#34;Out\u0026#34;) (\u0026#34;E\u0026#34; org-set-effort \u0026#34;Effort\u0026#34;) (\u0026#34;R\u0026#34; org-clock-report \u0026#34;Report\u0026#34;) (\u0026#34;p\u0026#34; org-pomodoro \u0026#34;Pomodoro\u0026#34;)) \u0026#34;Babel\u0026#34; ((\u0026#34;e\u0026#34; org-babel-confirm-evaluate \u0026#34;Eval\u0026#34;) (\u0026#34;x\u0026#34; org-babel-tangle \u0026#34;Export SRC\u0026#34;)) \u0026#34;Trello\u0026#34; ((\u0026#34;K\u0026#34; org-trello-mode \u0026#34;On/Off\u0026#34; :toggle org-trello-mode) (\u0026#34;k\u0026#34; (if org-trello-mode (org-trello-hydra/body) (message \u0026#34;org-trello-mode is not enabled\u0026#34;)) \u0026#34;Menu\u0026#34;)) \u0026#34;Agenda\u0026#34; ((\u0026#34;,\u0026#34; org-cycle-agenda-files \u0026#34;Cycle\u0026#34;)))) (major-mode-hydra-define org-agenda-mode (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-octicon \u0026#34;calendar\u0026#34;) \u0026#34; Agenda commands\u0026#34;)) (\u0026#34;Edit\u0026#34; ((\u0026#34;a\u0026#34; org-agenda-archive \u0026#34;Archive\u0026#34;) (\u0026#34;r\u0026#34; org-agenda-refile \u0026#34;Refile\u0026#34;) (\u0026#34;t\u0026#34; org-agenda-todo \u0026#34;TODO\u0026#34;) (\u0026#34;Q\u0026#34; org-agenda-set-tags \u0026#34;Tag\u0026#34;)) \u0026#34;Filter\u0026#34; ((\u0026#34;C\u0026#34; org-agenda-filter-by-category \u0026#34;Category\u0026#34;) (\u0026#34;T\u0026#34; org-agenda-filter-by-tag \u0026#34;Tag\u0026#34;) (\u0026#34;H\u0026#34; org-agenda-filter-by-top-headline \u0026#34;Headline\u0026#34;) (\u0026#34;E\u0026#34; org-agenda-filter-by-effort \u0026#34;Effort\u0026#34;) (\u0026#34;R\u0026#34; org-agenda-filter-by-regex \u0026#34;Regex\u0026#34;) (\u0026#34;z\u0026#34; org-agenda-filter-remove-all \u0026#34;Clear\u0026#34;)) \u0026#34;Priority\u0026#34; ((\u0026#34;\u0026gt;\u0026#34; org-agenda-priority-up \u0026#34;Up\u0026#34;) (\u0026#34;\u0026lt;\u0026#34; org-agenda-priority-down \u0026#34;Down\u0026#34;) (\u0026#34;,\u0026#34; org-agenda-priority \u0026#34;Set\u0026#34;)) \u0026#34;Clock\u0026#34; ((\u0026#34;i\u0026#34; org-agenda-clock-in \u0026#34;In\u0026#34;) (\u0026#34;o\u0026#34; org-agenda-clock-out \u0026#34;Out\u0026#34;) (\u0026#34;p\u0026#34; org-pomodoro \u0026#34;Pomodoro\u0026#34;) (\u0026#34;e\u0026#34; org-agenda-set-effort \u0026#34;Set Effort\u0026#34;) (\u0026#34;g\u0026#34; org-agenda-clock-goto \u0026#34;Go to\u0026#34;) (\u0026#34;x\u0026#34; org-agenda-clock-cancel \u0026#34;Cancel\u0026#34;))))) Key 効果 使用頻度 l リンク挿入 C-c C-l で手が馴染んでるのでたまに使う程度 T TODO ヘッドライン挿入 なんかあまり使わない h ヘッドライン挿入 これも C-RET で慣れてるので使ってない P プロパティ設定 よく使う . タイムスタンプ挿入 使ってない。使い慣れると便利かも ! アジェンダのエントリに反映されないタイムスタンプ挿入 使ってない。こっちも慣れると便利かも? S \u0026lt;s TAB とかのテンプレートの挿入 使ってないなあ。慣れたら便利かも a サブツリーをアーカイブ よく使う r サブツリーの移動(refile) よく使う Q タグ設定 時々使う。C-c C-q の方が使うか N カーソル位置のサブツリーのみ表示 使ってない。そのツリーだけに集中することがないのかも C カラム表示。ツリー内の時間などを合計して表示できる たまに使う。 D 各ツリーでそれぞれの掛かった時間を表示 使ってない。存在忘れてた s スケジュール設定 C-c C-s をよく使う d 締め切り設定 C-c C-d をよく使う t TODO ステータス変更 同じ効果である C-c C-t と同じぐらい使う c チェックボックスの切替 使うけどチェックボックスの行だけ使えればいいよなとか思う i Clock In よく使う。標準的なキーバインドは忘れた。 o Clock Out よく使う。標準的なキーバインドは忘れた。 E 見積時間の挿入 まあまあ使う。設定して予実差の確認はできてない R org-clock のレポート挿入 一応毎日の稼動をこれで記録している p ポモドーロタイマーの開始 ポモドーロテクニック使えてないでござる e org-babel のコード片を実行 C-c C-c しか使ってない気がするお x tangle でファイル出力 最近多用している K org-trello-mode の切替 最近使ってない。trello 連携してないバッファでは要らんしな k org-trello-mode 用の Hydra 起動 同上 , agenda ファイルの移動 いつも固定のファイルを見てるので使ってない。Cycle より直で飛ぶし 合わせて agenda 用の major-mode-hydra も定義しているが、こちらは情報をまだまとめていない……。\nGlobal な Hydra pretty-hydra を使って Global に使える org-mode のコマンドを叩けるようにしている\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define global-org-hydra (:separator \u0026#34;-\u0026#34; :color teal :foreign-key warn :title (concat (all-the-icons-fileicon \u0026#34;org\u0026#34;) \u0026#34; Global Org commands\u0026#34;) :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Main\u0026#34; ((\u0026#34;a\u0026#34; org-agenda \u0026#34;Agenda\u0026#34;) (\u0026#34;c\u0026#34; counsel-org-capture \u0026#34;Capture\u0026#34;) (\u0026#34;l\u0026#34; org-store-link \u0026#34;Store link\u0026#34;) (\u0026#34;J\u0026#34; org-journal-new-entry \u0026#34;Journal\u0026#34;) (\u0026#34;R\u0026#34; my/org-reviews-execute \u0026#34;Review\u0026#34;) (\u0026#34;t\u0026#34; my/org-tags-view-only-todo \u0026#34;Tagged Todo\u0026#34;)) \u0026#34;Calendar\u0026#34; ((\u0026#34;F\u0026#34; org-gcal-fetch \u0026#34;Fetch Calendar\u0026#34;) (\u0026#34;C\u0026#34; my/open-calendar \u0026#34;Calendar\u0026#34;) (\u0026#34;A\u0026#34; my/org-refresh-appt \u0026#34;Appt\u0026#34;)) \u0026#34;Clock\u0026#34; ((\u0026#34;i\u0026#34; org-clock-in \u0026#34;In\u0026#34;) (\u0026#34;o\u0026#34; org-clock-out \u0026#34;Out\u0026#34;) (\u0026#34;r\u0026#34; org-clock-in-last \u0026#34;Restart\u0026#34;) (\u0026#34;x\u0026#34; org-clock-cancel \u0026#34;Cancel\u0026#34;) (\u0026#34;j\u0026#34; org-clock-goto \u0026#34;Goto\u0026#34;)) \u0026#34;Search\u0026#34; ((\u0026#34;H\u0026#34; org-search-view \u0026#34;Heading\u0026#34;) (\u0026#34;O\u0026#34; counsel-org-goto-all \u0026#34;Outline\u0026#34;)) \u0026#34;Roam\u0026#34; ((\u0026#34;;\u0026#34; org-roam-hydra/body \u0026#34;Menu\u0026#34;)) \u0026#34;Pomodoro\u0026#34; ((\u0026#34;p\u0026#34; org-pomodoro \u0026#34;Pomodoro\u0026#34;))))) Key 効果 使用頻度 a Agenda 選択 よく使う c Capture よく使う l その場所へのリンクを保存 使ってない t 選択したタグが付与された TODO のみ表示 使ってない。使うと便利かもなあ F Google Calendar の情報取得 平日は毎日使っている C カレンダーを calfw で開く 最近使ってない A org-gcal で拾って来た情報を appt に登録 appt.el 経由で通知できるようにしている i Clock In 使ってないというか major-mode-hydra の方があれば良い o Clock Out 使ってない。使ってもいい気がする r 最後に Clock In したやつを再開 使ってない。大体常に Clock しているから最後がいつも切り替わってるので使う機会がない x Clock Cancel 作業は発生しているからキャンセルしないで普通に Clock out しているなあ j 最後に Clock In したやつの場所に移動 ちょくちょく使う。便利 H Heading の検索 使ってない。インクリメンタルに検索できればいいのに p ポモドーロタイマー これも major-mode-hydra にあれば十分かな その他 org-agenda 用の Hydra も用意しておいた方が良さそうだなというのが最近の実感。同じコマンド体系で操作できるようにしておいたら考えることが減って楽。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/nippou/",
	"title": "日報用の設定(旧)",
	"tags": ["unused"],
	"description": "",
	"content": "概要 業務で日報を提出する必要があったのでそれっぽいのを作れるようにしていた。\n今では org-super-agenda を使っているのでこれは使ってないが、とりあえず載せておく。\nシークレット設定の読み込み 表に出したくない情報については別ファイルに分離して setq している。が、内容的に本名が露出する程度の情報ではある。\n(my/load-config \u0026#34;my-nippou-config\u0026#34;) これの中で my/org-nippou-additional-files を定義していてそのファイル名に名前が含まれてるだけであった。\nme.org とでもしておけば解決しそう……。\n日報構築の対象となるファイルをリストアップする関数の定義 ~/Documenets/org/tasks に作業記録用ファイルなどを find コマンドを使ってリストアップする関数。\n(defun my/org-nippou-files () (let* ((dir my/org-tasks-directory) (cmd (format \u0026#34;find \\\u0026#34;%s\\\u0026#34; -name \u0026#39;*.org\u0026#39; -or -name \u0026#39;*.org_archive\u0026#39;\u0026#34; dir)) (result (shell-command-to-string cmd)) (file-names (split-string result \u0026#34;\\n\u0026#34;))) (-remove (lambda (file-name) (string= \u0026#34;\u0026#34; file-name)) file-names))) org-agenda-files を使えば要らないっぽいけどね。 agenda 全然使えてなかったらこんなことに。\n日報構築元ファイルを取得する関数の定義 シークレット設定で定義した変数と上で定義した my/org-nippou-files を結合して 1つのリストにするだけの関数を用意している。 1つにまとまってる方が扱いやすいので。\n(defun my/org-nippou-targets () (-concat (my/org-nippou-files) my/org-nippou-additional-files)) 日報を出力する関数 上記の関数群で target になるファイルから日報用に TODO 項目を引っ張り出してくる関数を用意している。\n(defun my/nippou-query () (interactive) (org-ql-search (my/org-nippou-targets) \u0026#34;todo:TODO,DOING,WAIT,DONE ts:on=today\u0026#34; :title \u0026#34;日報\u0026#34; :super-groups \u0026#39;((:auto-group)))) その中では org-ql の org-ql-search という関数を叩いている。 org-ql は使いこなすと色々なことができそうではあるがそれを内部で使ってる org-super-agenda を使えば十分な感じではある。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/ace-window/",
	"title": "ace-window",
	"tags": [],
	"description": "",
	"content": "概要 Window 間の移動を ace-jump や avy のように表示されてる文字の Window に移動するやつ。\nWindow が2分割の時は文字も出ないで別の Window に移動してくれる。\nC-x o にデフォルトで設定されている other-window は別の window に順番に移動するコマンドなので大量に分割していると移動がしんどいのだが ace-window を使うと起動して 1 ストロークで移動できるので C-x o をデフォルトの other-window から ace-window そのまま置き換えても便利に使える。\nインストール いつも通り el-get でインストールしている。\n(el-get-bundle ace-window) 設定 キーバインドは別の箇所で定義しているが C-x o で ace-window が起動するようにしている。\nまた Hydra からは ace-swap-window が起動できるようにしている。\nace-window には色々な機能があるからそれ用の Hydra を別途定義してもいいかもしれない。\nace-window 起動時に選択可能な数字が各 buffer の中央にいい感じに表示されるようにするため ace-window-posfrme-mode を有効にしている\n(with-eval-after-load \u0026#39;ace-window (ace-window-posframe-mode t)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/alert/",
	"title": "alert",
	"tags": [],
	"description": "",
	"content": "概要 alert は色々な通知システムに対応した通知を飛ばせるパッケージ。 Mac だと Growl だったり terminal-notifier だったり Win だと toast だったり Linux だと libnotify だったりを使ってその環境での標準的な通知機能を使って通知ができるやつ。\nインストール いつも通りに el-get でインストール。\n(el-get-bundle alert) 設定 業務では Mac を使ってるので terminal-notifier を設定している。他の環境では libnotify にしている。\n(if (or (eq window-system \u0026#39;ns) (eq window-system \u0026#39;mac)) (setq alert-default-style \u0026#39;notifier) ;; use terminal-notifier (setq alert-default-style \u0026#39;libnotify)) 「他の環境」が WSL 上の Emacs と Manjaro 上の Emacs なのだけども、後者は最近使ってないので無視して libnotify で通知するように設定を変えた。\n本当は WSL2 でもいい感じに通知されるようにしたいが WSLで通知を出すメモ - cobodoのブログ とかを見てるとちょっと面倒そう。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/all-the-icons/",
	"title": "all-the-icons",
	"tags": [],
	"description": "",
	"content": "概要 all-the-icons は Emacs で様々なアイコンを表示できるようにして華やかにしてくれるパッケージです。 Neotree などでも対応していてアイコンでファイルの種類が表示されるようになってモダンな雰囲気が出ます。\nインストール improvement いつも通り el-get-bundle で入れている。明示的に require している理由は忘れました。\n(el-get-bundle all-the-icons) (require \u0026#39;all-the-icons) フォントのインストール 以下のコマンドを叩くことでフォントをインストールすることができる。 all-the-icons のインストール直後に叩いておいたら普段は叩かなくて良いはず。\n(all-the-icons-install-fonts) all-the-icons の更新後は叩いた方がいいかもしれない\nキーバインド improvement キーバインドは覚えられないし、使えるキーも大分埋まってるので、 pretty-hydra を使って all-the-icons 用の Hydra を用意している。\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define all-the-icons-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;All the icons\u0026#34; :exit t :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Insert\u0026#34; ((\u0026#34;a\u0026#34; all-the-icons-insert-alltheicon \u0026#34;All the icons\u0026#34;) (\u0026#34;f\u0026#34; all-the-icons-insert-fileicon \u0026#34;File icons\u0026#34;) (\u0026#34;F\u0026#34; all-the-icons-insert-faicons \u0026#34;FontAwesome\u0026#34;) (\u0026#34;m\u0026#34; all-the-icons-insert-material \u0026#34;Material\u0026#34;) (\u0026#34;o\u0026#34; all-the-icons-insert-octicon \u0026#34;Octicon\u0026#34;) (\u0026#34;w\u0026#34; all-the-icons-insert-wicon \u0026#34;Weather\u0026#34;) (\u0026#34;*\u0026#34; all-the-icons-insert \u0026#34;All\u0026#34;))))) Key 効果 a all-the-icons で追加されてるアイコンを検索して挿入 f ファイルアイコンを検索して挿入 F FontAwesome アイコンを検索して挿入 m Material アイコンを検索して挿入 o Octicon のアイコンを検索して挿入 w 天気アイコンを検索して挿入 * 全てのアイコンを検索して挿入 フォントのインストールコマンドもここに収めてしまうのが良さそうな気がする\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/auth-source/",
	"title": "auth-source",
	"tags": [],
	"description": "",
	"content": "概要 auth-source は Emacs でパスワードのような秘匿情報を扱うための仕組み。 Emacs の各パッケージが認証情報を要求する時にこいつ経由で取得できるようにしておくと秘匿もできて便利っぽい。\nパスワードの保存先はデフォルトだと (\u0026quot;~/.authinfo\u0026quot; \u0026quot;~/.authinfo.gpg\u0026quot; \u0026quot;~/.netrc\u0026quot;) となっている。\n拡張子が gpg だと EagyPG Assistant で保存時に暗号化されるので便利。\nファイル指定 自分は Emacs でしか使わないであろう情報ということで /.emacs.d/.authinfo.gpg を指定している。\n(custom-set-variables \u0026#39;(auth-sources (quote (\u0026#34;~/.emacs.d/.authinfo.gpg\u0026#34;)))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/auto-format/",
	"title": "auto-format",
	"tags": [],
	"description": "",
	"content": "概要 保存時に自動で整形してくれるように fork した auto-fix.el を使っている。\nこれを入れて各 major-mode で設定をするとファイル保存時に自動で整形してくれて便利だったりする\nインストール fork しているので自前で recipe も用意している\n(:name auto-fix :website \u0026#34;https://github.com/mugijiru/auto-fix.el\u0026#34; :description \u0026#34;Fix current buffer automatically\u0026#34; :type github :branch \u0026#34;accept-multiple-args\u0026#34; :pkgname \u0026#34;mugijiru/auto-fix.el\u0026#34;) これを以下のようにして el-get でインスコしている\n(el-get-bundle auto-fix) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/auto-insert/",
	"title": "auto-insert",
	"tags": [],
	"description": "",
	"content": "概要 auto-insert はファイルを新規作成した時にファイル名に応じたテンプレートを挿入する機能。\nEmacs が標準で持ってるライブラリなのでインストールは不要\n設定 Emacs の設定は .emacs.d の中に閉じ込めたいので auto-insert のテンプレートも ~/.emacs.d/insert に閉じ込める設定にしている。\n(custom-set-variables \u0026#39;(auto-insert-directory \u0026#34;~/.emacs.d/insert/\u0026#34;)) 有効化 あとは単に有効化している。\n(auto-insert-mode 1) 他の設定 ファイル名を正規表現でマッチさせてテンプレートが選択されるので各言語やフレームワーク毎に設定を入れることにしている。\n実際は今のところ inits/41-vue.el でのみ追加設定を入れている。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/auto-save/",
	"title": "auto-save",
	"tags": ["replacement"],
	"description": "",
	"content": "概要 編集中状態の自動保存や、編集前や保存直後の状態のバックアップに関する設定をここでは書いている。\nEmacs ではデフォルトでも編集中ファイルの自動保存や、編集前の状態の自動バックアップもしてくれるが開いているファイルとは違う場所に保存したりすることで、より便利になるのでいくつかの設定を入れている。\n設定 自動保存設定 デフォルトだと #hoge.txt# みたいなファイル名で作られる、自動保存に関する設定。\nまあこの自動保存されてやつを活用できてる気がしないのでこの自動保存自体不要な気はしているが、とりあえず場所を移動して邪魔にはならないようにはしている。\n自動保存のタイミング 自動保存のタイミングは\nauto-save-timeout auto-save-interval で制御されている。\nまず auto-save-timeout で設定した秒数が経過すると再度自動保存が実行される。\nこれがデフォルトだと 30 秒なのだが、ちょっと長いのでその半分の 15 秒で保存されるように設定を変更している。\n(setq auto-save-timeout 15) また auto-save-interval で設定した回数のキーイベントが発生すると再度自動保存を実行する。\nこれもデフォルトだと 300 と結構なキーを叩く必要があるので 60 回としている。\n(setq auto-save-interval 60) 自動保存先を変更する 自動保存はそのままだと弄ってるファイルの場所に作られる。が、これは以下のようにすると ~/.emacs.d/backup/ 一応変更可能。\n(setq auto-save-file-name-transforms \u0026#39;((\u0026#34;.*\u0026#34; \u0026#34;~/.emacs.d/backup/\u0026#34; t))) ただ、デフォルト値が\n((\u0026#34;\\\\`/[^/]*:\\\\([^/]*/\\\\)*\\\\([^/]*\\\\)\\\\\u0026#39;\u0026#34; \u0026#34;/tmp/\\\\2\u0026#34; t)) なので .* にしているのは乱暴そうな気がしている。\nというわけで https://masutaka.net/chalow/2014-05-11-1.html に書かれているのを真似して\n((\u0026#34;~/\\\\([^/]*/\\\\)*\\\\([^/]*\\\\)$\u0026#34; \u0026#34;~/.emacs.d/backup/\\\\2\u0026#34; t)) とでもした方が良いかもしれない。\nバックアップファイル 自動保存とは別に、ファイルを開いた時点のバージョンや保存した時点のバージョンを取っておいてくれる自動バックアップ機能もあるのでその設定も弄っている。\nバックアップ先のフォルダ指定 デフォルトでは編集しているファイルと同じフォルダにバックアップファイルを作成するようになっている。\nだけど、こいつが結構邪魔なのでバックアップファイルは ~/.emacs.d/backup/ に全部保存するようにしている。\nまた、普段 tramp は使っていないが何かの拍子で使った時にバックアップが取られると邪魔そうなのでそれは保存しないようにしている。\n(setq backup-directory-alist \u0026#39;((\u0026#34;.*\u0026#34; . \u0026#34;~/.emacs.d/backup\u0026#34;) (,tramp-file-name-regexp . nil))) バージョン管理 バックアップにはバージョン管理機能もある。が、標準では無効化されている。\nとりあえず古いバージョンを引っ張り出せると便利かもと思って有効化している。\n(setq version-control t) が、実際それを使ったことはない。。。\nまた、古過ぎるバックアップファイルは要らないので、自動的に消されるように設定している。\n(setq delete-old-versions t) その他 Emacs の自動保存などについては http://yohshiy.blog.fc2.com/blog-entry-319.html によくまとめられているので、いずれその内容を設定に反映させたい。\nまた super-save というやつを使って実ファイルに自動保存したりしたらこれも不要になると思われる。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/avy/",
	"title": "avy",
	"tags": [],
	"description": "",
	"content": "概要 avy は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。 Vimium の f とかに似てる。\nインストール el-get で普通にインストールしている\n(el-get-bundle avy) 設定 文字の上に重なると元の文字列がよくわからなくなるので、移動先の文字の前に表示するようにしている\n(setq avy-style \u0026#39;pre) キーバインド グローバルなキーバインドを汚染したくなかったのでひとまず Hydra を定義している。\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define avy-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;avy\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Char\u0026#34; ((\u0026#34;c\u0026#34; avy-goto-char \u0026#34;Char\u0026#34;) (\u0026#34;C\u0026#34; avy-goto-char-2 \u0026#34;Char 2\u0026#34;) (\u0026#34;x\u0026#34; avy-goto-char-timer \u0026#34;Char Timer\u0026#34;)) \u0026#34;Word\u0026#34; ((\u0026#34;w\u0026#34; avy-goto-word-1 \u0026#34;Word\u0026#34;) (\u0026#34;W\u0026#34; avy-goto-word-0 \u0026#34;Word 0\u0026#34;)) \u0026#34;Line\u0026#34; ((\u0026#34;l\u0026#34; avy-goto-line \u0026#34;Line\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;r\u0026#34; avy-resume \u0026#34;Resume\u0026#34;))))) Key 効果 c 1文字からの絞り込み C 2文字から絞り込み x 任意の文字列からの絞り込み w 1文字絞り込んで単語先頭に移動 W 絞り込みなしの単語移動 l 列移動 r 繰り返し同じコマンドを実行 "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/browse-at-remote/",
	"title": "browse-at-remote",
	"tags": [],
	"description": "",
	"content": "概要 browse-at-remote は Emacs で見ているファイルについて GitHub や GitLab などのサービス上での該当ブランチ、該当ファイル、該当行を開いてくれる便利なやつ。\n業務だとレビュー中に「ここにこういう関数あるよ」みたいに示すことがあるけどその時に Emacs 内で関数を探して browse-at-remote で GitHub 上の位置を開くことでそこへのリンクを拾いやすく便利。\nインストール いつも透り el-get で入れている。\n(el-get-bundle browse-at-remote) 使い方 ブラウザで見たい行の上で M-x browse-at-remote を実行する。\nまたは Region を選択している状態で実行すると、その範囲を選択している状態で開いてくれる。便利。\nその他 Hydra でいつでも使えるようにキーバインドを割り当てている。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/color-theme-molokai/",
	"title": "color-theme-molokai",
	"tags": [],
	"description": "",
	"content": "概要 color-theme-molokai は多分 vim の molokai をベースにしたテーマ。更に元はどうも TextMate っぽい。\nダークグレイ背景をベースにしたテーマでもう何年もこのテーマを使っている。\nインストール el-get のレシピを自前で用意している\n(:name color-theme-molokai :type github :description \u0026#34;A pretty color theme.\u0026#34; :pkgname \u0026#34;alloy-d/color-theme-molokai\u0026#34;) そして el-get で入れている。\n(el-get-bundle color-theme-molokai) テーマへの PATH を通す インストールしただけでは custom-theme-load-path には追加されないので自分で add-to-list を使って PATH を通している。\n(add-to-list \u0026#39;custom-theme-load-path (expand-file-name \u0026#34;~/.emacs.d/el-get/color-theme-molokai\u0026#34;)) テーマの読み込み 最後に load-theme で molokai を読み込んでいる。\n(load-theme \u0026#39;molokai t) その他 もう長年これを使っているが、近年ではもっと良いテーマも出ているかもしれないのでそのうち乗り換えるかも。\nなんだけど、テーマ乗り換えるのちょっとだるいのよね〜。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/company-mode/",
	"title": "company-mode",
	"tags": [],
	"description": "",
	"content": "概要 company-mode は Emacs での補完機能を提供してくれるパッケージです。プラグイン式に拡張しやすいのが特徴っぽい。\nインストール いつも透り el-get から入れている\n(el-get-bundle company-mode) 設定 ほとんど設定は入れていない。有効な時に C-s を入力すると検索ができる程度。\nというのも最近の更新で、デフォルトが結構好みのキーバインドになったのでキーバインドはこだわる必要がなくなったのと、ついでに色もそこで好みな感じになってくれた。\nというわけで設定は以下のようにとてもシンプル。\n(with-eval-after-load \u0026#39;company ;; active (define-key company-active-map (kbd \u0026#34;C-s\u0026#34;) \u0026#39;company-search-candidates)) それと最近追加された company-show-quick-access を有効にしている。\n(custom-set-variables \u0026#39;(company-show-quick-access t)) これを有効にしていると補完候補の末尾に quick access key が表示されて例えば4行目なら 4 とか表示されるのでそこで M-4 とか入力すると4行目が選択されて便利\ncompany-quickhelp company-quickhelp は候補の補足情報が見れるようにするパッケージ。それを入れて、文字色とかぶらないように背景色を設定している。\n(el-get-bundle company-quickhelp) (custom-set-variables \u0026#39;(company-quickhelp-color-background \u0026#34;#323445\u0026#34;)) (with-eval-after-load \u0026#39;pos-tip (company-quickhelp-mode 1)) なおレシピは公式ではなかったので自前で用意している\n(:name company-quickhelp :description \u0026#34;Adds documentation popup to completion candidates\u0026#34; :type github :pkgname \u0026#34;company-mode/company-quickhelp\u0026#34;) company-posframe company-posframe は company-mode の表示に posframe を使うやつ。\n公式 README によると速度的にはまあ十分って感じなので速くはないのかなと。ただ CJK languages と相性は良いっぽい。ってことでとりあえず入れてみている\n(el-get-bundle company-posframe) (company-posframe-mode 1) その他 グローバルでは有効にしていなくて各モードで有効にするような hook を入れている。\nグローバルで有効でもいい気がしている。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/copilot/",
	"title": "copilot",
	"tags": [],
	"description": "",
	"content": "概要 Copilot.el は GitHub Copilot を Emacs で使えるようにするパッケージ。これ自体は非公式なプラグインで、動かすために Vim で動く公式プラグインのバイナリを利用して動いている\nインストール 最近出て来たパッケージなので el-get には登録されていない。というわけでとりあえず自前でレシピを用意している\n(:name copilot :website \u0026#34;https://github.com/copilot-emacs/copilot.el\u0026#34; :description \u0026#34;An Emacs plugin for GitHub Copilot.\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;copilot-emacs/copilot.el\u0026#34; :depends (s dash editorconfig jsonrpc)) 依存している editorconig も自前でレシピを用意している\n(:name editorconfig :website \u0026#34;https://github.com/editorconfig/editorconfig-emacs\u0026#34; :description \u0026#34;An EditorConfig plugin for Emacs.\u0026#34; :type github :branch \u0026#34;master\u0026#34; :pkgname \u0026#34;editorconfig/editorconfig-emacs\u0026#34;) そして el-get-bundle でインストール\n(el-get-bundle copilot) 設定 とりあえずプログラミング系の mode で有効になるようにしていた。けど今はちょっと無効にしている\n;; (add-hook \u0026#39;prog-mode-hook \u0026#39;copilot-mode) また、そのままだと enh-ruby-mode では有効にならないので copilot-major-mode-alist に突っ込んでいる。なおこの設定は 公式の README にも書かれている\n(with-eval-after-load \u0026#39;copilot (add-to-list \u0026#39;copilot-major-mode-alist \u0026#39;(\u0026#34;enh-ruby\u0026#34; . \u0026#34;ruby\u0026#34;))) あと何故か忘れたけど inline preview を無効にするような設定を入れている\n(with-eval-after-load \u0026#39;company ;; disable inline previews (delq \u0026#39;company-preview-if-just-one-frontend company-frontends)) キーバインド タブで補完ができるように設定している\n(with-eval-after-load \u0026#39;copilot (define-key copilot-completion-map (kbd \u0026#34;\u0026lt;tab\u0026gt;\u0026#34;) \u0026#39;copilot-accept-completion) (define-key copilot-completion-map (kbd \u0026#34;TAB\u0026#34;) \u0026#39;copilot-accept-completion)) warning 非表示 大きいファイルが開かれると\nWarning (copilot): .loaddefs.el size exceeds \u0026#39;copilot-max-char\u0026#39; (100000), copilot completions may not work とか出るけど、そんなもんは分かってるので warning が出ないように黙らせている\n(setq warning-suppress-log-types \u0026#39;((copilot copilot-exceeds-max-char))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/custom-file/",
	"title": "custom-file",
	"tags": [],
	"description": "",
	"content": "概要 Emacs では customize 機能などで設定したファイルを標準だと init.el の末尾に追記したりするが自動吐き出しされるものがあるとバージョン管理が難しくなるので別ファイルに出力するようにするなどの調整をしている。\n出力先の設定 .emacs.d の中に閉じ込めておく方が管理が楽なので出力先として ~/.emacs.d/custom.el を指定している。\n(setq custom-file (expand-file-name \u0026#34;~/.emacs.d/custom.el\u0026#34;)) カスタム設定の読み込み 起動時に、設定が入っているファイルが読み込まれないと保存した設定が有効にならないので load を使って読んでいる。\n(load custom-file) その他 カスタムファイルは終盤で読み込む方がいいかと思って init-loader では 99 という最後の方で読まれる番号を振っている。\nこのあたりの設定を個別のパッケージの設定の方に移動したらこのファイルは空にできるんじゃないかなとも思っているが、それはゆっくり対応していくつもり\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/dashboard/",
	"title": "dashboard",
	"tags": [],
	"description": "",
	"content": "概要 emacs-dashboard は Emacs の起動時に色々な情報を表示してくれるパッケージ。\nインストール el-get のレシピは自前で用意している\n(:name dashboard :type github :description \u0026#34;A startup screen extracted from Spacemacs\u0026#34; :pkgname \u0026#34;emacs-dashboard/emacs-dashboard\u0026#34; :depends (page-break-lines) :minimum-emacs-version (25 3)) そして el-get-bundle で入れている\n(el-get-bundle dashboard) 表示するアイコンをロゴに変更 ロゴ、画像にした方がカッコいいよねってことで logo に変更している\n(setq dashboard-startup-banner \u0026#39;logo) なお CUI で起動すると自動でテキストでの表示になる\n表示する情報の設定 dashboard-items を弄ることで表示する情報を設定している\n(setq dashboard-items \u0026#39;((recents . 5) ;; (bookmarks . 5) ;; bookmarks は使ってない (projects . 5) (agenda . 5) ;; (registers . 5) ;; registers は使ってない )) Emacs の bookmarks と register は使ってない(使えてない)のでコメントアウトしている。\nあとは最近開いたファイルとプロジェクトとagendaを表示するようにしているがイマイチ活用できてないので色々設定を詰める必要がありそう\n各セクションのタイトル部の先頭にアイコンを表示 これは見た目をちょっとだけカッコよくするために all-the-icons で装飾するための設定\n(setq dashboard-set-heading-icons t) 各ファイルの先頭にアイコンを表示 これも見た目をちょっとだエカッコよくするために all-the-icons で装飾するための設定。だけどファイルの種類がアイコンでわかるので便利。\n(setq dashboard-set-file-icons t) 最後に設定を反映 多分設定を反映するための関数だと思ってる。\n(dashboard-setup-startup-hook) その他 agenda などは表示する内容を絞ったりした方が dashboard として使い勝手が良さそう。今日の会議何があるとかが出ると便利かもね。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/ddskk/",
	"title": "ddskk",
	"tags": [],
	"description": "",
	"content": "概要 ddskk は Emacs Lisp 版の SKK 実装。\n一般的な日本語変換ソフトだと文法を自動で認識して変換をしてくれるけど SKK ではその自動認識がおかしくておかしな変換になるところを、単語の区切りなんかを一切判定せずに人間がそれを教えてあげることで、そういう自動的に変な挙動をしてしまう煩わしさから開放されるようになっている。\nインストール いつも通り el-get で入れている。最近は最新版が GitHub で更新されているのでそちらから引っ張られてくる。\n(el-get-bundle ddskk) 常時有効化 find-file-hooks で有効化することでファイルを開いた時には常に skk が使える状態にしている。また skk-latin-mode にしておくことで、基本は英語入力ですぐに日本語入力に切り替えられる状態にしている。\n(defun my/always-enable-skk-latin-mode-hook () (skk-latin-mode 1)) (add-hook \u0026#39;find-file-hooks \u0026#39;my/always-enable-skk-latin-mode-hook) hook の設定 ddskk が呼び出された時に色々設定されるようにしている。\nもしかしたら customize-variable とかあるかもしれないので今度見直した方が良さそう。\n(add-hook \u0026#39;skk-load-hook (lambda () ;; コード中では自動的に英字にする。 (require \u0026#39;context-skk) (setq skk-comp-mode t) ;; 動的自動補完 (setq skk-auto-insert-paren t) (setq skk-delete-implies-kakutei nil) (setq skk-sticky-key \u0026#34;;\u0026#34;) (setq skk-henkan-strict-okuri-precedence t) (setq skk-show-annotation t) ;; 単語の意味をアノテーションとして表示。例) いぜん /以前;previous/依然;still/ (setq skk-compare-jisyo-size-when-saving nil) (setq skk-extra-jisyo-file-list `(,(expand-file-name \u0026#34;~/.config/ibus-skk/user.dict\u0026#34;) \u0026#34;/usr/share/skk/SKK-JISYO.propernoun\u0026#34; \u0026#34;/usr/share/skk/SKK-JISYO.lisp\u0026#34;)) (setq skk-tooltip-parameters \u0026#39;((background-color . \u0026#34;#323445\u0026#34;))) ;; ;; 半角で入力したい文字 ;; (setq skk-rom-kana-rule-list ;; (nconc skk-rom-kana-rule-list ;; \u0026#39;((\u0026#34;;\u0026#34; nil nil) ;; (\u0026#34;:\u0026#34; nil nil) ;; (\u0026#34;?\u0026#34; nil nil) ;; (\u0026#34;!\u0026#34; nil nil)))) )) skk-comp-mode 自動補完関係らしいが、ググっても出て来ないし死んだ設定かもしれない skk-auto-insert-paren カッコを入力するとコッカも入れてくれる便利機能の切替 skk-delete-implies-kakutei nil にすると▼モードで \u0026lt;BS\u0026gt; を押した時 に一つ前の候補を表示するようになる skk-sticky-key 設定すると、その指定したキーを押した時に変換開始状態などにする Sticky Shift を提供する skk-henkan-strict-okuri-precedence 正しい送り仮名の変換が優先的に表示されるようにする設定 skk-show-annotation 単語の意味をアノテーションとして表示する設定 skk-rom-kana-rules-list キー入力時の挙動を指定する。とりあえず自分は : とかが全角になるのが嫌なので半角になるようにしている skk-compare-jisyo-size-when-saving これを nil にすることで辞書保存時に辞書サイズが大きいことを確認させないようにしている skk-extra-jisyo-file-list 追加の辞書を設定している。ibus-skk の辞書を入れることで同期したり。 skk-tooltip-parameters ツールチップの背景色を変えることで annotation を見れるようにしている L 辞書を使うようにする improvement Mac では AquaSKK の L 辞書を、 Linux では /usr/share/skk/SKK-JISYO.L を読むようにしている。\n(let ((l-dict (if (eq window-system \u0026#39;ns) (expand-file-name \u0026#34;~/Library/Application Support/AquaSKK/SKK-JISYO.L\u0026#34;) \u0026#34;/usr/share/skk/SKK-JISYO.L\u0026#34;))) (if (file-exists-p l-dict) (setq skk-large-jisyo l-dict))) WSL で動かしている Emacs では CurvusSKK の辞書を見るように設定した方が良さそうな気もするけど /usr/share/skk/SKK-JISYO.L にもあるのでひとまずこれにしておけば良さそう\nddskk-posframe ddskk-posframe は ddskk ツールチップを posframe で表示してくれるやつ。便利。\nhttps://emacs-jp.github.io/packages/ddskk-posframe に作った本人が解説記事を日本語で載せてるので詳細はそっちを見てもらう方が早い。\nとりあえず以下でインストール、有効化している。\n(el-get-bundle ddskk-posframe.el) (ddskk-posframe-mode 1) なお el-get.lock を使ったバージョン更新確認のためにレシピも必要だったので登録している\n(:name ddskk-posframe.el :website \u0026#34;https://github.com/conao3/ddskk-posframe.el\u0026#34; :description \u0026#34;ddskk-posframe.el provides Henkan tooltip for ddskk via posframe.\u0026#34; :type github :pkgname \u0026#34;conao3/ddskk-posframe.el\u0026#34;) その他 漢字の変換すらも機械任せではなく自分で決めるみたいな漢字直接入力という方式もあり、 SKK とそれを組み合わせると入力キーを覚えている漢字は漢直で入力しそうでない漢字は SKK で入力する、といった使い分けができるらしい。\n特に同音意義語が多い場合に便利そう。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/deprecated/",
	"title": "Deprecated",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/docker/",
	"title": "Docker",
	"tags": [],
	"description": "",
	"content": "概要 Dockerfile を書いたりするための設定。ちゃんと設定したら Emacs から Docker の操作もできるようだけどそこまでは対応してない\ndockerfile-mode インストール こちらは el-get にレシピが登録されているので単純に el-get-bundle でインストールしている。\n(el-get-bundle dockerfile-mode) カスタマイズ とりあえずインデントはスペース 2 つで普段書いているのでそれに合わせてカスタム変数を指定している。\n(custom-set-variables \u0026#39;(dockerfile-indent-offset 2)) hook lsp-mode では Dockerfile もサポートしている ので\n$ npm install -g dockerfile-language-server-nodejs で LSP サーバを入れた上で dockerfile-mode-hook で lsp を起動させるようにしている。\nあとついでに display-line-numbers-mode も有効にしている。\n(defun my/dockerfile-mode-hook () (display-line-numbers-mode t) (lsp)) (add-hook \u0026#39;dockerfile-mode-hook \u0026#39;my/dockerfile-mode-hook) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/dumb-jump/",
	"title": "dumb-jump",
	"tags": [],
	"description": "",
	"content": "概要 dumb-jump は関数とかの定義されてる場所にお手軽にジャンプできるようにするパッケージ。めっちゃ色々な言語をサポートしている。\nインストール いつも通り el-get でインストールしている。\n(el-get-bundle dumb-jump) 設定 デフォルトプロジェクトの変更 デフォルトだと ~/ がデフォルトプロジェクトらしいがそんなに上の階層から調べられてもしょうがない気がするのでソースコードを置いているフォルダを指定している。\n(setq dumb-jump-default-project \u0026#34;~/projects\u0026#34;) 複数マッチした時に使う絞り込み 最近はできるだけ ivy を使うようにしているので dumb-jump でも ivy を使うように指定している。\n(setq dumb-jump-selector \u0026#39;ivy) キーバインド README に書いている hydra の設定をほぼパクってるけど pretty-hydra を使ってキーを定義している\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define dumb-jump-pretty-hydra (:foreign-keys warn :title \u0026#34;Dumb jump\u0026#34; :quit-key \u0026#34;q\u0026#34; :color blue :separator \u0026#34;-\u0026#34;) (\u0026#34;Go\u0026#34; ((\u0026#34;j\u0026#34; dumb-jump-go \u0026#34;Jump\u0026#34;) (\u0026#34;o\u0026#34; dumb-jump-go-other-window \u0026#34;Other window\u0026#34;)) \u0026#34;External\u0026#34; ((\u0026#34;e\u0026#34; dumb-jump-go-prefer-external \u0026#34;Go external\u0026#34;) (\u0026#34;x\u0026#34; dumb-jump-go-prefer-external-other-window \u0026#34;Go external other window\u0026#34;)) \u0026#34;Lock\u0026#34; ((\u0026#34;l\u0026#34; dumb-jump-quick-look \u0026#34;Quick look\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;b\u0026#34; dumb-jump-back \u0026#34;Back\u0026#34;))))) Key 効果 j 定義場所にジャンプ o 定義場所を別 window で開く e 定義場所にジャンプ。ただし同じファイルより外部ファイルとのマッチを優先 x 定義場所を別 window で開く。ただし同じファイルより外部ファイルとのマッチを優先 l クイックルック。定義をツールチップ表示する b 最後にジャンプされた場所に戻る。今は既に obsolute 扱い "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/emacs-kibela/",
	"title": "emacs-kibela",
	"tags": [],
	"description": "",
	"content": "概要 emacs-kibela は Emacs で Kibela を操作するための自作のパッケージ。あまり機能は実装されていないけど、テンプレートから記事を書いたりする程度のことはできる\nインストール MELPA には登録してないし el-get にもレシピを登録していないので自前で el-get の recipe を用意している\n(:name emacs-kibela :website \u0026#34;https://github.com/mugijiru/emacs-kibela\u0026#34; :description \u0026#34;Kibela client.\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;mugijiru/emacs-kibela\u0026#34; :depends (graphql request markdown-mode)) そして el-get-bundle でインストールしている\n(el-get-bundle emacs-kibela) 設定 .authinfo.gpg に認証情報を突っ込んでいるのでそこから認証情報を拾って来て set している\n(custom-set-variables \u0026#39;(kibela-auth-list `((\u0026#34;Work\u0026#34; ,(plist-get (nth 0 (auth-source-search :host \u0026#34;emacs-kibela-work\u0026#34;)) :team) ,(funcall (plist-get (nth 0 (auth-source-search :host \u0026#34;emacs-kibela-work\u0026#34; :max 1)) :secret))) (\u0026#34;Private\u0026#34; ,(plist-get (nth 0 (auth-source-search :host \u0026#34;emacs-kibela-private\u0026#34;)) :team) ,(funcall (plist-get (nth 0 (auth-source-search :host \u0026#34;emacs-kibela-private\u0026#34; :max 1)) :secret)))))) 自前の関数 ivy-kibela と連携して、最近投稿された記事を Emacs の中で開くためのコマンドを用意している。\nもしかしたら emacs-kibela か ivy-kibela のどちらかで featurep を使って有効無効を切り分けて実装すべきかも\n(defun my/kibela-show-recent-note () \u0026#34;最近投稿された記事を見るためのコマンド ivy-kibela-recent で最近投稿された記事を拾って kibela-note-show でバッファを開く\u0026#34; (interactive) (ivy-kibela-recent (lambda (title) (let ((id (get-text-property 0 \u0026#39;id title))) (if id (kibela-note-show id)))))) キーバインド 各コマンドは Hydra で起動するように設定している。しれっと ivy-kibela のコマンドも混ぜちゃってるけど、使う分にはこの方がやりやすい。\n(pretty-hydra-define kibela-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;Kibela\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;ivy\u0026#34; ((\u0026#34;r\u0026#34; ivy-kibela-recent \u0026#34;Recent\u0026#34;) (\u0026#34;R\u0026#34; ivy-kibela-recent-browsing-notes \u0026#34;Recent brwosing notes\u0026#34;) (\u0026#34;S\u0026#34; ivy-kibela-search \u0026#34;Search\u0026#34;)) \u0026#34;Group\u0026#34; ((\u0026#34;g\u0026#34; kibela-group-notes \u0026#34;notes\u0026#34;)) \u0026#34;Note\u0026#34; ((\u0026#34;n\u0026#34; kibela-note-new \u0026#34;New\u0026#34;) (\u0026#34;s\u0026#34; my/kibela-show-recent-note \u0026#34;Show\u0026#34;) (\u0026#34;t\u0026#34; kibela-note-new-from-template \u0026#34;From template\u0026#34;)) \u0026#34;Team\u0026#34; ((\u0026#34;x\u0026#34; kibela-switch-team \u0026#34;Swtich\u0026#34;)))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/emacs-lisp/",
	"title": "emacs-lisp",
	"tags": [],
	"description": "",
	"content": "概要 Emacs Lisp を書くための設定。まあそんなにしっかり書いてないので、あんまり設定は入ってない\nHook Hook 用の関数を定義してその中に色々書いている。\nとりあえず行数表示が欲しいので display-line-numbers-mode を有効化 当然補完もしたいので company-mode を有効にしている カッコの対応などもいい感じに動いて欲しいので smartparens-mode とその strict-mode を有効にしている (defun my/emacs-lisp-mode-hook () (display-line-numbers-mode 1) (origami-mode 1) (company-mode 1) (smartparens-mode 1) (turn-on-smartparens-strict-mode)) そんで最後にその関数を hook に突っ込んでる。\n(add-hook \u0026#39;emacs-lisp-mode-hook \u0026#39;my/emacs-lisp-mode-hook) アイコン挿入コマンドの用意 時々 UI 設定目的で絵文字を使うことがあるので挿入できるコマンドを用意している。最近使った記憶ないけど。\n(defun my/insert-all-the-icons-code (family) (interactive) (let* ((candidates (all-the-icons--read-candidates-for-family family)) (prompt (format \u0026#34;%s Icon: \u0026#34; (funcall (all-the-icons--family-name family)))) (selection (completing-read prompt candidates nil t))) (insert \u0026#34;(all-the-icons-\u0026#34; (symbol-name family) \u0026#34; \\\u0026#34;\u0026#34; selection \u0026#34;\\\u0026#34;)\u0026#34;))) キーバインド emacs-lisp-mode 用に major-mode-hydra を設定している。けどそんなにしっかり Emacs Lisp を書いてるわけではないのがバレバレな感じである。\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define emacs-lisp-mode (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-fileicon \u0026#34;elisp\u0026#34;) \u0026#34; Emacs Lisp\u0026#34;)) (\u0026#34;Describe\u0026#34; ((\u0026#34;F\u0026#34; counsel-describe-function \u0026#34;Function\u0026#34;) (\u0026#34;V\u0026#34; counsel-describe-variable \u0026#34;Variable\u0026#34;)) \u0026#34;Insert Icon Code\u0026#34; ((\u0026#34;@a\u0026#34; (my/insert-all-the-icons-code \u0026#39;alltheicon) \u0026#34;All the icons\u0026#34;) (\u0026#34;@f\u0026#34; (my/insert-all-the-icons-code \u0026#39;fileicon) \u0026#34;File icons\u0026#34;) (\u0026#34;@F\u0026#34; (my/insert-all-the-icons-code \u0026#39;faicon) \u0026#34;FontAwesome\u0026#34;) (\u0026#34;@m\u0026#34; (my/insert-all-the-icons-code \u0026#39;material) \u0026#34;Material\u0026#34;) (\u0026#34;@o\u0026#34; (my/insert-all-the-icons-code \u0026#39;octicon) \u0026#34;Octicon\u0026#34;) (\u0026#34;@w\u0026#34; (my/insert-all-the-icons-code \u0026#39;wicon) \u0026#34;Weather\u0026#34;))))) Key 効果 F 関数を調べる V 変数を調べる @a all-the-icon のアイコンを挿入 @f fileicon のアイコンを挿入 @F FontAwesome のアイコンを挿入 @m Material Icons のアイコンを挿入 @o Octicons のアイコンを挿入 @w 天気アイコンを挿入 "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/emacs-w3m/",
	"title": "emacs-w3m",
	"tags": [],
	"description": "",
	"content": "概要 w3m という和製のテキストブラウザを Emacs 上で使うためのパッケージ。つまり w3m 自体もインストールしておく必要がある。\nインストール emacs-w3m は el-get で入れられるので以下のようにして入れている\n(el-get-bundle emacs-w3m) 今はこれだけしか入れてない。昔の設定はどこかにいっちゃった……。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/ember-js/",
	"title": "Ember.js",
	"tags": [],
	"description": "",
	"content": "概要 Ember.js 用の Emacs の拡張としては ember-mode と handlebars-mode が存在する\nember-mode unused ember-mode は Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。実は麦汁さんは使えてない。\nインストールするだけではダメで、 ember-mode を明示的に起動しないといけない。\nそのためには dir-locals を使うとか projectile なんかがやってるようにフォルダ構成から判定させるみたいなことが必要そう。だるい。\nというわけで死蔵中。\nついでにいうとキーバインドもだるい系なので使う時は Hydra を用意した方が良さそう\nインストールは GitHub からできるが el-get.lock を用いたバージョン更新確認スクリプトのためレシピを追加している\n(:name madnificent/ember-mode :website \u0026#34;https://github.com/madnificent/ember-mode\u0026#34; :description \u0026#34;Ember-mode speeds up navigation in EmberJS projects.\u0026#34; :type github :pkgname \u0026#34;madnificent/ember-mode\u0026#34;) このレシピを用意した上で以下でインストール\n(el-get-bundle ember-mode) handlebars-mode improvement handlebars-mode は Ember.js のテンプレートエンジンとして採用されている Handlebars を書くためのモード。\nsyntax highlight と、いくつかの編集機能を備えている。が、今のところ麦汁さんは syntax highlight しか使えてない。\n編集コマンドは major-mode-hydra で使えるようにしてあげれば良さそう\n(el-get-bundle handlebars-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/emojify/",
	"title": "emojify",
	"tags": [],
	"description": "",
	"content": "概要 emojify は :smile: のような入力を笑顔の絵文字が表示されたりするようにするパッケージ。\n文書を書く時に emojify で絵文字に置き換わるような文字列を入れておくと文書が華やかになって良いぞ!\nインストール いつも通り el-get で入れている。何か依存でもあるのが別途 dash.el も読み込んでる。\n(el-get-bundle emojify) (el-get-bundle dash) dash.el は他でも使うので、ライブラリの読み込みのところで対応した方が良さそうだな。今度対応しよう。\n有効化 emojify がグローバルに有効になるようにしている。\nmode-line でも有効になるようにしているので mode-line のカスタマイズ時に emojify で装飾することもできる。今そんなことやってないけど。\n(global-emojify-mode 1) (global-emojify-mode-line-mode 1) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/es6/",
	"title": "es6",
	"tags": [],
	"description": "",
	"content": "概要 ES5 以前ではない JS を書くための設定。 es6 といいつつ ES2016(ES7) などもこの設定のまま書いている。\nsprockets-es6 を使って ES6 対応をしていた時に es6 という拡張子を使っていたのでこのファイル名になっている。\nインストール es6 はつまり JS なのでとりあえず el-get で js2-mode を入れている。\n(el-get-bundle js2-mode) Hook flycheck を有効にしてリアルタイムに文法チェックをしている また javascript-eslint を使いたいので他2つは disable にしている company-mode で補完できるようにしている smartparens-strict-mode でカッコなどの入力補助をしている インデントは空白2文字としている (defun my/js2-mode-hook () (flycheck-mode 1) (setq flycheck-disabled-checkers \u0026#39;(javascript-standard javascript-jshint)) (company-mode 1) (turn-on-smartparens-strict-mode) (setq js2-basic-offset 2)) という Hook 用関数を用意しておいて\n(add-hook \u0026#39;js2-mode-hook \u0026#39;my/js2-mode-hook) という感じで js2-mode-hook に追加している。\nLambda で一括でやる方法もあるけども、関数名つけて分離しておくと中身を簡単に入れ替えられて便利。\nes6 を js2-mode で扱うようにする (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.es6$\u0026#34; . js2-mode)) 他に気になるツール xref-js2 https://github.com/js-emacs/xref-js2\nコード間の移動が楽になるかもしれない。けど dumb-jump があるから別に要らない気もする\njs2-refactor https://github.com/js-emacs/js2-refactor.el\nリファクタリングツール。キーバインドは覚えるのつらそうだから Hydra を用意する必要がありそう。\nskewer-mode https://github.com/skeeto/skewer-mode\nWeb ブラウザと連携して JS の評価をしたりとかしてくれたり一部の変更を反映してくれたりするらしい。\n保存したら自動リロードされる環境はともかくそうじゃない環境だと楽かもしねあい。\njs-import https://github.com/jakoblind/js-import\nimport を書くのを楽にしてくれるっぽい。\nindium https://github.com/NicolasPetton/indium\nNode.js と連携してステップ実行とかができるようになるらしい。便利そう。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/esa/",
	"title": "esa.el",
	"tags": [],
	"description": "",
	"content": "概要 esa.el は esa.io と連携するためのパッケージ。大体直接 Web で書くので活用はできてない……\nインストール・設定 レシピは自前で用意している\n(:name esa :description \u0026#34;Interface to esa.io (\\( ⁰⊖⁰)/)\u0026#34; :type github :pkgname \u0026#34;nabinno/esa.el\u0026#34;) そして el-get で入れている。\n設定は別ファイルに分離している。authinfo に移動したい\n(el-get-bundle esa) (my/load-config \u0026#34;my-esa-config\u0026#34;) けど今は esa 使ってないのよね。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/exec-path/",
	"title": "exec-path",
	"tags": [],
	"description": "",
	"content": "概要 Emacs は通常最小限の環境変数しか利用しないようになっている。\nが、それだと普段使う上で「ああ、このコマンドが使えなくてもどかしい……!」と感じてしまう。\nそこで exec-path-from-shell というのを使って Emacs が見える PATH 環境変数をシェルが見てる PATH 環境変数と揃うようにしている。\nインストール いつも通り el-get からインストールしている\n(el-get-bundle exec-path-from-shell) 有効化 理由は忘れたが Mac の環境でのみ有効化している。その内 Linux 環境でも有効化を試みた方が良さそう\n(when (memq window-system \u0026#39;(mac ns)) (exec-path-from-shell-initialize)) なお、これでシェルと共通の環境変数が使われるようになるのは デフォルトでは PATH と MANPATH のみである\nその他 なぜか以下のようなコメントを書いていた。普段使っている zsh で持ってる PATH は使わないのだろうか? :thinking_face:\n;; for exec path ;; use .bashrc setted path "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/flycheck/",
	"title": "flycheck",
	"tags": [],
	"description": "",
	"content": "概要 flycheck はリアルタイムで文法チェックなんかをするのに便利なモード。 flymake よりモダンなやつだったんだけど最近は flymake に戻る人もいるっぽいのでどっちが良いかよくわかってない\nインストール flycheck と同時にカーソルのそばに pos-tip で通知内容を表示してくれる flycheck-pos-tip をインストールしている\n(el-get-bundle flycheck) (el-get-bundle flycheck-pos-tip) 設定 flycheck を読んだ後で flycheck-pos-tip-mode が有効になるようにしている。これは公式に書かれているやりかたに則っている https://github.com/flycheck/flycheck-pos-tip#installation\nまた web-mode はデフォルトでは flycheck が使えないので flycheck-add-mode を使って web-mode でも flycheck が使えるようにしている\n(with-eval-after-load \u0026#39;flycheck (flycheck-pos-tip-mode) (flycheck-add-mode \u0026#39;javascript-eslint \u0026#39;web-mode)) その他 flycheck-posframe flycheck-pos-tip は flycheck 公式のプラグインなので採用しているけど同じことを posframe でやってくれる flycheck-posframe に置き換えた方が見た目麗しくなりそうな気がしている。\n言語毎の設定 各言語向けの設定もあるけどそれは各言語の設定ファイル内に書いているのでここでは書いてない\nプログラミング関係の設定 \u0026gt; ruby とか プログラミング関係の設定 \u0026gt; scss とかに書いているはず\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/flyspell/",
	"title": "flyspell",
	"tags": [],
	"description": "",
	"content": "概要 flyspell はスペルチェックをしてくれるパッケージです。 Emacs 本体に組込まれているので、設定すれば素の Emacs でも使えます。\nhunspell 向けの設定 flyspell は外部のスペルチェックツールとやりとりをします。私は hunspell を使ってるので、それ向けに設定をしています。\n;; for hunspell (with-eval-after-load \u0026#34;ispell\u0026#34; (setenv \u0026#34;DICTIONARY\u0026#34; \u0026#34;en_US\u0026#34;) (add-to-list \u0026#39;ispell-skip-region-alist \u0026#39;(\u0026#34;[^\\000-\\377]+\u0026#34;))) どうせ英語のスペルしかチェックしないので DICTIONARY には en_US を設定しています。また、日英が混在している文書でもスペルチェックが動くように ispell-skip-region-alist を設定しています\nhttp://home.hatanaka.info/article/474728666.html を参考にしていますが、まあ多分 ASCII 以外をシカトしているのかなこれは\nincorrect-hook の定義 上の設定でも ASCII 以外を無視してそうだけどさらに flyspell-incorrect-hook で incorrect 判定するのを ASCII にのみ限定しています。\n;; Original: https://takaxp.github.io/init.html#orgdd65fc08 (defun my/flyspell-ignore-nonascii (beg end _info) \u0026#34;incorrect判定をASCIIに限定\u0026#34; (string-match \u0026#34;[^!-~]\u0026#34; (buffer-substring beg end))) (add-hook \u0026#39;flyspell-incorrect-hook #\u0026#39;my/flyspell-ignore-nonascii) これは https://takaxp.github.io/init.html#orgdd65fc08 にある設定を持って来ています\nその他 flyspell-prog-mode を使うと、文字列やコメントにのみ有効にできるようですがそのあたりはまだ試していません。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/font-config/",
	"title": "font-config",
	"tags": [],
	"description": "",
	"content": "概要 Emacs で利用するフォントの設定。それなりの設定をしないとガタついたりするので通常あまり手を入れないで済ませている。\n設定 Mac では 14, それ以外(Linux) では 18 を基準としている。\nMac と Linux で基準のサイズを変えているがなぜかこの方がガタガタもしないし大き過ぎもしないしでいい感じになる。\nといいつつ元々 Linux の方は WSL2 環境に合わせて 12 にしていたが Manjaro 環境に合わせて 18 に変更しているのでまたその内 WSL2 でも Manjaro でもどっちいい感じに使えるように調整するかもしれない\n(defun my/set-font-size (size) (let* ((asciifont \u0026#34;Ricty Diminished\u0026#34;) ; ASCII fonts (jpfont \u0026#34;Ricty Diminished\u0026#34;) ; Japanese fonts (h (* size 10)) (fontspec (font-spec :family asciifont)) (jp-fontspec (font-spec :family jpfont))) (set-face-attribute \u0026#39;default nil :family asciifont :height h) (set-fontset-font nil \u0026#39;japanese-jisx0213.2004-1 jp-fontspec) (set-fontset-font nil \u0026#39;japanese-jisx0213-2 jp-fontspec) (set-fontset-font nil \u0026#39;katakana-jisx0201 jp-fontspec) (set-fontset-font nil \u0026#39;(#x0080 . #x024F) fontspec) (set-fontset-font nil \u0026#39;(#x0370 . #x03FF) fontspec))) (if (or (eq window-system \u0026#39;ns) (eq window-system \u0026#39;mac)) (my/set-font-size 14) (my/set-font-size 18)) フォントの設定する処理は関数に切り出しているので全体的にフォントを大きくしたい時は\n(my/set-font-size 24) のようにさくっと変更できるようにしている\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/forge/",
	"title": "forge",
	"tags": [],
	"description": "",
	"content": "概要 forge は magit と github を連携させるやつ。一応入れているけど実は使えてないのであまりこの設定を呼んでも意味はなさそう\nインストール いつも通り el-get でインストールする。ただし依存関係で必要なので emacs-sqlite3-api も合わせて入れている\n(el-get-bundle emacs-sqlite3-api) (el-get-bundle forge) なお emacs-sqlite3-api はレシピを自前で用意している\n(:name emacs-sqlite3-api 3:website \u0026#34;https://github.com/pekingduck/emacs-sqlite3-api\u0026#34; :description \u0026#34;sqlite3 is a dynamic module for GNU Emacs 25+ that provides direct access to the core SQLite3 C API from Emacs Lisp.\u0026#34; :type github :branch \u0026#34;master\u0026#34; :pkgname \u0026#34;pekingduck/emacs-sqlite3-api\u0026#34;) 読み込み magit の拡張なので magit を読み込んで後に読み込まれるようにしている。依存で必要な sqlite3 も合わせて require している。\n(with-eval-after-load \u0026#39;magit (require \u0026#39;sqlite3) (require \u0026#39;forge)) flycheck の有効化 Pull Request を作る時に text-lint で指摘されたいのでそのタイミングで flycheck を有効化している\n(defun my/forge-post-mode-hook () (flycheck-mode 1)) (with-eval-after-load \u0026#39;forge (add-hook \u0026#39;forge-post-mode-hook \u0026#39;my/forge-post-mode-hook)) その他 リポジトリのコミット数が多いとまともに使えない感じだけどどうしたらいいの。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/frame-cmds/",
	"title": "frame-cmds",
	"tags": [],
	"description": "",
	"content": "概要 frame-cmds は Emacs のフレーム操作に関するコマンド集。上下左右に移動したり広げたりといったことができる。いや、他にもできそうなんだけど、私がそれを把握してない。\nインストール とりあえず自前でレシピを用意している\n(:name frame-cmds :website \u0026#34;https://github.com/emacsmirror/frame-cmds\u0026#34; :description \u0026#34;Frame and window commands (interactive functions).\u0026#34; :type github :depends (frame-fns) :pkgname \u0026#34;emacsmirror/frame-cmds\u0026#34;) また依存している frame-fns もレシピを用意している\n(:name frame-fns :website \u0026#34;https://github.com/emacsmirror/frame-fns\u0026#34; :description \u0026#34;Non-interactive frame and window functions.\u0026#34; :type github :pkgname \u0026#34;emacsmirror/frame-fns\u0026#34;) そして el-get-bundle でインストールしている\n(el-get-bundle frame-cmds) キーバインド 無論キーバインドは覚えられないので以下のように Hydra で定義している\n(pretty-hydra-define window-control-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;Window Control\u0026#34; :exit nil :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Move\u0026#34; ((\u0026#34;h\u0026#34; move-frame-left \u0026#34;Left\u0026#34;) (\u0026#34;j\u0026#34; move-frame-down \u0026#34;Down\u0026#34;) (\u0026#34;k\u0026#34; move-frame-up \u0026#34;Up\u0026#34;) (\u0026#34;l\u0026#34; move-frame-right \u0026#34;Right\u0026#34;)) \u0026#34;Resize\u0026#34; ((\u0026#34;H\u0026#34; shrink-frame-horizontally \u0026#34;H-\u0026#34;) (\u0026#34;J\u0026#34; enlarge-frame \u0026#34;V+\u0026#34;) (\u0026#34;K\u0026#34; shrink-frame \u0026#34;V-\u0026#34;) (\u0026#34;L\u0026#34; enlarge-frame-horizontally \u0026#34;H+\u0026#34;)))) Key 効果 h 左に移動 j 下に移動 k 上に移動 l 右いん移動 H 左右方向に縮める J 上下方向に広げる K 上下方向に縮める L 左右方向に広げる "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/fullscreen/",
	"title": "fullscreen",
	"tags": [],
	"description": "",
	"content": "概要 起動時にフルスクリーンにする設定はここにまとめている\nMac の設定 Mac の場合にフルスクリーンにする設定を入れていた。けど 2020-01-08 に yabai WM を導入したことにより起動時はフルスクリーンじゃない方がよくなったので以下の処理は今は使ってない。\n(if (or (eq window-system \u0026#39;ns) (eq window-system \u0026#39;mac)) (add-hook \u0026#39;window-setup-hook (lambda () (set-frame-parameter nil \u0026#39;fullscreen \u0026#39;fullboth)))) WSL の設定 X Window system の場合かつ WSLENV という環境変数が設定されている場合にはフルスクリーンにする。新しく Linux マシンを導入したらこれの影響を受けていたので後から WSLENV による判定を追加した次第。\n(if (and (eq window-system \u0026#39;x) (getenv \u0026#34;WSLENV\u0026#34;)) (add-hook \u0026#39;window-setup-hook (lambda () (set-frame-parameter nil \u0026#39;fullscreen \u0026#39;fullboth) (set-frame-position nil 0 0)))) 微妙に画面の下の方がちゃんとフルになってくれてないけどそこは今は我慢して使っている。ちなみにその病はどうやら WSLg になっても残りそう。 https://w.atwiki.jp/ntemacs/pages/69.html\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/git-gutter-fringe/",
	"title": "git-gutter-fringe",
	"tags": ["improvement"],
	"description": "",
	"content": "概要 git-gutter-fringe は git-gutter の派生版。最後のコミットからどの行を弄ったかを fringe 領域に表示してくれる。\n他にも hunk の操作をできる機能とかあるみたいだけどそのあたりは使ったことがない……。\n派生元の git-gutter は linum-mode と同じ領域を使って描画をしているようで併用ができなかったので git-gutter-fringe を利用している。\nが、Emacs 26 から display-line-numbers-mode が搭載されて linum-mode が不要になったので git-gutter に乗り換えても良さそう\nインストール いつも通り el-get でインストールしている\n(el-get-bundle git-gutter-fringe) 有効化 Git 管理しているやつは全部差分情報が表示されて欲しいのでグローバルマイナーモードを有効にしている。\n(global-git-gutter-mode t) その他 git-gutter ほどではないけど多少のカスタマイズはできるはずだがデフォルト設定で特に不満はないので何もしてない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/git-messenger/",
	"title": "git-messenger",
	"tags": [],
	"description": "",
	"content": "概要 git-messenger は指定した行のコミット時の情報を表示してくれるやつ簡単に最終コミットの情報を見るのに便利\nインストール git-messenger は el-get のレシピに登録されているのでそのまま el-get-bundle を使ってインストールできる\n(el-get-bundle git-messenger) 設定 デフォルトでは commit message だけを表示するがより詳細な情報を見たいので git-messenger:show-detail を t に設定してコミット日時や author も表示するようにしている\n(custom-set-variables \u0026#39;(git-messenger:show-detail t)) magit を利用しているので git-messenger:use-magit-popup も有効にしても良いかもしれない\nキーバインド 起動には pretty-hydra-usefull-commands で C を叩くと起動するようにしている。\n起動後は、デフォルトでキーバインドが定義されているので https://github.com/emacsorphanage/git-messenger#key-bindings の通りの操作ができる\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/gnuplot-mode/",
	"title": "gnuplot-mode",
	"tags": [],
	"description": "",
	"content": "概要 gnuplot-mode はグラフ作成ソフトである gnuplot を Emacs で使うためのパッケージ。 Syntax Highlight や 補完機能 などを提供する。\nまあほとんど使ってないんだけど。\nインストール レシピは自前で用意している\n(:name gnuplot-mode :description \u0026#34;Drive gnuplot from within emacs\u0026#34; :type github :pkgname \u0026#34;emacs-gnuplot/gnuplot\u0026#34; :branch \u0026#34;main\u0026#34; :build `((\u0026#34;make\u0026#34; ,(concat \u0026#34;EMACS=\u0026#34; el-get-emacs)))) そしていつも通り el-get で入れている\n(el-get-bundle gnuplot-mode) その他 org-mode から使ってた記憶があるのでそっちの方で何か設定があるかもしれない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/google-integration/",
	"title": "Google 連携",
	"tags": [],
	"description": "",
	"content": "概要 Google と連携するパッケージとして google-this と google-translate を入れているが、どっちも Google を使うので1つの Hydra にまとめていた方が扱いやすいと思って統合している\nキーバインド (with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define google-pretty-hydra (:foreign-keys warn :title \u0026#34;Google\u0026#34; :quit-key \u0026#34;q\u0026#34; :color blue :separator \u0026#34;-\u0026#34;) (\u0026#34;Current\u0026#34; ((\u0026#34;SPC\u0026#34; google-this-noconfirm \u0026#34;No Confirm\u0026#34;) (\u0026#34;RET\u0026#34; google-this \u0026#34;Auto\u0026#34;) (\u0026#34;w\u0026#34; google-this-word \u0026#34;Word\u0026#34;) (\u0026#34;l\u0026#34; google-this-line \u0026#34;Line\u0026#34;) (\u0026#34;s\u0026#34; google-this-symbol \u0026#34;Symbol\u0026#34;) (\u0026#34;r\u0026#34; google-this-region \u0026#34;Region\u0026#34;) (\u0026#34;e\u0026#34; google-this-error \u0026#34;Error\u0026#34;)) \u0026#34;Feeling Lucky\u0026#34; ((\u0026#34;L\u0026#34; google-this-lucky-search \u0026#34;Lucky\u0026#34;) (\u0026#34;i\u0026#34; google-this-lucky-and-insert-url \u0026#34;Insert URL\u0026#34;)) \u0026#34;Translate\u0026#34; ((\u0026#34;t\u0026#34; google-translate-at-point \u0026#34;EN =\u0026gt; JP\u0026#34;) (\u0026#34;T\u0026#34; google-translate-at-point-reverse \u0026#34;JP =\u0026gt; EN\u0026#34;)) \u0026#34;Tool\u0026#34; ((\u0026#34;W\u0026#34; google-this-forecast \u0026#34;Weather\u0026#34;))))) Key 効果 SPC 確認なしで検索 RET どの範囲の情報で検索するか自動判定して検索 w 近くの単語で検索 l その行の内容で検索。エラーの検索とかに良いかも s シンボルで検索。使うのは Emacs Lisp の関数調べる時ぐらいか? r リージョンで検索。まあリージョン選択してたら RET とかでいいんだけども e コンパイルバッファのエラーで検索するっぽい L 1件目を開く i 1件目の URL を挿入する t 英語→日本語翻訳 T 日本語→英語翻訳 w 天気を調べる "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/google-this/",
	"title": "google-this",
	"tags": [],
	"description": "",
	"content": "概要 google-this は Google 検索を Emacs の中から行えるやつ。\nインストール いつも通り el-get でインストール\n(el-get-bundle google-this) で、本来の使い方だとこのあとに\n(google-this-mode 1) とやって有効化することになるがそれをしても google-this のデフォルトキーバインドが設定されるぐらいで自分はそのデフォルトキーバインドを使う気がないので有効化はしてない。\nキーバインド キーバインドは Hydra で設定しているが、 google-translate と統合したので キーバインド \u0026gt; Google 連携 に記載している。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/google-translate/",
	"title": "google-translate",
	"tags": [],
	"description": "",
	"content": "概要 google-translate は Google 翻訳する機能を提供するパッケージ。\nインストール レシピは自前で用意している\n(:name google-translate :description \u0026#34;Emacs interface to Google Translate\u0026#34; :type github :pkgname \u0026#34;atykhonov/google-translate\u0026#34;) そして el-get でインストール\n(el-get-bundle google-translate) 関数のオーバーライド どうも最新版でも壊れっぱなしのようなので https://github.com/atykhonov/google-translate/issues/52#issuecomment-727920888 にあるように関数を上書きしている。\n(with-eval-after-load \u0026#39;google-translate-tk (defun google-translate--search-tkk () \u0026#34;Search TKK.\u0026#34; (list 430675 2721866130))) google-translate-tk に定義されていて、それが読まれた後に上書きしないといけないので with-eval-after-load を使っている。\ndefault-ui の読み込み Google Translate は UI を defauult と smooth のどちらかから選べるようになっている。\ndefault だと\ngoogle-translate-default-source-language google-translate-default-target-language を設定しておいて\nM-x google-translate-at-point source → target の翻訳 M-x google-translate-at-point-reverse target → source の翻訳 という使い方をする。\nsmooth だと翻訳の source, target を複数設定して多言語対応ができるが、英語以外を翻訳することがないので smooth でなくていいかという感じで default を採用している。\n(with-eval-after-load \u0026#39;popup (require \u0026#39;google-translate-default-ui)) popup.el に依存しているのでそれが読まれた後に require しないといけなかった。というわけで with-eval-after-load で対応している。\nカスタム変数の設定 上述の通り default UI を使うことにしたのでその変数をいくらか設定している。\n(custom-set-variables \u0026#39;(google-translate-default-source-language \u0026#34;en\u0026#34;) \u0026#39;(google-translate-default-target-language \u0026#34;ja\u0026#34;) \u0026#39;(google-translate-translation-to-kill-ring t) \u0026#39;(google-translate-output-destination \u0026#39;popup)) google-translate-default-source-language 翻訳元言語 google-translate-default-target-language 翻訳先言語 google-translate-translation-to-kill-ring 翻訳後に RET などで翻訳結果を kill-ring にコピー google-translate-output-destination 翻訳結果の表示 日本語を母国語としていて英語はからきしという人間なので当然英日変換されるように設定していてあとは変換結果の表示方法は popup でツールチップ表示するようにしている。\nツールチップの表示だけでなくそれを文書に入れたい時はツールチップが出ている時に Enter でも叩けば kill-ring に入るのでそこから yank している\nキーバインド google-this と同じく Google 連係機能なので キーバインド \u0026gt; Google 連携 でまとめて Hydra を定義している\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/graphql/",
	"title": "GraphQL",
	"tags": [],
	"description": "",
	"content": "概要 GraphQL は API 向けのクエリ言語でよく対比される REST と違いクライアント側から必要なデータ属性を指定できたりするやつ\ngraphql-mode *.graphql ファイルを編集する時のメジャーモード\nインストール こいつは el-get にレシピが用意されてないので自前で用意している\n(:name graphql-mode :description \u0026#34;An emacs mode to edit GraphQL schema and queries.\u0026#34; :type github :pkgname \u0026#34;davazp/graphql-mode\u0026#34;) そして el-get-bundle でインストール\n(el-get-bundle graphql-mode) hooks graphql ファイルを弄る時に合わせて使いたい minor-mode があるのでそれらを有効にする hook を用意している\n(defun my/graphql-mode-hook () (company-mode 1) (turn-on-smartparens-strict-mode) (highlight-indent-guides-mode 1) (display-line-numbers-mode 1)) それぞれ以下の効果がある\ncompany-mode 補完候補を出してくれる smartparens-strict-mode カッコの対応を崩さないような編集ができるようなる highlight-indent-guides-mode インデントを見易くしてくれる display-line-numbers-mode 左側に行数表示を出してくれる そしてこの hook を graphql-mode-hook に突っ込んでいる\n(add-hook \u0026#39;graphql-mode-hook \u0026#39;my/graphql-mode-hook) graphql こちらは GraphQL API を Emacs Lisp から叩くためのライブラリ。命名的にややこしいけど。\nインストール こちらは el-get 本体にレシピがあるのでそのままインストールしている\n(el-get-bundle graphql) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/helm/",
	"title": "helm",
	"tags": [],
	"description": "",
	"content": "概要 helm は anything.el の後継であり、インクリメンタルに候補の絞り込みをしたりする UI を提供する便利なパッケージ。\npeco とか fzf とかと似ているっちゃ似ているかな? fzf 使ったことないけど。\n一時期開発が止まってるようだったけど最近(2021年)はまた更新が活発になっている。\nただ、麦汁さんは ivy に乗り換えようとしているので helm の設定は頑張っていない。 helm-for-files が便利なのでまだ捨てられてないけど……。\nインストール helm で使いたい拡張として helm-descbinds と helm-ag というのがあるのでそれらも同時に入れている。\n(el-get-bundle helm) (el-get-bundle helm-descbinds) (el-get-bundle helm-ag) ただ descbinds は counsel-descbinds に置き換えたし helm-ag ももう使ってない気がする\n設定 オススメの設定が helm に同梱されている helm-config に入ってるのでまずはそれを読み込んでいる。\n(require \u0026#39;helm-config) また helm-descbinds を使えるように有効にしている。けど、上にも書いたけどもう counsel-descbinds に置き換えちゃったのよね……。\n(helm-descbinds-mode) あとは helm-migemo-mode というのを有効にしている。これがあると helm で検索する時に migemo れて便利。\n(helm-migemo-mode 1) ivy の方でも migemo 対応したいけどまだできてない……。\nその他 helm 系の設定は他の設定にも色々影響も大きそうなので読み込み順は結構早いタイミングにしている(init-loader で 20 を prefix にしている)\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/helm-posframe/",
	"title": "helm-posframe",
	"tags": [],
	"description": "",
	"content": "概要 helm-posframe は helm の拡張で Helm のバッファの表示を posframe を使うようにしてくれるやつ。\n実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなのでいずれ外すかもしれない。\nただ確か本体の方の挙動が気に入らなかったような気はする。\nインストール いつも通り el-get でインストール。 GitHub にあるのでそれを取得するようにしている。\n(el-get-bundle tumashu/helm-posframe) 有効化 (helm-posframe-enable) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/",
	"title": "highlight-indent-guides",
	"tags": [],
	"description": "",
	"content": "概要 highlight-indent-guides はインデント毎にラインを引いたりして見易くしてくれるパッケージ。通常のプログラムを書く時にも便利だけど、 YAML などのインデントがそのまま構造になるような言語を弄る時にとても便利。\nインストール これもいつも通り el-get でインストールしている。 GitHub にあるのでそこを直接指定してインストールもできるのだけど el-get.lock からアップデートをチェックする都合上、レシピを用意してそれを使ってインストールしている\n(:name highlight-indent-guides :website \u0026#34;https://github.com/DarthFennec/highlight-indent-guides\u0026#34; :description \u0026#34;This minor mode highlights indentation levels via font-lock\u0026#34; :type github :pkgname \u0026#34;DarthFennec/highlight-indent-guides\u0026#34;) (el-get-bundle highlight-indent-guides) 設定 improvement 今いる行がどのインデントにいるのかをわかりやすくするために responsive モードを有効にしている。\n(setq highlight-indent-guides-responsive \u0026#34;stack\u0026#34;) defcustom で定義されてる変数なので custom-set-variables で設定した方がいいかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/hydra/",
	"title": "hydra",
	"tags": [],
	"description": "",
	"content": "概要 Hydra は Emacs の貴重なキーバインドを節約できる便利なパッケージ。\n自分で定義した各 Hydra コマンドを実行するとそれに紐付くサブコマンドとそれらのキーバインド一覧を表示させることができるというやつ。\nインストール Hydra 本体と関連パッケージをここでインスコしている\nHydra 本体のインストール Hydra 本体は el-get で普通に入れている\n(el-get-bundle hydra) hydra-posframe のインストール Hydra は通常だと minibuffer あたりに表示されるけど画面の真ん中に表示される方が視線移動が少なくて便利なので hydra-posframe を使って画面中央に表示されるようにしている。\nインストールは el-get でやっているが recipe がないのでまずそれを用意。\n(:name hydra-posframe :description \u0026#34;a hydra extension which shows hydra hints on posframe.\u0026#34; :type github :pkgname \u0026#34;Ladicle/hydra-posframe\u0026#34;) そして el-get-bundle でインストール\n(el-get-bundle hydra-posframe) そして Emacs の初期化処理が完了したタイミングでそれが使われるように after-init-hook で hydra-posframe を有効化している\n(add-hook \u0026#39;after-init-hook \u0026#39;hydra-posframe-enable) WebDAV Sync download の設定 作業管理用の org-mode のドキュメントは WebDAV サーバにも上げて beorg でも使えるようにしているがそれを拾って来るためのコマンドを用意している。\n(defun my/download-from-beorg () (interactive) (async-shell-command \u0026#34;java -jar ~/bin/webdav_sync1_1_9.jar -c ~/.config/webdav-sync/download.xml \u0026amp;\u0026amp; notify-send \u0026#39;WebDAV Sync\u0026#39; \u0026#39;Downloaded from WebDAV\u0026#39;\u0026#34;)) 簡単に async-shell-command を使って済ませている\nmajor-mode-hydra のインストール 自分以外で使っている人を見たことはないけど麦汁さんは major-mode-hydra というものを利用している。\nこれは major mode 用に簡単に Hydra の設定ができるというやつ。なので emacs-lisp-mode 用の Hydra とか js2-mode 用の Hydra などを定義できて便利。\nどちらの場合も M-x major-mode-hydra で起動するので迷わないで済むのも良い。\n内部では同じリポジトリにある pretty-hydra というのを利用していてそいつが UI の定義をせずともそれなりの感じに Hydra のメニューを構築してくれるようになっている。これもズボラな麦汁さんは気に入っている。導入していても表示にこだわりたい場合は直接 defhydra したらいいだけだしね。\nってことでそれを el-get を使って GitHub からインストールしている。\n(el-get-bundle major-mode-hydra.el) また pretty-hydra の表示フォーマットを変えるために pretty-hydra-default-title-body-format-spec を使うようにしている\n(custom-set-variables \u0026#39;(pretty-hydra-default-title-body-format-spec \u0026#34;%s\\n%s\u0026#34;)) なおレシピは自前で用意している\n(:name major-mode-hydra.el :website \u0026#34;https://github.com/jerrypnz/major-mode-hydra.el\u0026#34; :description \u0026#34;this package offers an alternative way to manage your major mode specific key bindings.\u0026#34; :type github :pkgname \u0026#34;jerrypnz/major-mode-hydra.el\u0026#34;) キーバインド Hydra でいくつかのキーバインドを設定していて他の機能に属さないものはここでまとめてキーバインドを定義している。\nel-get 他の機能に属さないものは、と書いたな? ありゃ嘘だ。 el-get の Hydra はここで定義してしまっている。その内 el-get 用の設定ファイルにでも移動したい気がする。\n(pretty-hydra-define el-get-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;el-get\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Install\u0026#34; ((\u0026#34;i\u0026#34; el-get-install \u0026#34;Install\u0026#34;) (\u0026#34;I\u0026#34; el-get-reinstall \u0026#34;Re-install\u0026#34;) (\u0026#34;D\u0026#34; el-get-remove \u0026#34;Uninstall\u0026#34;)) \u0026#34;Update\u0026#34; ((\u0026#34;s\u0026#34; el-get-self-update \u0026#34;Self Update\u0026#34;) (\u0026#34;u\u0026#34; el-get-update \u0026#34;Update\u0026#34;) (\u0026#34;A\u0026#34; el-get-update-all \u0026#34;Update All\u0026#34;) (\u0026#34;r\u0026#34; el-get-reload \u0026#34;Reload\u0026#34;)) \u0026#34;Recipe\u0026#34; ((\u0026#34;f\u0026#34; el-get-find-recipe-file \u0026#34;Find recipe\u0026#34;) (\u0026#34;E\u0026#34; el-get-elpa-build-local-recipes \u0026#34;Build ELPA recipes\u0026#34;) (\u0026#34;W\u0026#34; el-get-emacswiki-build-local-recipes \u0026#34;Build EmacsWiki recipes\u0026#34;)) \u0026#34;Lock\u0026#34; ((\u0026#34;C\u0026#34; el-get-lock-checkout \u0026#34;Checkout\u0026#34;) (\u0026#34;U\u0026#34; el-get-lock-unlock \u0026#34;Unlock\u0026#34;)))) Key 効果 i パッケージの新規インストール。正直このキー叩いた記憶がない I パッケージの再インストール D パッケージの削除 s el-get 自身のアップデート u 指定パッケージのアップデート A 全パッケージのアップデート r パッケージの読み直し f パッケージのインストール用レシピファイルを開く C 指定したパッケージを el-get-lock でロックされたバージョンをチェックアウト U 指定したパッケージの el-get-lock のロックを解除 Toggle Switches ここでは ON/OFF を切り替えるような機能のコントロールを行っている。\n(pretty-hydra-define toggle-hydra (:separator \u0026#34;-\u0026#34; :title (concat (all-the-icons-faicon \u0026#34;toggle-on\u0026#34;) \u0026#34; Toggle Switches\u0026#34;) :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;View\u0026#34; ((\u0026#34;z\u0026#34; zoom-mode \u0026#34;zoom-mode\u0026#34; :toggle zoom-mode) (\u0026#34;Z\u0026#34; toggle-frame-fullscreen \u0026#34;Fullscreen\u0026#34; :toggle (frame-parameter nil \u0026#39;fullscreen)) (\u0026#34;e\u0026#34; emojify-mode \u0026#34;Emojify\u0026#34; :toggle emojify-mode) (\u0026#34;b\u0026#34; display-battery-mode \u0026#34;Battery\u0026#34; :toggle display-battery-mode) (\u0026#34;L\u0026#34; display-line-numbers-mode \u0026#34;Line Number\u0026#34; :toggle display-line-numbers-mode) (\u0026#34;N\u0026#34; neotree-toggle \u0026#34;Neotree\u0026#34; :toggle (if (fboundp \u0026#39;neo-global--window-exists-p) (neo-global--window-exists-p) nil))) \u0026#34;Behavior\u0026#34; ((\u0026#34;S\u0026#34; my/notify-slack-toggle \u0026#34;Notify Slack\u0026#34; :toggle my/notify-slack-enable-p) (\u0026#34;v\u0026#34; my/toggle-view-mode \u0026#34;Readonly\u0026#34; :toggle view-mode) (\u0026#34;f\u0026#34; flycheck-mode \u0026#34;Flycheck\u0026#34; :toggle flycheck-mode) (\u0026#34;A\u0026#34; auto-fix-mode \u0026#34;Auto fix\u0026#34; :toggle auto-fix-mode) (\u0026#34;^\u0026#34; subword-mode \u0026#34;Subword\u0026#34; :toggle subword-mode) (\u0026#34;(\u0026#34; smartparens-strict-mode \u0026#34;strict parens\u0026#34; :toggle smartparens-strict-mode) (\u0026#34;E\u0026#34; toggle-debug-on-error \u0026#34;Debug on error\u0026#34; :toggle debug-on-error)))) Key 効果 z zoom-mode のON/OFF切替。狭いディスプレイの時は ON にするが、大きいディスプレイだと OFF にしている Z フルスクリーンの切替。狭いディスプレイの時は ON にするが、大きいディスプレイだと OFF にしている b バッテリー表示モードの切替。OFF にしたことないな…… L 行番号表示の切替。邪魔になる時もあるので ON/OFF 切り替えている N Neotree の表示切替。普段は邪魔なので OFF にしている S Slack 通知の切替。org-clock-in とかのタイミングで Slack に通知を飛ばしているが切る時もある v view-mode にしたり戻したり。コードを眺めたい時などに ON にする E エラー時のデバッグモードの切替。設定を弄ってる時はバックトレースある方が嬉しいよね Sub Tools 最初に起動した Hydra からは外してるけど、そこそこ使うコマンド群を適当に詰めてるやつ。\n(pretty-hydra-define subtools-hydra (:separator \u0026#34;-\u0026#34; :color teal :foreign-key warn :title (concat (all-the-icons-material \u0026#34;build\u0026#34;) \u0026#34; Sub tools\u0026#34;) :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Describe\u0026#34; ((\u0026#34;b\u0026#34; counsel-descbinds \u0026#34;Keybind\u0026#34;) (\u0026#34;f\u0026#34; counsel-describe-function \u0026#34;Function\u0026#34;) (\u0026#34;v\u0026#34; counsel-describe-variable \u0026#34;Variable\u0026#34;) ;; (\u0026#34;P\u0026#34; my/open-review-requested-pr \u0026#34;Open Requested PR\u0026#34;) (\u0026#34;m\u0026#34; describe-minor-mode \u0026#34;Minor mode\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;@\u0026#34; all-the-icons-hydra/body \u0026#34;List icons\u0026#34;) (\u0026#34;w\u0026#34; which-key-show-top-level \u0026#34;Which key\u0026#34;) (\u0026#34;D\u0026#34; my/download-from-beorg)))) Key 効果 b キーバインドを調べる f Emacs Lisp の関数を調べる v Emacs Lisp の変数を調べる m minor-mode を調べる @ All the icons の Hydra を起動 w トップレベルのキーバインドを表示する D beorg 連携に使ってる WebDAV サーバからダウンロード(Dropbox に移行して不要になった) Text Scale 文字サイズの切替用。たまに字を大きくしたりしたいので。\n(pretty-hydra-define text-scale-hydra (:separator \u0026#34;-\u0026#34; :title (concat (all-the-icons-material \u0026#34;text_fields\u0026#34;) \u0026#34; Text Scale\u0026#34;) :exit nil :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Scale\u0026#34; ((\u0026#34;+\u0026#34; text-scale-increase \u0026#34;Increase\u0026#34;) (\u0026#34;-\u0026#34; text-scale-decrease \u0026#34;Decrease\u0026#34;) (\u0026#34;0\u0026#34; text-scale-adjust \u0026#34;Adjust\u0026#34;)))) Key 効果 + 文字サイズを大きくする - 文字サイズを小さくする 0 文字サイズを元に戻す Main よく使うコマンドをまとめたやつ。 key-chord を使って jk 同時押しで起動できるようにしている。\n(pretty-hydra-define pretty-hydra-usefull-commands (:separator \u0026#34;-\u0026#34; :color teal :foreign-key warn :title (concat (all-the-icons-material \u0026#34;build\u0026#34;) \u0026#34; Usefull commands\u0026#34;) :quit-key \u0026#34;q\u0026#34;) (\u0026#34;File\u0026#34; ((\u0026#34;p\u0026#34; projectile-hydra/body \u0026#34;Projectile\u0026#34;) (\u0026#34;f\u0026#34; counsel-find-file \u0026#34;Find File\u0026#34;) (\u0026#34;d\u0026#34; counsel-find-dir \u0026#34;Find Dir\u0026#34;) (\u0026#34;r\u0026#34; counsel-recentf \u0026#34;Recentf\u0026#34;) (\u0026#34;L\u0026#34; counsel-locate \u0026#34;Locate\u0026#34;)) \u0026#34;Edit\u0026#34; ((\u0026#34;a\u0026#34; align-regexp \u0026#34;Align Regexp\u0026#34;) (\u0026#34;[\u0026#34; origami-hydra/body \u0026#34;Origami\u0026#34;) (\u0026#34;;\u0026#34; comment-dwim \u0026#34;Comment\u0026#34;)) \u0026#34;Code\u0026#34; ((\u0026#34;G\u0026#34; counsel-projectile-ag \u0026#34;Grep\u0026#34;) (\u0026#34;j\u0026#34; dumb-jump-pretty-hydra/body \u0026#34;Dumb jump\u0026#34;) (\u0026#34;g\u0026#34; avy-hydra/body \u0026#34;Avy\u0026#34;) (\u0026#34;l\u0026#34; pretty-hydra-lsp/body \u0026#34;LSP\u0026#34;) (\u0026#34;i\u0026#34; counsel-imenu \u0026#34;imenu\u0026#34;) (\u0026#34;y\u0026#34; yasnippet-hydra/body \u0026#34;Yasnippet\u0026#34;) (\u0026#34;B\u0026#34; browse-at-remote \u0026#34;Browse\u0026#34;) (\u0026#34;C\u0026#34; git-messenger:popup-message \u0026#34;Git Message\u0026#34;) (\u0026#34;m\u0026#34; magit-status \u0026#34;Magit\u0026#34;)) \u0026#34;View\u0026#34; ((\u0026#34;D\u0026#34; delete-other-windows \u0026#34;Only This Win\u0026#34;) (\u0026#34;W\u0026#34; window-control-hydra/body \u0026#34;Window Control\u0026#34;) (\u0026#34;+\u0026#34; text-scale-hydra/body \u0026#34;Text Scale\u0026#34;) (\u0026#34;w\u0026#34; ace-swap-window \u0026#34;Swap Window\u0026#34;)) \u0026#34;Tool\u0026#34; ((\u0026#34;SPC\u0026#34; major-mode-hydra \u0026#34;Hydra(Major)\u0026#34;) (\u0026#34;s\u0026#34; toggle-hydra/body \u0026#34;Toggle switches\u0026#34;) (\u0026#34;c\u0026#34; counsel-org-capture \u0026#34;Capture\u0026#34;) (\u0026#34;o\u0026#34; global-org-hydra/body \u0026#34;Org\u0026#34;) (\u0026#34;e\u0026#34; el-get-hydra/body \u0026#34;el-get\u0026#34;) (\u0026#34;k\u0026#34; kibela-hydra/body \u0026#34;Kibela\u0026#34;) (\u0026#34;/\u0026#34; google-pretty-hydra/body \u0026#34;Google\u0026#34;) (\u0026#34;t\u0026#34; subtools-hydra/body \u0026#34;Sub Tools\u0026#34;)))) Key 効果 p Projectile 用の Hydra 起動 f counsel でファイルを開く d counsel でフォルダ開く r counsel で最近使ったファイルを開く l counsel で locate する。Mac だと mdfind だけど A counsel で macOS の Application を開く a 正規表現に基いて整形 ; コメント挿入。 M-; を使ってるから要らないかも G projectile 内の検索。関係ないのがかかる時もあるので調整必要 j dumb-jump 用の Hydra 起動 g 画面上の好きな位置にジャンプする avy の起動 i counsel-imenu 起動。使ってない気がする y yasnippet 用の Hydra 起動 B browse-at-remote で GitHub などのコード位置を開く m magit を起動 D 他の Window を消す W フレームサイズや位置を弄るための Hydra を起動。ほぼ使ってない + 文字サイズ変更用 Hydra の起動 w Window の入替 SPC major-mode-hydra の起動 s ON/OFF 切替系の Hydra を起動する c counsel-org-capture を呼び出す o org-mode 用の Hydra を起動する e el-get 用の Hydra を起動する t 第一階層には入れてないけどまあまあ便利なコマンドを詰めた Hydra を起動する "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/ido-mode/",
	"title": "ido-mode",
	"tags": [],
	"description": "",
	"content": "概要 Emacs に標準添付の補完インターフェース。 ivy 使ってるからこれ有効化している意味がない気はする。\n拡張入れてない段階でもこいつを有効にしていると find-file とかが楽になって良い。\n有効化 とりあえず昔からずっと有効化している\n(ido-mode 1) 設定 ファイル名の補完とかを曖昧一致を有効にするっぽいい。\n(setq ido-enable-flex-matching t) その他 https://qiita.com/tadsan/items/33ebb8db2271897a462b に書いていることだけど\nido-everywhere を有効にするとファイル名とバッファ切替以外にも使えるようになるらしい smex 入れると M-x が強化される ido-ubiquitous を入れると ido-everywhere よりもさらに色々な他に使えるらしい ido-vertical-mode を入れたら候補が縦並びになって便利っぽい "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/improvement/",
	"title": "improvement",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/ivy/",
	"title": "ivy",
	"tags": [],
	"description": "",
	"content": "概要 インストール el-get を使って GitHub のリポジトリから直で入れている。\n(el-get-bundle abo-abo/swiper) ;; ivy, swiper, counsel が同時に入って来る MELPA 経由だと org-mode 関係のパッケージ周りでハマったことがあるので GitHub から直で入れる運用にしている。\nが、やっぱり MELPA とかに寄せるべきかなって気になってきているところだったりもする。\nなんか設定 便利に使えるようにするための設定を書いている。が、何を設定しているのかよく覚えてないので今度調べておこう……\n(when (require \u0026#39;ivy nil t) ;; M-o を ivy-dispatching-done-hydra に割り当てる． (require \u0026#39;ivy-hydra) ;; `ivy-switch-buffer\u0026#39; (C-x b) のリストに recent files と bookmark を含める． (setq ivy-use-virtual-buffers t) ;; ミニバッファでコマンド発行を認める (when (setq enable-recursive-minibuffers t) (minibuffer-depth-indicate-mode 1)) ;; 何回層入ったかプロンプトに表示． ;; ESC連打でミニバッファを閉じる (define-key ivy-minibuffer-map (kbd \u0026#34;\u0026lt;escape\u0026gt;\u0026#34;) \u0026#39;minibuffer-keyboard-quit) ;; (index/総数) 表示で何番目の候補かわかりやすくする (setq ivy-count-format \u0026#34;(%d/%d) \u0026#34;) ;; アクティベート (ivy-mode 1)) counsel の有効化 counsel は ivy で提供されているやつで、既存の Emacs のコマンドを置き換えてくれるやつ。\nとても便利なので当然有効にしている。\n(counsel-mode 1) counsel-locate-cmd の設定 環境によってシステム全体を検索するコマンドが異なるのでここで指定している。 Mac は mdfind を使いそれ以外ではデフォルトの locate を使う。\n(custom-set-variables \u0026#39;(counsel-locate-cmd (if (eq window-system \u0026#39;mac) \u0026#39;counsel-locate-cmd-mdfind \u0026#39;counsel-locate-cmd-default))) counsel.el を見てると Windows では counsel-locate-cmd-es が使われるようだけど Windows 環境を使ってないので無視。 https://github.com/abo-abo/swiper/blob/d28225e86f8dfb3825809ad287f759f95ee9e479/counsel.el#L2567-L2573\nivy-posframe ivy-posframe は ivy を posframe で表示してくれるようにするやつ。 posframe 表示だと Emacs の中央に表示できるので視線移動が少なく済んで便利。\nインストール こちらは自前で el-get の resipe を用意している\n(:name ivy-posframe :type github :description \u0026#34;ivy-posframe is a ivy extension, which let ivy use posframe to show its candidate menu.\u0026#34; :pkgname \u0026#34;tumashu/ivy-posframe\u0026#34; :minimum-emacs-version (26)) そしていつも通りに el-get でインストール\n(el-get-bundle ivy-posframe) 設定 Swiper だけは画面下部に表示されるようにしているが他は画面中央に表示されるようにしている。\nSwiper は検索なので、真ん中に表示しているとヒットした部分が隠されてしまう。というわけでそいつだけは下に表示しているのでした。\n(setq ivy-posframe-display-functions-alist \u0026#39;((swiper . ivy-display-function-fallback) (t . ivy-posframe-display-at-frame-center))) 有効化 (ivy-posframe-mode 1) ivy-rich ivy-rich は ivy の見た目をよりモダンにしてくれるやつ。なんだけど、オフにした時の表示どんな感じだったか忘れたな……。\nインストール el-get のレシピを自前で用意して\n(:name ivy-rich :type github :description \u0026#34;More friendly interface for ivy\u0026#34; :pkgname \u0026#34;Yevgnen/ivy-rich\u0026#34; :minimum-emacs-version (25 1)) el-get-bundle でインストールしている\n(el-get-bundle ivy-rich) アイコン設定 いい感じにアイコンが表示されるように https://ladicle.com/post/config/#ivy に書かれている関数を丸コピしてきた\n(defun ivy-rich-file-icon (candidate) \u0026#34;Display file icons in `ivy-rich\u0026#39;.\u0026#34; (when (display-graphic-p) (let ((icon (if (file-directory-p candidate) (cond ((and (fboundp \u0026#39;tramp-tramp-file-p) (tramp-tramp-file-p default-directory)) (all-the-icons-octicon \u0026#34;file-directory\u0026#34;)) ((file-symlink-p candidate) (all-the-icons-octicon \u0026#34;file-symlink-directory\u0026#34;)) ((all-the-icons-dir-is-submodule candidate) (all-the-icons-octicon \u0026#34;file-submodule\u0026#34;)) ((file-exists-p (format \u0026#34;%s/.git\u0026#34; candidate)) (all-the-icons-octicon \u0026#34;repo\u0026#34;)) (t (let ((matcher (all-the-icons-match-to-alist candidate all-the-icons-dir-icon-alist))) (apply (car matcher) (list (cadr matcher)))))) (all-the-icons-icon-for-file candidate)))) (unless (symbolp icon) (propertize icon \u0026#39;face `( :height 1.1 :family ,(all-the-icons-icon-family icon) )))))) switch-buffer でのアイコン表示 公式に書かれてるように設定することでバッファを切り替える時もアイコンが表示されるようにしている。 https://github.com/Yevgnen/ivy-rich#how-i-can-add-icons-for-ivy-switch-buffer\n(defun ivy-rich-switch-buffer-icon (candidate) (with-current-buffer (get-buffer candidate) (let ((icon (all-the-icons-icon-for-mode major-mode))) (if (symbolp icon) (all-the-icons-icon-for-mode \u0026#39;fundamental-mode) icon)))) yank-pop の区切り設定 yank-pop の区切りをちょっと長めにしている。長い方が区切りだってわかりやすいので。\n(setq counsel-yank-pop-separator \u0026#34;\\n--------------------\\n\u0026#34;) ivy-rich の表示設定 それぞれのカラムがどのぐらいの幅、みたいな設定をコマンド毎に設定できるようになっている。\n(setq ivy-rich-display-transformers-list \u0026#39;(ivy-switch-buffer (:columns ((ivy-rich-switch-buffer-icon :width 2) (ivy-rich-candidate (:width 30)) (ivy-rich-switch-buffer-size (:width 7)) (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)) (ivy-rich-switch-buffer-major-mode (:width 12 :face warning)) (ivy-rich-switch-buffer-project (:width 15 :face success)) (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3)))))) :predicate (lambda (cand) (get-buffer cand))) counsel-M-x (:columns ((counsel-M-x-transformer (:width 40)) ; thr original transformer (ivy-rich-counsel-function-docstring (:face font-lock-doc-face)))) ; return the docstring of the command counsel-find-file (:columns ((ivy-rich-file-icon) (ivy-rich-candidate))) counsel-recentf (:columns ((ivy-rich-file-icon) (ivy-rich-candidate (:width 110)))) )) switch-buffer 以下のような構成になっている。\n列名 幅 内容 アイコン 2 all-the-icons のアイコン表示幅の設定 候補名 30 選択候補名。バッファ名が表示される。 バッファサイズ 7 容量を示す。120.3k みたいな表示になる インジケータ 4 保存されてるかなどの表示。正直マーク何が何かわかってない メジャーモード 12 そのバッファのメジャーモード。Org とか表示されたりする プロジェクト名 15 プロジェクト名の表示。.git があるフォルダ名が大体出てる ファイルパス 可変 プロジェクト内でのファイル位置の表示 正直ファイル名以外あんまり気にしたことがない……。\nM-x コマンド選択時のやつは以下の構成になっている。\n列名 幅 内容 コマンド名 40 候補となるコマンド名の表示 概要 制限なし コマンドの概要。docstring の1行目が表示されてるっぽい find-file 列名 幅 内容 アイコン 未設定 all-the-icons のアイコン表示 ファイル名 未設定 カレントディレクトリ内のファイルが候補として表示される recentf 列名 幅 内容 アイコン 未設定 all-the-icons のアイコン表示 ファイル名 110 最近使われたファイルが候補として表示される もうちょっと追加で情報表示できると便利かも。\nivy-rich-mode の有効化 (ivy-rich-mode 1) C-s で migemo れるように ivy-migemo を導入・設定 swiper は標準だと migemo れないのだが\nhttps://github.com/ROCKTAKEY/ivy-migemo\nでそれをできるようにした。\nインストール (:name ivy-migemo :website \u0026#34;https://github.com/ROCKTAKEY/ivy-migemo\u0026#34; :description \u0026#34;Use migemo on ivy.\u0026#34; :type github :pkgname \u0026#34;ROCKTAKEY/ivy-migemo\u0026#34;) でレシピを用意して\n(el-get-bundle ivy-migemo) で入れている。\nキーバインドの設定 以下を入れておくと migemo を使ったり fuzzy を使ったりを切り替えられるようなのでとりあえず設定している。\n(define-key ivy-minibuffer-map (kbd \u0026#34;M-f\u0026#34;) #\u0026#39;ivy-migemo-toggle-fuzzy) (define-key ivy-minibuffer-map (kbd \u0026#34;M-m\u0026#34;) #\u0026#39;ivy-migemo-toggle-migemo) なおこれは公式に記載されている設定である。\nデフォルトで migemo を有効にする swiper を使う時はデフォで有効になっててほしいのでその設定も入れている。なおこれも公式ページに記述されている設定である。\nというか全体を ivy-migemo-regex-plus にしている。これは completing-read-function で指定されている ivy-completing-read でも migemo りたかったため。 completing-read や ivy-completing-read を指定してもうまくいかないのでもうエイヤで全部 migemo に倒した\n(with-eval-after-load \u0026#39;ivy-migemo (setq ivy-re-builders-alist \u0026#39;((t . ivy-migemo-regex-plus) (counsel-M-x . ivy--regex-plus) (counsel-describe-function . ivy--regex-plus) (counsel-describe-variable . ivy--regex-plus) (swiper . ivy-migemo-regex-plus) (counsel-find-file . ivy-migemo-regex-plus)))) また fuzzy match を有効にする設定も記載されているがそちらは自分は設定していない。なんとなく。\nivy-kibela Kibela の記事を ivy で絞り込んで Emacs から開けるようにするために ivy-kibela という自作ツールを使っている\nインストール 以下のレシピを用意して\n(:name ivy-kibela :website \u0026#34;https://github.com/mugijiru/ivy-kibela\u0026#34; :description \u0026#34;Ivy interface to kibela.\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;mugijiru/ivy-kibela\u0026#34;) (el-get-bundle ivy-kibela) を設定ファイルに書いておけば OK\n有効化 今のところ明示的に require しないといけない。 ivy が読まれてから読まれて欲しいので、以下のように設定している。\n(with-eval-after-load \u0026#39;ivy (require \u0026#39;ivy-kibela)) 設定 README に従い ivy-kibela-team と ivy-kibela-access-token を設定してあげれば OK。自分は authinfo を使ってるのでそれ経由で値を取得している。\n(custom-set-variables \u0026#39;(ivy-kibela-team (plist-get (nth 0 (auth-source-search :host \u0026#34;kibe.la\u0026#34;)) :team)) \u0026#39;(ivy-kibela-access-token (funcall (plist-get (nth 0 (auth-source-search :host \u0026#34;kibe.la\u0026#34; :max 1)) :secret)))) ivy-migemo の有効化 ivy-kibela でも migemo りたかったので、以下のようにして migemo でも使えるようにしている\n(with-eval-after-load \u0026#39;ivy-kibela (add-to-list \u0026#39;ivy-re-builders-alist \u0026#39;(ivy-kibela . ivy-migemo-regex-plus) t)) prescient.el prescient.el は強力なソート・フィルタ機能を提供してくれるパッケージ。 ivy などの絞り込み系ツールと組み合わせて使う。\nとりあえずいつも通り el-get でインストールしている。\n(el-get-bundle prescient.el) レシピは自前で追加している\n(:name prescient.el :website \u0026#34;https://github.com/radian-software/prescient.el\u0026#34; :description \u0026#34;simple but effective sorting and filtering for Emacs.\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;radian-software/prescient.el\u0026#34; :minimum-emacs-version \u0026#34;27.1\u0026#34; :depends (corfu)) 依存している corfu も自前で追加している\n(:name corfu :website \u0026#34;https://github.com/minad/corfu\u0026#34; :description \u0026#34;COmpletion in Region FUnction\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;minad/corfu\u0026#34; :minimum-emacs-version \u0026#34;27.1\u0026#34; :depends (compat)) そんで ivy でそれが使われるように ivy-prescient-mode を有効にしている。\n(ivy-prescient-mode 1) ただ候補文字列の長さで sort されるのはどうも微妙さを感じるので無効にしている。\n(setq prescient-sort-length-enable nil) どうやら company-mode でも使えるらしいので設定は別のところに分離した方がいいかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/jest/",
	"title": "Jest",
	"tags": [],
	"description": "",
	"content": "概要 Jest は JavaScript のテスティングフレームワークの1つ。なんか大体オールインワンな感じで最近はデファクトっぽい人気なやつ。\njest-test-mode jest-test-mode は Emacs 上から Jest のテストを手軽に実行できるようにしてくれるやつ。\nインストール まず el-get のレシピが公式では置かれていないので自前で用意\n(:name jest-test-mode :website \u0026#34;https://github.com/rymndhng/jest-test-mode/tree/3126c5c5c5632da639ea34867a7342d4410d78aa\u0026#34; :description \u0026#34;Emacs minor mode for running jest.\u0026#34; :type github :pkgname \u0026#34;rymndhng/jest-test-mode\u0026#34; :minimum-emacs-version \u0026#34;25.1\u0026#34;) そしてそれを el-get-bundle でインストール\n(el-get-bundle jest-test-mode) keymap デフォルトのキーマップ以外にも C-c C-c でテストできる方が手癖でテストを実行できて便利なので jest-test-mode-map に keybind を追加している\n(with-eval-after-load \u0026#39;jest-test-mode (let ((keymap jest-test-mode-map)) (define-key keymap (kbd \u0026#34;C-c C-c\u0026#34;) \u0026#39;jest-test-run-at-point))) .dir-locals.el Jest でテストを書いているプロジェクトのテストファイルを詰めているフォルダの.dir-locals.el に以下のように書くことでそれらのコードを開いた時に jest-test-mode が自動的に有効になるようにしている\n((web-mode . ((eval . (jest-test-mode)))) (typescript-mode . ((eval . (jest-test-mode))))) その他 類似品に emacs-jest というのもあるが、こちらは el-get で入れようとしても jest-traverse-test.el の byte compile でエラーになるので利用を諦めた\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/json/",
	"title": "JSON",
	"tags": [],
	"description": "",
	"content": "概要 パッケージの設定ファイルなどでよく使われているファイル形式。\njson-mode json-mode は Emacs で JSON を編集するためのモード。\nインストール いつも通り el-get-bundle でインストール。\n(el-get-bundle json-mode) hook 補完を有効にしたり LSP を使えるようにしたり保存時に自動整形させたりするため hook を色々突っ込んでる\n(defun my/json-mode-hook () (company-mode 1) (lsp) (lsp-ui-mode 1) (add-hook \u0026#39;before-save-hook #\u0026#39;lsp-format-buffer nil \u0026#39;local) (turn-on-smartparens-strict-mode) (flycheck-mode 1) (flycheck-select-checker \u0026#39;json-jq) (highlight-indent-guides-mode 1) (display-line-numbers-mode 1)) (add-hook \u0026#39;json-mode-hook \u0026#39;my/json-mode-hook) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/key-chord/",
	"title": "key-chord",
	"tags": [],
	"description": "",
	"content": "概要 key-chord はキーを同時に押した時にコマンドを発動させるということができるようにしてくれるパッケージ。\nなのですが本家の方だと誤爆が多いということなのでそれを改善した zk-phi/key-chord の方を利用している。\nまあほとんど使えてないので改良版の恩恵をまだ受けてないけど……。\nインストール el-get のレシピは自前で用意している。なおインストールしているのは本家版ではない。\n(:name key-chord :description \u0026#34;bind commands to combinations of key-strokes\u0026#34; :type github :pkgname \u0026#34;zk-phi/key-chord\u0026#34;) そして el-get でインストールしている。\n(el-get-bundle key-chord) 設定 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。\n(setq key-chord-two-keys-delay 0.25 key-chord-safety-interval-backward 0.1 key-chord-safety-interval-forward 0.15) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。\n改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動に使っている上に Hydra で叩けるやつでよく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。\n有効化 設定を入れた後は有効にするだけである。\n(key-chord-mode 1) 実際のキーバインド設定は各モードだったりグローバルキーバインドを設定しているファイルだったりで書く感じ。\nといいつつ現状では Hydra 起動のやつしか使ってないので、グローバルキーバインド設定でしか書いてない。\nsticky-shift セミコロン2つでシフトを押した状態にする セミコロンを2回叩くことで shift が押されてるという状態を実現する。\nこれにより magit で P などを入力したい時にも ;;p で入力できるし通常の英字入力時にも大文字にできるので左手小指が痛い時には Shift を使わずに操作ができるようになる。\n(key-chord-define-global \u0026#34;;;\u0026#34; \u0026#39;event-apply-shift-modifier) (key-chord-define key-translation-map \u0026#34;;;\u0026#34; \u0026#39;event-apply-shift-modifier) global-key-map と key-translation-map の両方に定義しないと動かないがその原因はよく分かってない。一旦動くから良しとしている。\nここで使っている event-apply-shift-modifier はデフォルトでは C-x @ S にバインドされているやつ。お仲間に event-apply-control-modifier などの各 modifier キーがいるので sticky 的なことをやる上で便利な子達。 sticky-control の中でも event-apply-control-modifier が使われているぞい。\nやりたかったけど実現できてないこと セミコロン*2+数字キー、セミコロン*2+記号キーの対応 sticky.el では実現されてそうなことなので、同じことをできるようにしたい\nその他 sticky-control も control 限定で似たようなことをしているので key-chord に全部置き換えできるかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/keypression/",
	"title": "keypression",
	"tags": [],
	"description": "",
	"content": "概要 keypression は Emacs 上でのキー操作を可視化してくれるツール。操作したキーを右下とかにダダダッと表示してくれるのでデモ動画を撮る時なんかに使うと便利なやつ\nインストール el-get にはレシピがないので自前で用意している\n(:name keypression :website \u0026#34;https://github.com/chuntaro/emacs-keypression\u0026#34; :description \u0026#34;Keystroke visualizer for GUI version Emacs\u0026#34; :type github :branch \u0026#34;master\u0026#34; :pkgname \u0026#34;chuntaro/emacs-keypression\u0026#34;) そしてそれを el-get-bundle でインストールしている\n(el-get-bundle keypression) 設定 あまり設定は弄っていないが、とりあえず child frame を使うようにしている\n(custom-set-variables \u0026#39;(keypression-use-child-frame t)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/load-path/",
	"title": "load-path",
	"tags": [],
	"description": "",
	"content": "概要 load-path は Emacs の設定でも重要な項目でこのリストに追加されている path は load または require する際に走査される path となっている。\n即ち load-path を通しておけば、そこに置いている emacs lisp のファイルは簡単に読み出せるようになる。\nなお package-install や el-get を使っておけば基本的に自分で load-path を通す必要はない。\n秘匿情報を入れてるフォルダを読み込み可能にする パスワードなどの秘匿情報を持っている部分は ~/.emacs.d/secret というフォルダで管理している。そのためここに入ってる emacs lisp のファイルも読み込めるように load-path に追加している。\n(add-to-list \u0026#39;load-path (expand-file-name \u0026#34;~/.emacs.d/secret\u0026#34;)) my/load-config ~/.emacs.d/secret は個人マシンか会社マシンかによって置いてるデータが異なったりするためもしもファイルがなくてもエラーにならないような方法で load する方法が必要だった。\nというわけでファイルがなかったら読み込まずにメッセージを出力して終了するような関数を用意している。\n(defun my/load-config (file) (condition-case nil (load file) (file-missing (message \u0026#34;Load error: %s\u0026#34; file)))) ただ、これって結局\n(load file nil t) で十分な気もするので、置き換えを検討した方が良さそう。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/lsp-mode/",
	"title": "lsp-mode",
	"tags": [],
	"description": "",
	"content": "概要 lsp-mode は Emacs で Language server protocol が使えるようにするパッケージ。\nより軽そうなやつに eglot というのもあるがこっちは試したことがない。\nインストール lsp-mode 本体と UI 周りを担当する lsp-ui-mode の両方をインストールしている。また lsp-mode が有効になる際に lsp-ui-mode も同時に有効になるようにしている。\n(el-get-bundle lsp-mode) (el-get-bundle lsp-ui) (add-hook \u0026#39;lsp-mode-hook \u0026#39;lsp-ui-mode) カスタム変数 lsp-ui-doc はカーソル位置にある変数や関数などの説明を child frame で表示してくれるやつ。\nこれがデフォルトではフレーム基準で右上に表示するのだが大きめの画面を分割して使っていると大分遠くに表示されてしまうので window 基準で表示するように設定を変更している\n(custom-set-variables \u0026#39;(lsp-diagnostics-provider :flycheck) \u0026#39;(lsp-ui-doc-show-with-cursor t) \u0026#39;(lsp-ui-doc-alignment \u0026#39;window)) パッチ 文字を拡大している時の折り返しがおかしくならないようにするパッチ\n;; Patch ;; https://github.com/emacs-lsp/lsp-ui/issues/184#issuecomment-1158057166 (with-eval-after-load \u0026#39;lsp-ui-sideline (defun lsp-ui-sideline--align (\u0026amp;rest lengths) \u0026#34;Align sideline string by LENGTHS from the right of the window.\u0026#34; (cons (+ (apply \u0026#39;+ lengths) (if (display-graphic-p) 1 2)) \u0026#39;width)) (defun lsp-ui-sideline--compute-height () nil)) Hydra の設定 (with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define pretty-hydra-lsp (:separator \u0026#34;-\u0026#34; :color blue :foreign-keys warn :title \u0026#34;LSP\u0026#34; :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Find\u0026#34; ((\u0026#34;x\u0026#34; lsp-find-definition \u0026#34;definition\u0026#34;) (\u0026#34;r\u0026#34; lsp-find-references \u0026#34;references\u0026#34;) (\u0026#34;t\u0026#34; lsp-find-type-definition \u0026#34;type\u0026#34;) (\u0026#34;i\u0026#34; lsp-find-implementation \u0026#34;implementation\u0026#34;) (\u0026#34;D\u0026#34; lsp-find-declaration \u0026#34;declaration\u0026#34;)) \u0026#34;Code\u0026#34; ((\u0026#34;m\u0026#34; lsp-rename \u0026#34;Rename\u0026#34;)) \u0026#34;UI\u0026#34; ((\u0026#34;I\u0026#34; lsp-ui-imenu \u0026#34;imenu\u0026#34;) (\u0026#34;X\u0026#34; lsp-ui-peek-find-definitions \u0026#34;def\u0026#34;) (\u0026#34;R\u0026#34; lsp-ui-peek-find-references \u0026#34;refs\u0026#34;))))) TSX のインデント調整 tab 押下時は web-mode-code-indent-offset 等の設定で動いていたが indent-region ではそれと違う値(4)でインデントされていて indent-region を使えずにいた\nhttps://github.com/emacs-lsp/lsp-mode/issues/2915#issuecomment-855156802\nを参考に lsp\u0026ndash;formatting-indent-aliat に web-mode と tsx-ts-mode の設定を追加することで良い感じにインデントできるように調整している\n(with-eval-after-load \u0026#39;lsp-mode (add-to-list \u0026#39;lsp--formatting-indent-alist `(web-mode . web-mode-code-indent-offset)) (add-to-list \u0026#39;lsp--formatting-indent-alist `(tsx-ts-mode . typescript-ts-mode-indent-offset)) (add-to-list \u0026#39;lsp-file-watch-ignored-directories \u0026#34;node_modules\u0026#34;) (add-to-list \u0026#39;lsp-file-watch-ignored-directories \u0026#34;tmp\u0026#34;) (add-to-list \u0026#39;lsp-file-watch-ignored-directories \u0026#34;vendor\u0026#34;) (add-to-list \u0026#39;lsp-file-watch-ignored-directories \u0026#34;hello-friend-ng\u0026#34;) (add-to-list \u0026#39;lsp-file-watch-ignored-directories \u0026#34;ox-hugo\u0026#34;)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/magit/",
	"title": "magit",
	"tags": [],
	"description": "",
	"content": "概要 magit は Emacs の上で Git の色々な操作ができるやつ。結構使いやすいのでオススメなやつ。\nforge を使うと GitHub や GitLab とも連携できてさらに便利、なはず。\nインストール レシピは el-get 本体付属のものをコピーして使ってる。 magit の依存関係に変更があったのでそれに追従するため\nref: https://github.com/mugijiru/.emacs.d/pull/2992\n(:name magit :website \u0026#34;https://github.com/magit/magit#readme\u0026#34; :description \u0026#34;It\u0026#39;s Magit! An Emacs mode for Git.\u0026#34; :type github :pkgname \u0026#34;magit/magit\u0026#34; :branch \u0026#34;main\u0026#34; :minimum-emacs-version \u0026#34;25.1\u0026#34; ;; Note: `git-commit\u0026#39; is shipped with `magit\u0026#39; code itself. ;; Note: `magit-section\u0026#39; is shipped with `magit\u0026#39; code itself. :depends (dash transient with-editor compat seq) :info \u0026#34;docs\u0026#34; :load-path \u0026#34;lisp/\u0026#34; :compile \u0026#34;lisp/\u0026#34; ;; Use the Makefile to produce the info manual, el-get can ;; handle compilation and autoloads on its own. Create an ;; empty autoloads file because magit.el explicitly checks for ;; a file of that name. :build `((\u0026#34;make\u0026#34; ,(format \u0026#34;EMACSBIN=%s\u0026#34; el-get-emacs) \u0026#34;docs\u0026#34;) (\u0026#34;touch\u0026#34; \u0026#34;lisp/magit-autoloads.el\u0026#34;)) :build/berkeley-unix `((\u0026#34;gmake\u0026#34; ,(format \u0026#34;EMACSBIN=%s\u0026#34; el-get-emacs) \u0026#34;docs\u0026#34;) (\u0026#34;touch\u0026#34; \u0026#34;lisp/magit-autoloads.el\u0026#34;)) ;; assume windows lacks make and makeinfo :build/windows-nt (with-temp-file \u0026#34;lisp/magit-autoloads.el\u0026#34; nil)) また依存している with-editor や seq のレシピも用意している\n(:name with-editor :description \u0026#34;Use the Emacsclient as $EDITOR\u0026#34; :type github :pkgname \u0026#34;magit/with-editor\u0026#34; :branch \u0026#34;main\u0026#34; :info \u0026#34;docs\u0026#34; :load-path \u0026#34;lisp/\u0026#34; :compile \u0026#34;lisp/\u0026#34; ;; Use the Makefile to produce the info manual, el-get can ;; handle compilation and autoloads on its own. :build `((\u0026#34;make\u0026#34; ,(format \u0026#34;EMACSBIN=%s\u0026#34; el-get-emacs) \u0026#34;info\u0026#34;)) :build/berkeley-unix `((\u0026#34;gmake\u0026#34; ,(format \u0026#34;EMACSBIN=%s\u0026#34; el-get-emacs) \u0026#34;info\u0026#34;))) (:name seq :description \u0026#34;Sequence manipulation functions\u0026#34; :type elpa :website \u0026#34;https://elpa.gnu.org/packages/seq.html\u0026#34;) そして el-get-bundle でインストールしている\n(el-get-bundle magit) その他設定 ghub を load-path に入れないとうまくいかなかった時があったので load-path に入れてたり、 orgit を入れていたり\n(with-eval-after-load \u0026#39;magit (add-to-list \u0026#39;load-path (expand-file-name \u0026#34;~/.emacs.d/el-get/ghub/lisp\u0026#34;))) (el-get-bundle orgit) なお orgit は recipe を自前で用意している\n(:name orgit :website \u0026#34;https://github.com/magit/orgit\u0026#34; :description \u0026#34;Link to Magit buffers from Org documents.\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;magit/orgit\u0026#34; :depends (compat magit org-mode)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/markdown/",
	"title": "markdown",
	"tags": [],
	"description": "",
	"content": "概要 Markdown を書くための設定。といいつつ markdown-mode を入れてるだけだけども。\n手元でテキストドキュメントを弄るのは org-mode が多いからなあ……\nインストール いつも通り el-get で入れている。\n(el-get-bundle markdown-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/migemo/",
	"title": "migemo",
	"tags": [],
	"description": "",
	"content": "概要 migemo.el は cmigemo などと通信して、日本語入力オフのままローマ字入力をして日本語検索ができるようにするパッケージ。\nこれとても便利で抜け出せない。\nインストール いつも通り el-get でインストール。\n(el-get-bundle migemo) (load \u0026#34;migemo\u0026#34;) load はする必要あるのかわからんけど、そういう設定が既に入ってるのでそのままにしている。\nMac での辞書の位置の指定 Homebrew で cmigemo を入れているのでそれに合わせて辞書の位置を指定している。\n;; Mac (let ((path \u0026#34;/usr/local/share/migemo/utf-8/migemo-dict\u0026#34;)) (if (file-exists-p path) (setq migemo-dictionary path))) Ubuntu での辞書の位置の指定 apt で cmigemo を入れているのでそれに合わせて辞書の位置を指定している。\n;; Ubuntu (let ((path \u0026#34;/usr/share/cmigemo/utf-8/migemo-dict\u0026#34;)) (if (file-exists-p path) (setq migemo-dictionary path))) Manjaro での辞書の位置の指定 yay で cmigemo-git を入れているのでそれに合わせて辞書の位置を指定している。\n;; Manjaro (let ((path \u0026#34;/usr/share/migemo/utf-8/migemo-dict\u0026#34;)) (if (file-exists-p path) (setq migemo-dictionary path))) cmigemo コマンドの PATH 指定 環境で PATH が変わるので which コマンドの結果を migemo-command に設定している。\n(let ((path (s-chomp (shell-command-to-string \u0026#34;which cmigemo\u0026#34;)))) (if (s-ends-with? \u0026#34;not found\u0026#34; path) (message \u0026#34;cmigemo not found\u0026#34;) (setq migemo-command path))) オプション設定 裏側で動くのでうるさくならないように -q を指定しているのと Emacs から叩くから --emacs を指定しているだけ。\n(setq migemo-options \u0026#39;(\u0026#34;-q\u0026#34; \u0026#34;--emacs\u0026#34;)) coding system の指定 Mac と Ubuntu でしか使わないしそれらの環境だと統一で utf-8-unix でいいよねってことでそれを指定している。\n(setq migemo-coding-system \u0026#39;utf-8-unix) 今時なら euc とかにする必要もないだろうしね。\n初期化 以上の設定を入れた上で初期化をしている。\n(migemo-init) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/mocha/",
	"title": "Mocha",
	"tags": ["Deprecated"],
	"description": "",
	"content": "概要 Mocha は JS のテストフレームワークの1つ。 Jest より前はこっちはよく使われてた\nというわけで設定していたのだけど、今はもう使ってない。\nひょっとしたらまた使うことがあるかもしれないのでドキュメントには残しておいて tangle による出力を停止する。\nmocha.el インストール レシピは自前で用意していた\n(:name mocha :description \u0026#34;Emacs mode for running mocha tests\u0026#34; :website \u0026#34;https://github.com/scottaj/mocha.el\u0026#34; :type github :pkgname \u0026#34;scottaj/mocha.el\u0026#34;) そしていつも通り el-get-bundle でインストールしていた\n(el-get-bundle mocha) テスト実行コマンド mocha のテストファイルかどうかを判定してそうだったら mocha としてテストを実行するコマンドを用意していた\n(defun my/mocha-test-file () (interactive) (if my/mocha-enable-p (mocha-test-file))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/mode-line/",
	"title": "mode-line",
	"tags": [],
	"description": "",
	"content": "概要 Emacs のバッファ下部に表示されるモードライン関連の設定をここにまとめている。このメニューの並びとかはどこかで直した方が良さそう。\nhide-mode-line hide-mode-line は mode-line を隠してくれるパッケージ。ここでは neotree-mode-hook で引っ掛けて Neotree では mode-line を隠すように設定している\n(el-get-bundle hlissner/emacs-hide-mode-line) (add-hook \u0026#39;neotree-mode-hook #\u0026#39;hide-mode-line-mode) レシピは自前で用意している\n(:name emacs-hide-mode-line :type github :description \u0026#34;minor mode that hides/masks your modeline.\u0026#34; :pkgname \u0026#34;hlissner/emacs-hide-mode-line\u0026#34; :minimum-emacs-version (24 4)) 他にも mode-line の表示が不要なモードとかってありそうだけど特に思い付かないから今のところ Neotree 専用になっている。\n日時を mode-line では表示しない 今だと i3bar に時計が表示されていていつもそれを見るので mode-line の日時表示は要らないな〜と思ったので非表示にした\n(custom-set-variables \u0026#39;(display-time-24hr-format t)) (display-time-mode -1) 表示していたころの名残りで時計の表示形式は24時間表記の設定。表示する場合、「午前」とか「午後」とかの表示邪魔だしね。\nsmart-mode-line 関連の設定 unused smart-mode-line は mode-line をセクシーな感じにしてくれるパッケージ。というわけで昔入れていたけどもう使ってない。一応コードの残骸があったから一旦残しておく。\n多分アイコン表示周りをゴリゴリ設定するのがだるくなって doom-modeline に乗り換えたんだと思う。\n;; (el-get-bundle smart-mode-line) ;; (defvar sml/no-confirm-load-theme t) ;; (defvar sml/theme \u0026#39;dark) ;; (sml/setup) ;; major-mode ;; (add-hook \u0026#39;emacs-lisp-mode-hook (lambda () (setq mode-name (all-the-icons-fileicon \u0026#34;elisp\u0026#34;)))) ;; (add-hook \u0026#39;enh-ruby-mode-hook (lambda () (setq mode-name (concat \u0026#34;e\u0026#34; (all-the-icons-alltheicon \u0026#34;ruby-alt\u0026#34;))))) ;; (add-hook \u0026#39;ruby-mode-hook (lambda () (setq mode-name (all-the-icons-alltheicon \u0026#34;ruby-alt\u0026#34;)))) ;; (add-hook \u0026#39;vue-mode-hook (lambda () ;; (make-local-variable \u0026#39;mmm-submode-mode-line-format) ;; (setq mmm-submode-mode-line-format \u0026#34;~M:~m\u0026#34;) ;; (make-local-variable \u0026#39;mmm-buffer-mode-display-name) ;; (setq mmm-buffer-mode-display-name \u0026#34;V\u0026#34;))) ;; (add-hook \u0026#39;js-mode-hook (lambda () (setq mode-name \u0026#34;\u0026#34;))) ;; (add-hook \u0026#39;pug-mode-hook (lambda () (setq mode-name (all-the-icons-fileicon \u0026#34;pug\u0026#34;)))) ;; (add-hook \u0026#39;css-mode-hook (lambda () (setq mode-name (all-the-icons-faicon \u0026#34;css3\u0026#34;)))) ;; (add-hook \u0026#39;twittering-mode-hook (lambda () (setq mode-name (all-the-icons-faicon \u0026#34;twitter-square\u0026#34;)))) ;; (add-hook \u0026#39;org-mode-hook (lambda () (setq mode-name (all-the-icons-fileicon \u0026#34;org\u0026#34;)))) diminish diminish は minor-mode の表示をカスタマイズするためのモード。\nこれも昔使ってたけど今は使ってない。というか最近はマイナーモードを mode-line で表示してない。表示しなくなったから要らなくなった感じ。\nインストール・有効化 el-get-bundle で入れて require したら有効になる\n(el-get-bundle diminish) (require \u0026#39;diminish) なおレシピは自前で用意している\n(:name diminish :description \u0026#34;An Emacs package that diminishes the amount of space taken on the mode line by the names of minor modes.\u0026#34; :type github :url \u0026#34;https://github.com/emacsmirror/diminish\u0026#34; :pkgname \u0026#34;emacsmirror/diminish\u0026#34; :features diminish) マクロ定義 各パッケージが読まれた後に指定した表示が設定されるようにするマクロを書いている。\n(defmacro my/diminish (file mode \u0026amp;optional new-name) \u0026#34;https://github.com/larstvei/dot-emacs/blob/master/init.org\u0026#34; `(with-eval-after-load ,file (diminish ,mode ,new-name))) https://github.com/larstvei/dot-emacs/blob/master/init.org に書かれているのを流用しただけであるはずだが、リンク先にその記述が見当たらないな……。\nマイナーモード毎の表示指定 上で用意したマクロを用いて各マイナーモード毎の設定を行っていた。今は使ってないので全部コメントアウトしている\n;; (my/diminish \u0026#34;git-gutter\u0026#34; \u0026#39;git-gutter-mode (all-the-icons-octicon \u0026#34;git-compare\u0026#34;)) ;; (my/diminish \u0026#34;yasnippet\u0026#34; \u0026#39;yas-minor-mode \u0026#34; Ys\u0026#34;) ;; (my/diminish \u0026#34;whitespace\u0026#34; \u0026#39;whitespace-mode \u0026#34;◽\u0026#34;) ;; (my/diminish \u0026#34;whitespace\u0026#34; \u0026#39;global-whitespace-mode \u0026#34;◽\u0026#34;) ;; (my/diminish \u0026#34;tempbuf\u0026#34; \u0026#39;tempbuf-mode \u0026#34;\u0026#34;) ;; (my/diminish \u0026#34;flycheck\u0026#34; \u0026#39;flycheck-mode \u0026#34;\u0026#34;) ;; (my/diminish \u0026#34;zoom\u0026#34; \u0026#39;zoom-mode \u0026#34;\u0026#34;) ;; (my/diminish \u0026#34;rainbow\u0026#34; \u0026#39;rainbow-mode \u0026#34;🌈\u0026#34;) ;; (my/diminish \u0026#34;projectile-rails\u0026#34; \u0026#39;projectile-rails-mode \u0026#34;🛤\u0026#34;) ;; (my/diminish \u0026#34;company\u0026#34; \u0026#39;company-mode \u0026#34;\u0026#34;) ;; (my/diminish \u0026#34;ElDoc\u0026#34; \u0026#39;eldoc-mode \u0026#34;\u0026#34;) 結構頑張ったけど絵文字周りで思うような表示にならなかったりして最終的にはマイナーモードを mode-line に表示しないようになっている。\n使ってる minor-mode どうやって把握したりしたらいいんだろうね。ま、表示されなくてもなんとなくで把握しているから、困ってはいないんだけど。\ndoom-modeline doom-modeline は Emacs の mode-line を装飾するパッケージの1つ。結構スッキリした見た目になるので気に入ってる。\nインストール el-get のレシピは自前で用意している\n(:name doom-modeline :website \u0026#34;https://github.com/seagle0128/doom-modeline\u0026#34; :description \u0026#34;A fancy and fast mode-line which was from DOOM Emacs, but it\u0026#39;s more powerful and much faster.\u0026#34; :depends (shrink-path compat) :type github :pkgname \u0026#34;seagle0128/doom-modeline\u0026#34;) 依存している shrink-path と nerd-icons も自前でレシピを用意している\n(:name shrink-path :website \u0026#34;https://gitlab.com/bennya/shrink-path.el\u0026#34; :description \u0026#34;Small utility functions that allow for fish-style trunctated directories in eshell and for example modeline.\u0026#34; :depends (dash f s) :type git :url \u0026#34;https://gitlab.com/bennya/shrink-path.el.git\u0026#34;) (:name nerd-icons :website \u0026#34;https://github.com/rainstormstudio/nerd-icons.el\u0026#34; :description \u0026#34;A Library for Nerd Font icons.\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;rainstormstudio/nerd-icons.el\u0026#34;) そして以下でインストール\n(el-get-bundle doom-modeline) 有効化 (doom-modeline-mode 1) VCS 用表示の長さ変更 デフォルトだと 12 なんだけどそれだと短かくて何のブランチかよくわからんので 30 まえのばしている。\n(setq doom-modeline-vcs-max-length 30) バッテリー残量表示 これは doom-modeline 専用の設定ではないけど doom-modeline で見た目をカッコよくしているのでこっちに設定を書いている。\n(display-battery-mode 1) アイコン表示 nerd-icons に依存しているのでそれの設定もここに書いておく\n(el-get-bundle nerd-icons) (require \u0026#39;nerd-icons) ;; if nerd-icons are not installed, run M-x nerd-icons-install-fonts if nerd-icons are not installed, run M-x nerd-icons-install-fonts と書いているように nerd-icons をインストールしていない場合は nerd-icons-install-fonts を叩いてインストールしてあげないといけない\nその他 doom-modeline-github を t にしたら GitHub の通知数も表示されるらしいがちょっと試しに t にしているけどどうも表示されない。\nあとはメジャーモード名はアイコンの方があるから消したいな。 doom-modeline-def-modeline で自分用に作れば良さそうな雰囲気はある\nその他 多分 mode-line 周りはもうちょっと整理した方が設定は読み易いんだろうなという気がしている\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/multiple-cursors/",
	"title": "multiple-cursors",
	"tags": [],
	"description": "",
	"content": "概要 multiple-cursors はカーソルを増やせるやつ。複数箇所を同時に編集できるようになって便利。\nインストール el-get からインストールしている\n(el-get-bundle multiple-cursors) キーバインド キーバインドは別途定義している。もうちょっと真面目に定義したい\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/neotree/",
	"title": "Neotree",
	"tags": ["replacement"],
	"description": "",
	"content": "概要 Neotree は Emacs でフォルダのツリー表示ができるやつ。メンテは活発じゃないようなので、その内乗り換えたい。\nレシピ Neotree でメンテされているのは dev ブランチだけど el-get の公式のレシピでは master ブランチを見ているので自前で recipe を用意してそれを使っている。\n(:name emacs-neotree-dev :website \u0026#34;https://github.com/jaypei/emacs-neotree\u0026#34; :description \u0026#34;An Emacs tree plugin like NerdTree for Vim.\u0026#34; :type github :branch \u0026#34;dev\u0026#34; :pkgname \u0026#34;jaypei/emacs-neotree\u0026#34;) インストール 上に書いたレシピを使ってインストールしている。\n(el-get-bundle emacs-neotree-dev) 使わなくなったコード 元々設定していたが、 counsel-projectile を使ってると projectile-switch-project-action を設定していても反映されず意味がないのに気付いたので使わなくなった\nhttps://github.com/mugijiru/.emacs.d/pull/183/files#r541843206\n(setq projectile-switch-project-action \u0026#39;neotree-projectile-action) テーマの設定 GUI で起動している時はアイコン表示しそうでない場合は ▾ とかで表示する\n(setq neo-theme (if (display-graphic-p) \u0026#39;icons \u0026#39;arrow)) のだけど、実際に今使ってるやつだともっとグラフィカルな表示なので all-the-icons の設定で上書きしている気がするので要確認\nmajor-mode-hydra いちいちキーバインドを覚えてられないので major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。\nとはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define neotree-mode (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-octicon \u0026#34;list-unordered\u0026#34;) \u0026#34; Neotree\u0026#34;)) (\u0026#34;Nav\u0026#34; ((\u0026#34;u\u0026#34; neotree-select-up-node \u0026#34;Up\u0026#34;) (\u0026#34;g\u0026#34; neotree-refresh \u0026#34;Refresh\u0026#34;) (\u0026#34;Q\u0026#34; neotree-hide \u0026#34;Hide\u0026#34;)) \u0026#34;File\u0026#34; ((\u0026#34;a\u0026#34; neo-open-file-ace-window \u0026#34;Ace\u0026#34;) (\u0026#34;N\u0026#34; neotree-create-node \u0026#34;Create\u0026#34;) (\u0026#34;R\u0026#34; neotree-rename-node \u0026#34;Rename\u0026#34;) (\u0026#34;C\u0026#34; neotree-copy-node \u0026#34;Copy\u0026#34;) (\u0026#34;D\u0026#34; neotree-delete-node \u0026#34;Delete\u0026#34;) (\u0026#34;SPC\u0026#34; neotree-quick-look \u0026#34;Look\u0026#34;) ;; (\u0026#34;d\u0026#34; neo-open-dired \u0026#34;Dired\u0026#34;) ;; (\u0026#34;O\u0026#34; neo-open-dir-recursive \u0026#34;Recursive\u0026#34;) ) \u0026#34;Toggle\u0026#34; ((\u0026#34;z\u0026#34; neotree-stretch-toggle \u0026#34;Size\u0026#34; :toggle (not (neo-window--minimize-p))) (\u0026#34;h\u0026#34; neotree-hidden-file-toggle \u0026#34;Hidden file\u0026#34; :toggle neo-buffer--show-hidden-file-p))))) キーバインド ナビゲーション Key 効果 u 上のノードに移動 g 再描画 Q Neotree を隠す ファイル操作 Key 効果 a ファイルを開く。その際に ace-window で開く window を指定する N 新しいノードを作る R ノードの名前を変える C ノードのコピー D ノードの削除 SPC クイックルック Toggle Key 効果 z Neotree のサイズを大きくしたり小さくしたり h 隠しファイルを表示したり隠したり "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/noflet/",
	"title": "noflet",
	"tags": [],
	"description": "",
	"content": "概要 ローカル定義の関数を用意するためのパッケージ。\nref: http://emacs.rubikitch.com/noflet/\nテストする際に副作用を持つ関数を置き換えるのに便利。例えば https://github.com/mugijiru/emacs-kibela/pull/14/commits/da54ad30473d65539efd884f30693e1d4707067b では noflet に差し替えてテストしている。\nmocker.el との使い分け mocker.el は関数を stub/mock するのには悪くないのだけどその関数が副作用を持っていて、その副作用の結果を反映した状態を実現するのには向いてなさそうなので emacs-kibela のテストでは noflet を採用したという経緯がある\nインストール noflet は el-get 本体の recipe として登録されているので el-get-bundle で入れるだけで良い\n(el-get-bundle noflet) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/notify-slack/",
	"title": "notify-slack",
	"tags": [],
	"description": "",
	"content": "概要 Emacs から Slack に通知するための自作関数。実体は同じく自作の外部コマンドを叩いているだけである。\n何に使ってるかというと org-clock-in, org-clock-out の時に作業の開始と終了を分報チャンネルに投稿しているだけである。作業の可視化である。\n実装 分報チャンネル設定用の変数 通知先のチャンネル名を格納する変数が必要なので defvar で定義しておく\n(defvar my/notify-slack-times-channel nil) 送信するコマンド start-process を使って外部コマンドを叩いている。\n(defun my/notify-slack (channel text) (if my/notify-slack-enable-p (start-process \u0026#34;my/org-clock-slack-notifier\u0026#34; \u0026#34;*my/org-clock-slack-notifier*\u0026#34; \u0026#34;my-slack-notifier\u0026#34; channel text))) my/notify-slack-enable-p という変数が nil だと大分コマンドが実行されないようになっている。\nSlack 連携を Toggle するコマンド 連携したい時としたくない時があるので送信したりしなかったりを切り替えられるコマンドを用意している。\n中身は何をしているかというと上に書いた my/notify-slack-enable-p という変数を切り替えているだけ。\n(defun my/notify-slack-toggle () (interactive) (if my/notify-slack-enable-p (setq my/notify-slack-enable-p nil) (setq my/notify-slack-enable-p t))) 分報チャンネル投稿関数 「分報チャンネル投稿関数」としているけどデフォルト投稿先に投稿するための関数というような扱いの関数。\n単純に前出の my/notify-slack 関数の第一引数に my/notify-slack-times-channel という変数を設定してそのチャンネルに向けて投稿するだけ。\n(defun my/notify-slack-times (text) (if my/notify-slack-times-channel (my/notify-slack my/notify-slack-times-channel text))) 設定 あまり見せたくない設定ファイルを別ファイルに分離しているのでそれを読み出している。\n内部では my/notify-slack-times-channel という変数を設定しているだけじゃないだろうか。職場の Slack のチャンネルを指定しているので隠したいという意図があった。\nそのうち .authinfo.gpg に移動しようと思ってる。\n(my/load-config \u0026#34;my-notify-slack-config\u0026#34;) ちなみに my/load-config はこの手の設定ファイルを読み出すために使っている自作関数である。 load と同じように使えば大体 OK。むしろ load の引数ちゃんと使えばこの関数要らない説まである。\nそして起動直後は連携を ON にしたいので my/notify-slack-enable-p を ON にしている\n(setq my/notify-slack-enable-p t) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/openai/",
	"title": "openai",
	"tags": [],
	"description": "",
	"content": "概要 OpenAI.el は OpenAI などの API を使うための Emacs Lisp ライブラリ。直接使うよりは、これを使ったアプリを開発するために使うものなのかなと思う。\n最近は特に使ってないけどとりあえず設定ファイルがあるのでドキュメントにも反映しておく\nインストール 例によってレシピは el-get 本体にはなので自前で用意\n(:name emacs-openai :website \u0026#34;https://github.com/emacs-openai/openai\u0026#34; :description \u0026#34;Elisp library for the OpenAI API.\u0026#34; :type github :branch \u0026#34;master\u0026#34; :pkgname \u0026#34;emacs-openai/openai\u0026#34; :depends (request tblui)) 依存している tblui も el-get 本体にはレシピがないのでこれも自前で用意\n(:name tblui :website \u0026#34;https://github.com/Yuki-Inoue/tblui.el\u0026#34; :description \u0026#34;Define tabulated-list based UI easily.\u0026#34; :type github :branch \u0026#34;master\u0026#34; :pkgname \u0026#34;Yuki-Inoue/tblui.el\u0026#34; :depends (dash magit-popup tablist)) そして el-get-bundle でインストール\n(el-get-bundle emacs-openai) API キーなどの設定 authinfo で管理してそこから読み取るよういしている\n(setq openai-user (plist-get (nth 0 (auth-source-search :host \u0026#34;api.openai.com\u0026#34;)) :user)) (setq openai-key (funcall (plist-get (nth 0 (auth-source-search :host \u0026#34;api.openai.com\u0026#34;)) :secret))) その他 今は使ってないので説明は雑に。\nAPI 叩いて質問ができるようにしたり、補完して続きを適当に書いてもらったりするような関数を定義している。どこかのものを参考にしたはずだけど覚えてないな……\n(defvar-local my/openai-result nil) (defun my/openai-completion-from-prompt (input) (interactive \u0026#34;sText: \u0026#34;) (openai-completion input (lambda (data) (let* ((choices (openai--data-choices data)) (result (openai--get-choice choices))) (message \u0026#34;result: %s\u0026#34; result))) :max-tokens 2000)) (defun my/openai-observe (buf end) (cond (my/openai-result (save-current-buffer (set-buffer (get-buffer buf)) (goto-char end) (insert my/openai-result) (setq my/openai-result nil) (my/openai-stop-observe))) (t nil))) (defvar my/openai-observe-timer nil) (defun my/openai-start-observe (buf end) (setq my/openai-observe-timer (run-with-idle-timer 0.5 t \u0026#39;my/openai-observe buf end))) (defun my/openai-stop-observe () (cancel-timer my/openai-observe-timer)) (defun my/openai-completion-from-region (begin end) (interactive \u0026#34;r\u0026#34;) (my/openai-start-observe (current-buffer) end) (openai-completion (buffer-substring-no-properties begin end) (lambda (data) (let* ((choices (openai--data-choices data)) (result (openai--get-choice choices))) (setq my/openai-result result))) :max-tokens 4000) (deactivate-mark t)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-journal/",
	"title": "org-journal",
	"tags": [],
	"description": "",
	"content": "概要 org-journal は org-mode で日記を書くためのモードっぽい。\nデフォルトに近い設定だと `M-x org-journal-new-entry` でその日の日記ファイルを生成してその時刻を Headline を用意するようになってる。\n一度書いた後にまた同じコマンドを叩くと以前に書いた記事を開いて新しい時刻の Headline を用意するのでなんか書きたくなったら雑に書いておくと、時系列順に並んでいくので便利かもしれない。まだ使ってないから本当に便利かは分からない\nインストール これは el-get にはレシピがないようなので自前で用意している\n(:name org-journal :website \u0026#34;https://github.com/bastibe/org-journal\u0026#34; :description \u0026#34;Functions to maintain a simple personal diary / journal in Emacs.\u0026#34; :type github :pkgname \u0026#34;bastibe/org-journal\u0026#34;) そして el-get-bundle でインストール\n(el-get-bundle org-journal) また refile 先の候補設定 で org-journal--get-entry-path という内部関数を使ってしまっていてそれが読み込まれていないと困るので、ここで require まで行っている\n(require \u0026#39;org-journal) agenda のスコープ設定用関数 org-clock-report では前日分も target に入れてほしいのでそれの :scope に指定するための関数を自前で用意している\n(defun my/org-agenda-scope-with-yesterday-journal () (let* ((agenda-files (org-agenda-files t)) (24-hours-ago (* -60 60 24)) (yesterday (time-add (current-time) 24-hours-ago)) (yesterday-string (format-time-string \u0026#34;%Y%m%d\u0026#34; yesterday)) (yesterday-journal-file-path (concat org-journal-dir yesterday-string \u0026#34;.org\u0026#34;)) (files (append `(,yesterday-journal-file-path) agenda-files))) (org-add-archive-files files))) 設定 (custom-set-variables \u0026#39;(org-journal-dir (concat org-directory \u0026#34;journal/\u0026#34;)) \u0026#39;(org-journal-file-format \u0026#34;%Y%m%d.org\u0026#34;) \u0026#39;(org-journal-date-format \u0026#34;%d日(%a)\u0026#34;) \u0026#39;(org-journal-enable-agenda-integration t) \u0026#39;(org-journal-carryover-items \u0026#34;TODO={TODO\\\\|DOING\\\\|WAIT}\u0026#34;)) hook org-journal ファイルを新しく作る度にそのファイルを refile target で扱って欲しいので hook で org-refile-targets を設定し直すようにしている\n(with-eval-after-load \u0026#39;org-journal (add-to-list \u0026#39;org-journal-after-header-create-hook \u0026#39;my/reset-org-refile-targets)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/org-mode/org-roam/",
	"title": "org-roam",
	"tags": [],
	"description": "",
	"content": "概要 org-roam は記事同士のリンク周りを強化して、検索機能を提供したり繋がりを可視化したりしてくれるやつ。繋がりを可視化することでアイデア同士の結び付きを見つけたりとかに使えるっぽい\n内部的には SQLite を使ってリンクを cache しているっぽい。\nインストール el-get 本体ではレシピを提供していないのでとりあえず自前で用意している\n(:name org-roam :website \u0026#34;https://www.orgroam.com/\u0026#34; :description \u0026#34;A plain-text knowledge management system.\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;org-roam/org-roam\u0026#34; :depends (dash emacsql magit org-mode)) そしてそれを el-get-bundle でインストールしている\n(el-get-bundle org-roam) 設定 既存の org ファイル全てを対象にすると最初の DB 構築で無限に時間がかかるので org フォルダの下に roam というフォルダを掘ってその中だけを対象としている\n(custom-set-variables \u0026#39;(org-roam-directory (file-truename (concat org-directory \u0026#34;roam/\u0026#34;)))) そして自動的に SQLite3 と同期するように自動同期の設定を入れている\n(org-roam-db-autosync-mode 1) キーバインド とりあえず忘れても使えるように pretty-hydra で操作できるように設定している\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define org-roam-hydra (:separator \u0026#34;-\u0026#34; :color teal :foreign-key warn :title (concat (all-the-icons-material \u0026#34;graphic_eq\u0026#34;) \u0026#34; Roam\u0026#34;) :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Node\u0026#34; ((\u0026#34;f\u0026#34; org-roam-node-find \u0026#34;Find\u0026#34;) (\u0026#34;r\u0026#34; org-roam-node-random \u0026#34;Random\u0026#34;)) \u0026#34;DB\u0026#34; ((\u0026#34;S\u0026#34; org-roam-db-sync \u0026#34;Sync\u0026#34;) (\u0026#34;C\u0026#34; org-roam-db-clear-all \u0026#34;Clear\u0026#34;))))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/origami/",
	"title": "origami",
	"tags": [],
	"description": "",
	"content": "概要 origami はコードの折り畳み機能を提供するやつ。メジャーな言語は大体サポートしている感じ。大きいファイルを見る時に便利。\nインストール el-get 公式にはレシピがないので自前でレシピを用意している。\n(:name origami :website \u0026#34;https://github.com/elp-revive/origami.el\u0026#34; :description \u0026#34;A text folding minor mode for Emacs.\u0026#34; :type github :pkgname \u0026#34;elp-revive/origami.el\u0026#34; :depends (s dash)) そしてそれを使ってインストール\n(el-get-bundle origami) キーバインド origami-mode-map では以下のように動くように設定している。\nKey 効果 \u0026lt;backtab\u0026gt; 再帰的に折り畳んだり開いたりするやつ。org-mode の fold と似た感じ M-\u0026lt;backtab\u0026gt; そのノードだけ表示する (with-eval-after-load \u0026#39;origami (define-key origami-mode-map (kbd \u0026#34;\u0026lt;backtab\u0026gt;\u0026#34;) \u0026#39;origami-recursively-toggle-node) (define-key origami-mode-map (kbd \u0026#34;M-\u0026lt;backtab\u0026gt;\u0026#34;) \u0026#39;origami-show-only-node)) ただこれだけだと多分足りないので Hydra で色々定義している。\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define origami-hydra (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title \u0026#34;Origami\u0026#34;) (\u0026#34;Node\u0026#34; ((\u0026#34;o\u0026#34; origami-open-node \u0026#34;Open\u0026#34;) (\u0026#34;c\u0026#34; origami-close-node \u0026#34;Close\u0026#34;) (\u0026#34;s\u0026#34; origami-show-node \u0026#34;Show\u0026#34;) (\u0026#34;t\u0026#34; origami-toggle-node \u0026#34;Toggle\u0026#34;) (\u0026#34;S\u0026#34; origami-forward-toggle-node \u0026#34;Foward toggle\u0026#34;) (\u0026#34;r\u0026#34; origami-recursively-toggle-node \u0026#34;Recursive toggle\u0026#34;)) \u0026#34;All\u0026#34; ((\u0026#34;O\u0026#34; origami-open-all-nodes \u0026#34;Open\u0026#34;) (\u0026#34;C\u0026#34; origami-close-all-nodes \u0026#34;Close\u0026#34;) (\u0026#34;T\u0026#34; origami-toggle-all-nodes \u0026#34;Toggle\u0026#34;)) \u0026#34;Move\u0026#34; ((\u0026#34;n\u0026#34; origami-next-fold \u0026#34;Next\u0026#34;) (\u0026#34;p\u0026#34; origami-previous-fold \u0026#34;Previous\u0026#34;)) \u0026#34;Undo/Redo\u0026#34; ((\u0026#34;/\u0026#34; origami-undo \u0026#34;Undo\u0026#34;) (\u0026#34;?\u0026#34; origami-redo \u0026#34;Redo\u0026#34;) (\u0026#34;X\u0026#34; origami-reset \u0026#34;Reset\u0026#34;))))) この設定は jk で起動する Hydra から呼び出せるようにしている\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/pdf-tools/",
	"title": "pdf-tools",
	"tags": [],
	"description": "",
	"content": "概要 pdf-tools は PDF を読む時にいい感じにしてくれるやつ。\nインストール これは el-get 本体にレシピがあるので、単純にそのまま入れている\n(el-get-bundle pdf-tools) 設定 PDF を開いたら即使えるようにするため pdf-loader-install を実行している\n(pdf-loader-install) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/plantuml-mode/",
	"title": "plantuml-mode",
	"tags": [],
	"description": "",
	"content": "概要 plantuml-mode は PlantUML という、テキストだけで UML 図などが描けるツール用のモード。\nインストール el-get のレシピは自前で用意。\n(:name plantuml-mode :description \u0026#34;Major mode for PlantUML.\u0026#34; :type github :branch \u0026#34;develop\u0026#34; :pkgname \u0026#34;skuro/plantuml-mode\u0026#34; :post-init (let ((plantuml-url \u0026#34;http://sourceforge.net/projects/plantuml/files/plantuml.jar/download\u0026#34;) (plantuml-jar (expand-file-name \u0026#34;plantuml.jar\u0026#34; default-directory))) (when (not (file-exists-p plantuml-jar)) (url-copy-file plantuml-url plantuml-jar))) :prepare (setq plantuml-jar-path (expand-file-name \u0026#34;plantuml.jar\u0026#34; default-directory))) そして el-get で入れてる\n(el-get-bundle plantuml-mode) 設定 実行モードは 'jar を指定している。デフォルトは 'server なんだけどオフラインの時も使いたいししね。\n(setq plantuml-default-exec-mode \u0026#39;jar) el-get でインスコすると jar ファイルも自動で拾って来て plantuml-mode と同じディレクトリに設置して plantuml-jar-path も通してくれるからそっち使う方が便利だしね。\nその他 最新の develop ブランチだとインデントを調整できる機能が入っているので乗り換えたいけどそのためには el-get のレシピを書いてあげる必要がありそうで放置している。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/posframe/",
	"title": "posframe",
	"tags": [],
	"description": "",
	"content": "概要 posframe は child frame を表示させるためのパッケージ。 Emacs のど真ん中に表示したり、今あるカーソル位置のすぐそばに出したりできる。\nivy なんかを使う時に ivy-posframe をど真ん中に出すと、いつもそこに表示されるし真ん中なの視線移動が少なくて済むし ddskk-posframe なんかで変換候補をカーソル位置のそばに出て来るので一般的な日本語変換ソフトと同様にこれまた視線移動が少なくて便利。\nという感じで色々なものの拡張として使わているやつ。\nインストール いつも通り el-get で入れているだけ。\n(el-get-bundle posframe) こいつ自体には特に設定を入れてない。というか設定項目自体2個しか存在していない。\nま、こいつ単体で使うものでもないしね。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/projectile/",
	"title": "projectile",
	"tags": [],
	"description": "",
	"content": "概要 projectile はプロジェクト内のファイルを検索したりするのに便利なパッケージ\nインストール いつも通り el-get からインストールする\n(el-get-bundle projectile) 有効化 このあたりで有効化しておいている。この順序に意味があったかは忘れた……。\n(projectile-mode) 無視リスト 普段 Rails ばっかりやってるのでそれ関係のものを無視リストに入れている。けどあんまりメンテしてない。\n無視するディレクトリ (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;tmp\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;.tmp\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;vendor\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;.sass-cache\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;coverage\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;cache\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;log\u0026#34;) node_modules もここに突っ込んでも良いかもしれない。\n無視するファイル (add-to-list \u0026#39;projectile-globally-ignored-files \u0026#34;gems.tags\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-files \u0026#34;project.tags\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-files \u0026#34;manifest.json\u0026#34;) tags ファイルは昔は使っていたけど、最近は dumb-jump が優秀なのと、面倒で使ってないのでそろそろ gems.tags と project.tags は不要かもしれない。\nivy/counsel との連携 上の方で helm との連携処理を入れていたが今は大体 ivy に乗り換えているので ivy 連携もしている。\n(setq projectile-completion-system \u0026#39;ivy) (el-get-bundle counsel-projectile) counsel-projectile はいくつかの絞り込み処理を提供してくれて便利。それでも足りなかったら自前で何か作ることになるのかなと思っている。\nキーバインド デフォルトでいくつかのキーバインドが用意されてるようだけどそんなものさっぱり覚えられないのでとりあえずいくつかを Hydra で叩けるようにしている\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define projectile-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;Projectile\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;File\u0026#34; ((\u0026#34;f\u0026#34; counsel-projectile-find-file \u0026#34;Find File\u0026#34;) (\u0026#34;d\u0026#34; counsel-projectile-find-dir \u0026#34;Find Dir\u0026#34;) (\u0026#34;r\u0026#34; projectile-recentf \u0026#34;Recentf\u0026#34;)) \u0026#34;Edit\u0026#34; ((\u0026#34;R\u0026#34; projectile-replace \u0026#34;Replace\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;p\u0026#34; (counsel-projectile-switch-project \u0026#39;neotree-dir) \u0026#34;Switch Project\u0026#34;))))) Key 効果 f プロジェクト内のファイルを検索 d プロジェクト内のフォルダを検索 r プロジェクト内で最近触ったファイルのリスト表示 p 別のプロジェクトに切り替え projectile-find-implementation-or-test projectile-replace projectile-replace-regxp あたりも使えるようにするともしかしたら便利かもしれない。あとは counsel-projectile-grep とかの類か。\nその他 基本的に Rails のプロジェクトをやっているので projectile-rails をベースにいつも触ってるので projectile そのものはあまり弄ってないのであった\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/rails/",
	"title": "rails",
	"tags": [],
	"description": "",
	"content": "概要 Rails 開発関係だけど Ruby 開発とはちょっと違う設定をここに書いている。\n関連パッケージのインストール テンプレートエンジンには haml を使っているので haml-mode を入れていてファイルナビゲーションには projectile の拡張である projectile-rails を利用している。\n(el-get-bundle haml-mode) (el-get-bundle projectile-rails) (projectile-rails-global-mode 1) projectile-rails 用のコマンド追加 自身のプロジェクトだと少しナビゲーション用のコマンドが不足していたので projectile-rails の実装を参考にコマンドを追加している\nTS/TSX Finder client に格納しているフロントエンドのファイルを検索するコマンド\n(defun my/projectile-rails-find-typescript () \u0026#34;Find a TS/TSX files.\u0026#34; (interactive) (projectile-rails-find-resource \u0026#34;ts/tsx: \u0026#34; \u0026#39;((\u0026#34;client/\u0026#34; \u0026#34;\\\\(.+\\\\.tsx?\\\\)$\u0026#34;)) \u0026#34;client/${filename}\u0026#34;)) TS/TSX test files Finder spec/javascript に格納しているフロントエンドのテストファイルを検索するコマンド\n(defun my/projectile-rails-find-typescript-spec () \u0026#34;Find a TS/TSX test files.\u0026#34; (interactive) (projectile-rails-find-resource \u0026#34;ts/tsx spec: \u0026#34; \u0026#39;((\u0026#34;spec/javascripts/\u0026#34; \u0026#34;\\\\(.+\\\\.spec.tsx?\\\\)$\u0026#34;)) \u0026#34;spec/javascripts/${filename}\u0026#34;)) キーバインド もちろん基本的にコマンドなんて覚えられないのでいつも通り Hydra を定義して大体キーバインドは忘れている。\nなおこの Hydra は Rails のファイルを開いている時には C-c r で起動するようにしている。これは通常のセットアップで prefix としてこう設定するといいよ、みたいに書かれているのを流用している。 https://github.com/asok/projectile-rails#keymap-prefix\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define pretty-hydra-projectile-rails-find (:separator \u0026#34;-\u0026#34; :color blue :foreign-keys warn :title \u0026#34;Projectile Rails\u0026#34; :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Current\u0026#34; ((\u0026#34;M\u0026#34; projectile-rails-find-current-model \u0026#34;Current model\u0026#34;) (\u0026#34;V\u0026#34; projectile-rails-find-current-view \u0026#34;Current view\u0026#34;) (\u0026#34;C\u0026#34; projectile-rails-find-current-controller \u0026#34;Current controller\u0026#34;) (\u0026#34;H\u0026#34; projectile-rails-find-current-helper \u0026#34;Current helper\u0026#34;) (\u0026#34;P\u0026#34; projectile-rails-find-current-spec \u0026#34;Current spec\u0026#34;) (\u0026#34;Z\u0026#34; projectile-rails-find-current-serializer \u0026#34;Current serializer\u0026#34;)) \u0026#34;App\u0026#34; ((\u0026#34;m\u0026#34; projectile-rails-find-model \u0026#34;Model\u0026#34;) (\u0026#34;v\u0026#34; projectile-rails-find-view \u0026#34;View\u0026#34;) (\u0026#34;c\u0026#34; projectile-rails-find-controller \u0026#34;Controller\u0026#34;) (\u0026#34;h\u0026#34; projectile-rails-find-helper \u0026#34;Helper\u0026#34;) (\u0026#34;@\u0026#34; projectile-rails-find-mailer \u0026#34;Mailer\u0026#34;) (\u0026#34;!\u0026#34; projectile-rails-find-validator \u0026#34;Validator\u0026#34;) ;; (\u0026#34;y\u0026#34; projectile-rails-find-layout \u0026#34;Layout\u0026#34;) (\u0026#34;z\u0026#34; projectile-rails-find-serializer \u0026#34;Serializer\u0026#34;)) \u0026#34;Assets\u0026#34; ((\u0026#34;j\u0026#34; projectile-rails-find-javascript \u0026#34;Javascript\u0026#34;) ;; (\u0026#34;w\u0026#34; projectile-rails-find-component) (\u0026#34;x\u0026#34; my/projectile-rails-find-typescript \u0026#34;TS/TSX\u0026#34;) (\u0026#34;X\u0026#34; my/projectile-rails-find-typescript-spec \u0026#34;TS/TSX spec\u0026#34;) (\u0026#34;s\u0026#34; projectile-rails-find-stylesheet \u0026#34;CSS\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;n\u0026#34; projectile-rails-find-migration \u0026#34;Migration\u0026#34;) (\u0026#34;r\u0026#34; projectile-rails-find-rake-task \u0026#34;Rake task\u0026#34;) (\u0026#34;i\u0026#34; projectile-rails-find-initializer \u0026#34;Initializer\u0026#34;) (\u0026#34;l\u0026#34; projectile-rails-find-lib \u0026#34;Lib\u0026#34;) (\u0026#34;p\u0026#34; projectile-rails-find-spec \u0026#34;Spec\u0026#34;) (\u0026#34;t\u0026#34; projectile-rails-find-locale \u0026#34;Translation\u0026#34;)) \u0026#34;Single Files\u0026#34; ((\u0026#34;R\u0026#34; projectile-rails-goto-routes \u0026#34;routes.rb\u0026#34;) (\u0026#34;G\u0026#34; projectile-rails-goto-gemfile \u0026#34;Gemfile\u0026#34;) (\u0026#34;D\u0026#34; projectile-rails-goto-schema \u0026#34;schema.rb\u0026#34;)))) (define-key projectile-rails-mode-map (kbd \u0026#34;C-c r\u0026#34;) \u0026#39;pretty-hydra-projectile-rails-find/body)) Key 効果 備考 M 現在のファイルに関連する Model を開く V 現在のファイルに関連する View を開く キーが Vue ファイル検索とかぶってしまっていて現在使えない C 現在のファイルに関連する Controller を開く H 現在のファイルに関連する Helper を開く P 現在のファイルに関連する Spec を開く Z 現在のファイルに関連する Serializer を開く ActiveModelSerializer を使ってるプロジェクトがある m Model ファイルを検索する v View ファイルを検索する c Controller ファイルを検索する h Helper ファイルを検索する a ActiveAdmin のファイルを検索する f Form Object ファイルを検索する @ ActionMailer ファイルを検索する V Vue の単一ファイルコンポーネントファイルを検索する J Webpacker 管理の JS ファイルを検索する u Uploader ファイルを検索する ! Validator ファイルを検索する z Serializer ファイルを検索する j assets 配架の JS ファイルを検索する s SCSS ファイルを検索する n migration ファイルを検索する r rake ファイルを検索する i config/initializers 以下のファイルを検索する l lib 以下のファイルを検索する p rspec ファイルを検索する t I18n の翻訳ファイルを検索する R routes.rb を開く G Gemfile を開く D Schema.rb を開く "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/react-js/",
	"title": "React.js",
	"tags": [],
	"description": "",
	"content": "概要 React.js を書くための設定をここにまとめている\ndap-mode Debug Adapter Protocol をサポートするモード。入れておいた方がきっとデバッグしやすいんだろうということで入れている。\nその際に el-get のレシピは自前で用意している\n(:name dap-mode :description \u0026#34;Debug Adapter Protocol mode\u0026#34; :website \u0026#34;https://github.com/emacs-lsp/dap-mode\u0026#34; :type github :pkgname \u0026#34;emacs-lsp/dap-mode\u0026#34; :depends (bui dash f lsp-mode lsp-treemacs tree-mode posframe s lsp-docker)) また依存している lsp-docker と tree-mode 用のレシピも用意している\n(:name lsp-docker :description \u0026#34;lsp-mode uses lsp-docker to run language servers using in containers\u0026#34; :website \u0026#34;https://github.com/emacs-lsp/lsp-docker\u0026#34; :type github :pkgname \u0026#34;emacs-lsp/lsp-docker\u0026#34; :depends (dash lsp-mode f yaml ht)) (:name tree-mode :website \u0026#34;https://github.com/emacsorphanage/tree-mode\u0026#34; :description \u0026#34;A mode to manage tree widgets\u0026#34; :type github :pkgname \u0026#34;emacsorphanage/tree-mode\u0026#34;) lsp-mode の仲間なので、本当はそっち側で入れるようにした方が良さそうだけどひとまず React のために入れているので React 用の設定ファイルに書いている。\n(el-get-bundle dap-mode) 同時に treemacs や lsp-treemacs も入ってくる罠がある。 Neotree 使ってるからちょっとアレだなあ。いずれ乗り換えようとはしていたけども。\nweb-mode とりあえず tsx を弄る上では web-mode が良いという話もあるので入れておく。\n(el-get-bundle web-mode) メジャーモードの紐付け jsx/tsx ファイルを開いた時には web-mode で動いてほしいので auto-mode-alist で関連付けをする\n(add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.tsx\u0026#34; . tsx-ts-mode)) 自動フォーマット hook の用意 tsx の保存時に自動でフォーマットしてほしいのでそれ用に hook を追加\n(defun my/tsx-auto-fix-hook () (when (string-equal (file-name-extension buffer-file-name) \u0026#34;tsx\u0026#34;) (lsp-eslint-apply-all-fixes))) lsp-mode などの有効化 jsx/tsx ファイルを開く時に web-mode が有効になるようにしているのでその web-mode の hook で\ndisplay-line-numbers-mode lsp lsp-ui-mode company-mode を有効にしている。\nまた\n保存時の自動補正 hook の追加 自動テストのキーバインドの設定 も合わせて行っている。\nそれ以外にも web-mode の設定も少し弄っていて indent は2桁スペースになるようにしているが自動インデントだとそれが反映されないっぽいので自動インデントはオフにしている。\nなお過去の設定では flycheck も少し設定していたが lsp-mode から eslint を使うことでやりたいことの対応ができるようなのでその設定は外した。\n(defun my/tsx-hook () (let ((ext (file-name-extension buffer-file-name))) (when (or (string-equal \u0026#34;jsx\u0026#34; ext) (string-equal \u0026#34;tsx\u0026#34; ext)) (setq web-mode-markup-indent-offset 2) (setq web-mode-code-indent-offset 2) (setq web-mode-enable-auto-indentation nil) (origami-mode 1) (company-mode 1) (subword-mode 1) (turn-on-smartparens-strict-mode) (display-line-numbers-mode t) (lsp) (lsp-ui-mode 1) (add-hook \u0026#39;before-save-hook \u0026#39;my/tsx-auto-fix-hook nil \u0026#39;local)))) (add-to-list \u0026#39;context-skk-programming-mode \u0026#39;tsx-ts-mode) (add-hook \u0026#39;tsx-ts-mode-hook \u0026#39;my/tsx-hook) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/replacement/",
	"title": "replacement",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/rspec-mode/",
	"title": "rspec-mode",
	"tags": [],
	"description": "",
	"content": "概要 rspec-mode は Emacs で RSpec を実行したりする時に便利なパッケージ。といいつつ麦汁さんはちゃんと使いこなしていない……\nインストール (el-get-bundle rspec-mode) 有効化 rspec 実行バッファで byebug などで止まった際に C-x C-q したら inf-ruby が動くようにしている。\n(add-hook \u0026#39;after-init-hook \u0026#39;inf-ruby-switch-setup) binding.pry は何故かまともに動かないので byebug か binding.irb 推奨。麦汁さんはいつも debugger とコードに入れて使っている。\nキーバインド C-c C-c で開いている rspec ファイルのカーソルがある行のテストを実行できるようにしている。\n(define-key rspec-mode-map (kbd \u0026#34;C-c C-c\u0026#34;) \u0026#39;rspec-verify-single) 他にも色々な機能があるのだけどキーバインド未設定なのでこれだけしか使ってない。\nDocker 連携 Docker と連携するように調整\n(custom-set-variables \u0026#39;(rspec-use-docker-when-possible t)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/ruby/",
	"title": "ruby",
	"tags": [],
	"description": "",
	"content": "概要 Ruby のコードを編集する上での設定をここには書いている。別の箇所で rspec-mode などの設定も書いているのでいつか記述場所を統合した方が良さそうな気もする\nrbenv.el Ruby のバージョンを切り替えられる rbenv を使ってるので Emacs 上でもそれが使えるように rbenv.el を導入している。\nインストール インストールはいつも通り el-get でやっている\n(el-get-bundle rbenv) 有効化 そして global に有効化している。というか global じゃない有効化ってあるのかなってのと、あるとしても意味があるのかな的な。\n(global-rbenv-mode) enh-ruby-mode メジャーモードは enhanced-ruby-mode を利用している。が、最近は ruby-mode の方がやっぱり良いみたいな話もどこかで見た気がするので戻ってみるのも手かもしれないと思っている。\nインストール いつも通り el-get で入れている。\n(el-get-bundle enh-ruby-mode) カスタム設定 enh-ruby-mode が読み込まれた後に setq で以下のように設定されている\n(with-eval-after-load \u0026#39;enh-ruby-mode (setq enh-ruby-add-encoding-comment-on-save nil) (setq enh-ruby-deep-indent-paren nil) (setq enh-ruby-deep-indent-construct nil) (setq enh-ruby-bounce-deep-indent nil)) encoding のマジックコメントが入らないようにする enh-ruby-add-encoding-comment-on-save を nil にすることで encoding 設定のマジックコメントが入らないようにしている。\nこれは昔は有効にしておいた方が良かったけど最近の Ruby では設定しなくても UTF-8 が前提になるからむしろ無い方が良いというお話だったはず。\nそういう状況に変わったのも大分前なので詳細は忘れた。\nただとりあえず 最新の enhanced-ruby-mode を見るとデフォルトが nil なのでわざわざ設定しなくて良さそう。\nインデントの調整 enh-ruby-deep-indent-paren が t の場合\nhoge = { foo: 1 } みたいな深いインデントになるけど\nhoge = { foo: 1 } というようにしたいので nil に設定している。\nインデントの切替 インデントを深くしたくないといいつつ、全然それができないのも困りそうなので enh-ruby-bounce-deep-indent を t に設定してタブを押すごとに切り替わるようにしている。\nところでデフォルトで深い方になってるような気がするので今度設定の見直しした方が良さそう。\nhook hook 用の関数で補完などの機能を有効にしている\n(defun my/enh-ruby-mode-hook () (origami-mode 1) (company-mode 1) (subword-mode 1) (lsp) (lsp-ui-mode 1) (add-hook \u0026#39;before-save-hook #\u0026#39;lsp-format-buffer nil \u0026#39;local) (turn-on-smartparens-strict-mode) (display-line-numbers-mode 1)) 補完用に company-mode を有効化 solargraph を使ってるので lsp-mode を有効にしている lsp-ui-mode も有効にして色々な情報を表示している また lsp-mode の自動フォーマットを保存時に実行するようにしている 開きカッコと閉じカッコの組み合わせがズレないように smartparens-strict-mode を有効にしている 行番号も表示されている方が便利なので display-line-numbers-mode を有効にしている それらを設定する関数を enh-ruby-mode-hook に突っ込んでいる\n(add-hook \u0026#39;enh-ruby-mode-hook \u0026#39;my/enh-ruby-mode-hook) SKK の調整 enh-ruby-mode を context-skk-programming-mode に追加することで Ruby を使ってる時にコメント部分はクォートの外以外では自動的に日本語入力がオフになるようにしている\n(add-to-list \u0026#39;context-skk-programming-mode \u0026#39;enh-ruby-mode) キーバインド キーバインドは覚えられないので major-mode-hydra でキーを定義している\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define enh-ruby-mode (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-alltheicon \u0026#34;ruby-alt\u0026#34;) \u0026#34; Ruby commands\u0026#34;)) (\u0026#34;Enh Ruby\u0026#34; ((\u0026#34;{\u0026#34; enh-ruby-toggle-block \u0026#34;Toggle block\u0026#34;) (\u0026#34;e\u0026#34; enh-ruby-insert-end \u0026#34;Insert end\u0026#34;)) \u0026#34;LSP\u0026#34; ((\u0026#34;i\u0026#34; lsp-ui-imenu \u0026#34;Imenu\u0026#34;) (\u0026#34;f\u0026#34; lsp-ui-flycheck-list \u0026#34;Flycheck list\u0026#34;)) \u0026#34;RSpec\u0026#34; ((\u0026#34;s\u0026#34; rspec-verify \u0026#34;Run associated spec\u0026#34;) (\u0026#34;m\u0026#34; rspec-verify-method \u0026#34;Run method spec\u0026#34;) (\u0026#34;r\u0026#34; rspec-rerun \u0026#34;Rerun\u0026#34;) (\u0026#34;l\u0026#34; rspec-run-last-failed \u0026#34;Run last failed\u0026#34;)) \u0026#34;REPL\u0026#34; ((\u0026#34;I\u0026#34; inf-ruby \u0026#34;inf-ruby\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;j\u0026#34; dumb-jump-go \u0026#34;Dumb Jump\u0026#34;) (\u0026#34;o\u0026#34; origami-hydra/body \u0026#34;Origami\u0026#34;))))) Key 効果 { do 〜 end と { 〜 } を切り替える e end を挿入する。使ったことない気がする i lsp-ui-imenu の表示 f Flycheck の通知されるエラーのリスト表示 s 関連するテストまたは特定のテストの実行 m カーソル位置のコードのテストを探して実行する r 最後に実行したテストを再実行 l 最後に失敗したテストの再実行 I REPL バッファで Ruby を実行する j dumb-jump で関数定義にジャンプ。dumb-jump 用の hydra があるから要らなさそう "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/savehist/",
	"title": "savehist",
	"tags": [],
	"description": "",
	"content": "概要 Emacs 標準でついている、ミニバッファの履歴などを保存してくれる機能。\n有効化 標準でついているので以下のようにするだけで有効化可能。\n(savehist-mode 1) 設定 標準で保存されるもの以外だと kill-ring だけを保存対象にしている。これで Emacs を終了させても kill-ring は残るようになるはず。だけど最近使えてない気がするな……。検証が必要そう。\n(setq savehist-additional-variables \u0026#39;(kill-ring)) 他にも有効にしたら便利そうなのがあれば追加したい。が、ぱっとは思い付かない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/buffer-management/scratch-log/",
	"title": "scratch-log",
	"tags": [],
	"description": "",
	"content": "概要 scratch-log は、Emacs でちょっとした Emacs Lisp なんかを試し書きする時に使う *scratch* バッファを永続化してくれるパッケージ。\n自分なんかは Emacs Lisp だけでなくちょっとメモを置いといたりもするので勝手に永続化してくれるこいつにはとてもお世話になっている。\nGitHub の README には作者のブログへのリンクしかないしそのブログは消えてるので一番まともに解説しているのは http://emacs.rubikitch.com/scratch-log/ だと思う。\nインストール el-get のレシピを自前で用意して\n(:name scratch-log :type github :description \u0026#34;emacs の scratch バッファのログを取ります.\u0026#34; :pkgname \u0026#34;mori-dev/scratch-log\u0026#34;) el-get-bundle で入れるだけ。\n(el-get-bundle scratch-log) 有効化 どうも明示的に require しないといけないっぽくて、そうしている。ちょっと本当にそうなのか検証したい気はする。\n(require \u0026#39;scratch-log) 類似品など persistent-scratch これも scratch を永続化させるやつ。カスタマイズ性はこっちがありそう unkillable-scratch scratch バッファを kill させないやつ。同じような機能が scratch-log にもある auto-save-buffers-enhanced 自動保存機能がメインだけど scratch を自動保存する機能もある "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/scss/",
	"title": "scss",
	"tags": [],
	"description": "",
	"content": "概要 scss を使う上での設定をここではまとめている。長いこと手を入れてないので今はより良い設定がありそうな気がする。\nrainbow-mode rainbow-mode はカラーコードを入力した際に、そのカラーコード部分の背景色をカラーコードの色に変化させるパッケージ。ぱっと見で大体どんな色かわかって便利なやつ\nインストール 自分はel-get で入れている。\n(el-get-bundle rainbow-mode) ELPA に登録されているので package-install でもいける\nscss-mode scss-mode は Emacs 組込みの css-mode の中で定義されているメジャーモード。なのでインストール不要で使えるし .scss という拡張子なら自動的に scss-mode で開いてくれるようになっている。\n設定 improvement インデントはデフォルトだと半角空白 4 つとなっているが麦汁さん的には 2 の方が良いのでそのように変更している。\n(with-eval-after-load \u0026#39;scss-mode (setq css-indent-offset 2)) with-eval-after-load を使っているが css-indent-offset は defcustom で定義されているので custom-set-variables を使うように修正した方が良さそう\nflycheck の scss-stylelint を上書き stylelint v14 以降は \u0026ndash;style オプションが使えないので上書き https://github.com/flycheck/flycheck/pull/1944 が取り込まれたらこれも要らなさそうだけど。\n(with-eval-after-load \u0026#39;flycheck (flycheck-define-checker scss-stylelint \u0026#34;A SCSS syntax and style checker using stylelint. See URL `http://stylelint.io/\u0026#39;.\u0026#34; :command (\u0026#34;stylelint\u0026#34; (eval flycheck-stylelint-args) (option-flag \u0026#34;--quiet\u0026#34; flycheck-stylelint-quiet) (config-file \u0026#34;--config\u0026#34; flycheck-stylelintrc)) :standard-input t :error-parser flycheck-parse-stylelint :predicate flycheck-buffer-nonempty-p :modes (scss-mode))) hook improvement scss を使う上で hook を使って色々有効化したりしている。\n(defun my/scss-mode-hook () (flycheck-mode 1) (setq-local lsp-prefer-flymake nil) (lsp) (lsp-ui-mode -1) (smartparens-strict-mode 1) ;; lsp-ui とかより後に設定しないと上書きされるのでここに移動した (setq-local flycheck-checker \u0026#39;scss-stylelint) (setq-local flycheck-check-syntax-automatically \u0026#39;(save new-line idle-change)) (origami-mode 1) (company-mode 1) (subword-mode 1) (display-line-numbers-mode 1) (rainbow-mode)) (add-hook \u0026#39;scss-mode-hook \u0026#39;my/scss-mode-hook) flycheck-mode の有効化 これによりリアルタイムに lint 結果が分かって便利になる lsp-prefer-flymake の無効化 flycheck が有効にならない問題を防いでいる。どうも自分の設定の書き方が悪い気もするが……。 lsp-mode を有効化しつつ lsp-ui は無効にしている lsp-ui が有効だと画面上でガチャガチャ height とかのプロパティの説明をしてうざいので smartparens-strict-mode を入れることで {} のペアが維持されるようにしている flycheck-checker, flycheck-check-syntax-automatically の設定 lsp-ui とかより後に設定しないと上書きされるので、それらより後に設定している 設定の書き方の悪さのせいな気もする company-mode の有効化。これがないと補完できなくて厳しいよね display-line-numbers-mode の有効化。行数表示も欲しいよね。巨大ファイルだと邪魔だけど巨大にしなきゃいい rainbow-mode の有効化 カラーコード→ CSS Variable の置き換え 外部コマンドで fetch-color-var というのを定義してそいつにカラーコードを渡すとプロジェクトで使ってる CSS Variable を返してくるようにしている。\nで、それを Emacs から叩いて使えるようにしているのが以下のコマンド\n(defun my/replace-var (point mark) (interactive \u0026#34;r\u0026#34;) (let* ((str (buffer-substring point mark)) (cmd (concat \u0026#34;fetch-color-var \u0026#39;\u0026#34; str \u0026#34;\u0026#39;\u0026#34;)) (response (shell-command-to-string cmd))) (delete-region point mark) (insert response))) キーバインド 設定しているけど使ってないなあ……。\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define scss-mode (:quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-alltheicon \u0026#34;css3\u0026#34;) \u0026#34; CSS\u0026#34;)) (\u0026#34;Edit\u0026#34; ((\u0026#34;v\u0026#34; my/replace-var \u0026#34;replace-var\u0026#34;))))) Key 効果 v リージョンの値で CSS 変数を検索して置き換えるやつ。自作コマンドを利用している "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/server/",
	"title": "server",
	"tags": [],
	"description": "",
	"content": "概要 Emacs の起動後にサーバとして動くようにしている。\nこれにより emacsclient コマンドで接続するとサーバとして動いている Emacs に別端末から繋げられたりする。\nけど麦汁さんは Firefox から org-capture を動かすためにだけ利用している。\n設定 server.el を require しておいてサーバとして動いていなかったらサーバとして動くようにしている。多重起動の防止ですね。\n(require \u0026#39;server) (unless (server-running-p) (server-start)) 関連ツール org-capture-extension org-capture 連携するための Chrome 及び Firefox の拡張。麦汁さんはこれを Firefox で使ってる。 org-protocol-capture-html HTML コンテンツを org-mode の記述に変換して capture してくれるやつ。Pandoc 利用。 その他 起動処理の最後に動けばいいので init-loader で 99 を割り振っている。\ninit-loader をやめるなら多分 after-init-hook を使うことになるのかな。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/show-paren-mode/",
	"title": "show-paren-mode",
	"tags": [],
	"description": "",
	"content": "概要 show-paren-mode は Emacs に標準で入っているやつで開き括弧と閉じ括弧の対応を示してくれたり括弧の中身を強調表示したりする機能を提供してくれるやつ。\n有効化 デフォで入ってるので以下のようにするだけで有効化される。\n(show-paren-mode 1) デフォ設定だと対応する括弧を強調表示するだけだけどまあそれで悪くないと思ってるので今のところデフォルト設定のままである。\nその他 http://syohex.hatenablog.com/entry/20110331/1301584188\nの記事へのリンクを設定ファイルの中に残していたけど設定は特に弄ってないのでまたその記事読んだりで設定弄ってみてもいいかもしれない。\nまた smartparens.el にも似た機能はあるようだけど Emacs 標準機能の方が軽そうなのでとりあえずこのままにするつもり。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/smartparens/",
	"title": "smartparens",
	"tags": [],
	"description": "",
	"content": "概要 smartparens はカッコとかクォートとかのペアになるようなものの入力補助をしてくれるやつ。\nstrict モードだとペアが崩れないように強制するので雑に C-k で行削除しててもペアが維持されて便利。\nインストール いつも透り el-get で導入している\n(el-get-bundle smartparens) 設定 実は導入して間もないので、提供されてるオススメ設定のみ突っ込んでいる。オススメ設定は別途 reqiure したら良いという作りなので、以下のようにして突っ込んでいる。\n(require \u0026#39;smartparens-config) その他 各言語の hook で smartparens-strict-mode を有効にしている。なんか常に有効だと困りそうな気がしたので。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/",
	"title": "sticky-control",
	"tags": [],
	"description": "",
	"content": "概要 指定したキーを2回叩いたら Control が押されてるような状態にしてくれるプラグイン。\nその2回の間隔はデフォルトだと 0.5 秒以内となっている。そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる\nさらに sticky-control-shortcuts に指定されてる一部のキーについては sticky 用のキーを押した直後に shortcuts のキーを押すと Control を押している状態でそのキーを押したことになる。\n例えば私は , を sticky 用のキーにしていて shortcuts に c を入れているので ,c と素早くタイプをすればそれだけで C-c が押された状態になる。\nインストール まずは el-get-bundle でインストール。\n(el-get-bundle sticky-control) ちなみにレシピは公式ではなかったのでとりあえず自分の環境で使えるように自作レシピを置いている。\n(:name sticky-control :description \u0026#34;save your left little finger\u0026#34; :type http :url \u0026#34;https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el\u0026#34; :features \u0026#34;sticky-control\u0026#34;) 元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど最近そこからは取得できなくなったので https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el から取得して利用している\n設定 まずは「2回叩いたら Control を押している状態になる」キーを指定する。\n(sticky-control-set-key \u0026#39;sticky-control-key ?,) 私は , を sticky-control のキーにしているのでこの指定。\nそして次に sticky-control-shortuts の指定。ここに指定しておくと、例えば ,c と素早くタイプすることで C-c が入力された状態とすることができる。\n(setq sticky-control-shortcuts \u0026#39;((?c . \u0026#34;\\C-c\u0026#34;) (?g . \u0026#34;\\C-g\u0026#34;) (?k . \u0026#34;\\C-k\u0026#34;) (?a . \u0026#34;\\C-a\u0026#34;) (?e . \u0026#34;\\C-e\u0026#34;) (?n . \u0026#34;\\C-n\u0026#34;) (?o . \u0026#34;\\C-o\u0026#34;) (?p . \u0026#34;\\C-p\u0026#34;) (?j . \u0026#34;\\C-j\u0026#34;) (?f . \u0026#34;\\C-f\u0026#34;) (?b . \u0026#34;\\C-b\u0026#34;) (?x . \u0026#34;\\C-x\u0026#34;) (?r . \u0026#34;\\C-r\u0026#34;) (?s . \u0026#34;\\C-s\u0026#34;))) 結構な数を指定しているけど、普段そんなに使えているわけでもない。まあ、大体 Control を押しながら使いそうなところは押さえてあるので何も考えずとも使えるようにしてある。\n有効化 最後に有効化\n(sticky-control-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/buffer-management/tempbuf/",
	"title": "tempbuf",
	"tags": [],
	"description": "",
	"content": "概要 tempbuf-mode は不要になったと思われるバッファを自動的に kill してくれるパッケージ。使っていた時間が長い程、裏に回った時には長い時間保持してくれる。\nつまり、一瞬開いただけのファイルは明示的に kill しなくても勝手にやってくれるのでファイルを開いてそのまま放置みたいなことをしがちなズボラな人間には便利なやつ。\nインストール いつも通り el-get で入れている。\n(el-get-bundle tempbuf-mode) 勝手に kill させないファイルの指定 org-clock を使うようなファイルは kill されると org-clock が狂って面倒なことになるのでそれらのファイルは勝手に kill されないように ignore リストに突っ込んでいる\n(setq my/tempbuf-ignore-files \u0026#39;(\u0026#34;~/Documents/org/tasks/reviews.org\u0026#34; \u0026#34;~/Documents/org/tasks/interrupted.org\u0026#34; \u0026#34;~/Documents/org/tasks/habits.org\u0026#34; )) find-file への hook find-file した時に上でリストアップしたファイルだった場合は kill されないように tempbuf-mode が自動的に無効になるような hook を用意している。\nあとその日の journal ファイルも勝手に kill されると org-clock 的に困るので tempbuf-mode をオフにしている\n(defun my/find-file-tempbuf-hook () (cond ((string= (org-journal--get-entry-path) (buffer-file-name)) (turn-off-tempbuf-mode)) (t (let ((ignore-file-names (mapcar \u0026#39;expand-file-name my/tempbuf-ignore-files))) (unless (member (buffer-file-name) ignore-file-names) (turn-on-tempbuf-mode)))))) hook の設定 find-file では上で作成した hook を使うことで kill されたくないファイルは kill されないようにしている\n(add-hook \u0026#39;find-file-hook \u0026#39;my/find-file-tempbuf-hook) また dired buffer も邪魔になりがちだけど、デフォルトだと対象にならないのでこいつらも tempbuf-mode の管理対象となるように tempbuf-mode を有効にしている。\n(add-hook \u0026#39;dired-mode-hook \u0026#39;turn-on-tempbuf-mode) その他 midnight-mode という、深夜に処理を実行させるようなやつで夜間にバッファをごっそり消すみたいなことをしている人も結構いるっぽい。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/terraform/",
	"title": "Terraform",
	"tags": [],
	"description": "",
	"content": "概要 Terraform はオープンソースの IaC ツール。結構よく使われている。色々なクランドサービスに対応していて便利。\nterraform-mode terraform-mode は Emacs で terraform のコードを書くための major-mode を提供してくれるやつ。\nインストール el-get にも terraform-mode のレシピはあるけど dash の依存が書かれていないのでとりあえず自前で用意している\n(:name terraform-mode :type github :pkgname \u0026#34;emacsorphanage/terraform-mode\u0026#34; :description \u0026#34;Major mode for Terraform configuration files\u0026#34; :depends (hcl-mode dash)) そしてそれを el-get-bundle で入れている\n(el-get-bundle terraform-mode) 設定 保存時に自動で整形してほしいのでその設定を入れている\n(custom-set-variables \u0026#39;(terraform-format-on-save t)) company-terraform company-terraform は company-mode の拡張機能で terraform の補完をいい感じにしてくれるやつ\nインストール el-get 本体にはレシピが用意されてないのでとりあえず自前で用意している\n(:name company-terraform :website \u0026#34;https://github.com/rafalcieslak/emacs-company-terraform\u0026#34; :description \u0026#34;Company backend for terraform files.\u0026#34; :type github :pkgname \u0026#34;rafalcieslak/emacs-company-terraform\u0026#34; :depends (company-mode terraform-mode)) そしていつも通り el-get-bundle でインストール\n(el-get-bundle company-terraform) 設定 インストールした後に init してあげることで company の backend として追加してくれるのでそのようにしている\n(company-terraform-init) hooks hook を使っていくつかの minor-mode を有効にしている\norigami コードの折り畳み company コード補完 flyccheck コードの変な部分の指摘 smartparens-strict-mode カッコの対応を強力にしてくれるやつ display-line-numbers-mode 行数表示 flycheck に関しては terraform-tflint が tflint 0.47 に対応してないのでそいつだけ無効にしている\n(defun my/terraform-mode-hook () (origami-mode 1) (company-mode 1) (setq-local flycheck-checker \u0026#39;terraform) (setq-local flycheck-disabled-checkers \u0026#39;(terraform-tflint)) (flycheck-mode 1) (turn-on-smartparens-strict-mode) (display-line-numbers-mode 1)) (add-hook \u0026#39;terraform-mode-hook \u0026#39;my/terraform-mode-hook) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/textlint/",
	"title": "textlint",
	"tags": [],
	"description": "",
	"content": "概要 textlint は plain text や Markdown の校正に使える linter です。そして flycheck でそれを呼び出すことができるので、変な文章を書いていないかチェックすることができます。\n設定 textlint の設定を ~/.config/textlint/textlintrc_ja.json に置いているのでそれを flycheck-textlint-config に設定しています。\n(custom-set-variables \u0026#39;(flycheck-textlint-config \u0026#34;~/.config/textlint/textlintrc_ja.json\u0026#34;)) magit 用の hook 関数の用意 magit で commit message を書く時に自動で textlint が起動するようにするための関数。なんだけど想定通りに動いていない\n;; 想定通りに動かない (defun my/magit-commit-create-after (\u0026amp;optional arg) (ignore arg) (flycheck-select-checker \u0026#39;textlint-no-extension)) ;; (with-eval-after-load \u0026#39;magit ;; (advice-add \u0026#39;magit-commit-create :after \u0026#39;my/magit-commit-create-after)) checker 定義 flycheck のデフォルトでも textlint は動くのですが magit でコミットメッセージを書く時なんかには動いてくれなかったので拡張子がないファイルの時にも動くように checker を定義 \u0026amp; 追加している。\nその際 forge で Pull request を作る時に自動で有効になるようにも調整している。\n(with-eval-after-load \u0026#39;flycheck (flycheck-define-checker textlint-no-extension \u0026#34;A text prose linter using textlint. See URL `https://textlint.github.io/\u0026#39;.\u0026#34; :command (\u0026#34;textlint\u0026#34; \u0026#34;--stdin\u0026#34; \u0026#34;--stdin-filename\u0026#34; (eval (concat buffer-file-name \u0026#34;.txt\u0026#34;)) (config-file \u0026#34;--config\u0026#34; flycheck-textlint-config) \u0026#34;--format\u0026#34; \u0026#34;json\u0026#34; ;; get the first matching plugin from plugin-alist \u0026#34;--plugin\u0026#34; (eval (flycheck--textlint-get-plugin))) :standard-input t ;; textlint seems to say that its json output is compatible with ESLint. ;; https://textlint.github.io/docs/formatter.html :error-parser flycheck-parse-eslint ;; textlint can support different formats with textlint plugins, but ;; only text and markdown formats are installed by default. Ask the ;; user to add mode-\u0026gt;plugin mappings manually in ;; `flycheck-textlint-plugin-alist\u0026#39;. :modes (forge-post-mode text-mode) :enabled (lambda () (and (flycheck--textlint-get-plugin) (null (file-name-extension buffer-file-name)))) :verify (lambda (_) (let ((plugin (flycheck--textlint-get-plugin))) (list (flycheck-verification-result-new :label \u0026#34;textlint plugin\u0026#34; :message plugin :face \u0026#39;success))))) (add-to-list \u0026#39;flycheck-checkers \u0026#39;textlint-no-extension) (flycheck-add-mode \u0026#39;textlint-no-extension \u0026#39;forge-post-mode)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/todoist/",
	"title": "todoist",
	"tags": [],
	"description": "",
	"content": "概要 emacs-todoist は Todo 管理サービスである Todoist と連携するためのパッケージ。 org-mode に依存している。\nインストール まず以下のレシピを用意している\n(:name emacs-todoist :website \u0026#34;https://github.com/abrochard/emacs-todoist\u0026#34; :description \u0026#34;Emacs interface to Todoist\u0026#34; :type github :pkgname \u0026#34;abrochard/emacs-todoist\u0026#34;) その上で以下のようにしてインストールしている\n(el-get-bundle emacs-todoist) 設定 API キーを設定するので別ファイルに分離している。いつか .authinfo.gpg に移動しようかなと思っているけどそもそも最近 TODOIST 使ってない……\n(with-eval-after-load \u0026#39;todoist (setq todoist-token (funcall (plist-get (nth 0 (auth-source-search :host \u0026#34;todoist.com\u0026#34; :max 1)) :secret)))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/toolbar/",
	"title": "toolbar",
	"tags": [],
	"description": "",
	"content": "概要 Emacs 標準の toolbar の設定。麦汁さんは使わないし幅を取るので隠す派。\n設定 単に無効にして隠している\n(tool-bar-mode -1) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/tree-sitter/",
	"title": "tree-sitter",
	"tags": [],
	"description": "",
	"content": "概要 ここでは今現在は、 tree-sitter が使えることを自動判定して mode を切り替えて tree-sitter の文法定義が存在しなければ自動的にインストールしてくれる treesit-auto 用の設定を記述している\nインストール treesit-auto のレシピは自前で用意している\n(:name treesit-auto :website \u0026#34;https://github.com/renzmann/treesit-auto\u0026#34; :description \u0026#34;Automatically install and use tree-sitter major modes in Emacs 29+.\u0026#34; :type github :branch \u0026#34;main\u0026#34; :pkgname \u0026#34;renzmann/treesit-auto\u0026#34;) そしていつも通り el-get-bundle でインストールしている\n(el-get-bundle treesit-auto) 設定 インストール時には一応確認してほしいので、確認が入るような設定にしている\n(custom-set-variables \u0026#39;(treesit-auto-install \u0026#39;prompt)) 有効化 require した上で global に有効化している\n(require \u0026#39;treesit-auto) (global-treesit-auto-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/twmode/",
	"title": "twmode",
	"tags": [],
	"description": "",
	"content": "概要 twmode は Emacs 上で動く Twitter クライアント。\n今でもたまーに使っている。勉強会に参加して実況する時などに。\nインストール いつも通り el-get でインスコしている。\n(el-get-bundle twittering-mode) 設定 (setq twittering-username \u0026#34;mugijiru\u0026#34;) (setq twittering-jojo-mode t) (setq twittering-timer-interval 60) ;(setq twittering-auth-method \u0026#39;xauth) (setq twittering-auth-method \u0026#39;oauth) (setq twittering-update-status-function \u0026#39;twittering-update-status-from-minibuffer) (setq twittering-status-format \u0026#34;%i %S(%s)%p, %@:\\n%FILL{ %T // from %f%L%r%R}\\n \u0026#34;) (setq twittering-retweet-format \u0026#34;RT @%s %t\u0026#34;) (setq twittering-display-remaining t) なんか色々設定しているけど、まあ大体こんな感じ。\nユーザー名の指定 twittering-jojo-mode を有効化 自動リロードの間隔を60秒に設定 OAuth で認証するように設定 投稿時にミニバッファから投稿するように設定 各ツイートのフォーマット指定 旧式の Retweet 時のフォーマット指定 late limit をmode-line に表示 キーバインド (let ((km twittering-mode-map)) (define-key km (kbd \u0026#34;SPC\u0026#34;) \u0026#39;scroll-up) (define-key km (kbd \u0026#34;b\u0026#34;) \u0026#39;scroll-down) (define-key km (kbd \u0026#34;g\u0026#34;) \u0026#39;beginning-of-buffer) (define-key km (kbd \u0026#34;G\u0026#34;) \u0026#39;end-of-buffer) (define-key km (kbd \u0026#34;\u0026lt;\u0026#34;) \u0026#39;beginning-of-buffer) (define-key km (kbd \u0026#34;\u0026gt;\u0026#34;) \u0026#39;end-of-buffer) (define-key km (kbd \u0026#34;R\u0026#34;) \u0026#39;twittering-current-timeline) (define-key km (kbd \u0026#34;F\u0026#34;) \u0026#39;twittering-favorite) (define-key km (kbd \u0026#34;\\C-cfd\u0026#34;) \u0026#39;twittering-unfavorite) (define-key km (kbd \u0026#34;\\C-c[\u0026#34;) \u0026#39;twittering-follow) (define-key km (kbd \u0026#34;\\C-c]\u0026#34;) \u0026#39;twittering-unfollow) nil) Key 効果 SPC スクロールする b 上にスクロールする g, \u0026lt; バッファの先頭に移動 G, \u0026gt; バッファの末尾に移動 R 現在のタイムラインを更新 F ふぁぼる C-c f d ふぁぼ取り消し C-c [ フォローする C-c ] アンフォロー "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/typescript/",
	"title": "TypeScript",
	"tags": [],
	"description": "",
	"content": "概要 TypeScript ファイル(.ts) を使う上での設定を書いている。とりあえず簡単な設定だけ。\ntypescript-mode typescript-mode は TypeScript 向けの Syntax Highlight とかを提供してくれるメジャーモード。\nインストール 自分はいつも通り el-get で入れている\n(el-get-bundle typescript-mode) カスタム変数 indent は2文字がいいのでデフォルトから変更 言語設定を ja にする。エラーが日本語で出るようになるとか……? inlay-hint を有効にする。何が変わるかわかってないけど Node.js の使用メモリも 2048 MB に増加。メモリ足らんってなる時があったので 保存時の自動フォーマット などを設定している。\n(custom-set-variables \u0026#39;(typescript-indent-level 2) \u0026#39;(lsp-typescript-locale \u0026#34;ja\u0026#34;) \u0026#39;(lsp-inlay-hint-enable t) \u0026#39;(lsp-javascript-display-parameter-name-hints t) \u0026#39;(lsp-javascript-display-enum-member-value-hints t) \u0026#39;(lsp-clients-typescript-max-ts-server-memory 2048) \u0026#39;(lsp-disabled-clients \u0026#39;()) \u0026#39;(lsp-eslint-auto-fix-on-save nil)) auto-fix の hook 関数 保存した時に自動で整形してほしいなと思ったので自動で保存されるように hook 関数を用意している\n(defun my/ts-mode-auto-fix-hook () (when (string-equal (file-name-extension buffer-file-name) \u0026#34;ts\u0026#34;) (lsp-eslint-apply-all-fixes))) hook company-mode smartparens-strict-mode lsp/lsp-ui などのプログラミングで便利な各種のモードを hook を使って有効化している\n(defun my/ts-mode-hook () (origami-mode 1) (company-mode 1) (subword-mode 1) (turn-on-smartparens-strict-mode) (display-line-numbers-mode t) (lsp) (lsp-ui-mode 1) (add-hook \u0026#39;before-save-hook #\u0026#39;my/ts-mode-auto-fix-hook nil \u0026#39;local)) この関数を\n(add-hook \u0026#39;typescript-ts-mode-hook \u0026#39;my/ts-mode-hook) として hook に追加している。\n直接 lambda で add-hook に書くという手もあるが関数を分離しておくと修正の反映が用意なのでこのようにしている。\n拡張子による有効化 .ts ファイルであれば typescript-mode で動いてほしいので auto-mode-alist に突っ込んでいる\n(add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.ts\u0026#34; . typescript-ts-mode)) また skk もいい感じに動いてほしいので context-skk-programming-mode を有効にしている\n(add-to-list \u0026#39;context-skk-programming-mode \u0026#39;typescript-ts-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/undo-fu/",
	"title": "undo-fu",
	"tags": [],
	"description": "",
	"content": "概要 undo-fu はシンプルな undo/redo 機能を提供してくれるやつ。\n昔はもっと色々できる undo-tree を使っていたけどそっちにバグがあるっぽいので乗り換えた。\nインストール レシピは自前で用意している\n(:name undo-fu :website \u0026#34;https://codeberg.org/ideasman42/emacs-undo-fu\u0026#34; :description \u0026#34;Simple, stable linear undo with redo for Emacs.\u0026#34; :type git :branch \u0026#34;main\u0026#34; :url \u0026#34;https://codeberg.org/ideasman42/emacs-undo-fu.git\u0026#34;) そしていつも通り el-get-bundle でインストールしている\n(el-get-bundle undo-fu) キーバインド 別の場所で定義しているけど、以下のキーバインドにしている。\nKey 効果 C-/ undo C-M-/ redo "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/uniquify/",
	"title": "uniquify",
	"tags": [],
	"description": "",
	"content": "概要 同じ名前のファイルを開いている時に祖先のディレクトリ名を表示してくれてどこのファイルかわかりやすくしてくれるやつ。\nすぐ親とかも同名でも、名前が違うところまで遡って表示してくれる。\n有効化 Emacs に標準で入ってるので require するだけで有効にできる\n(require \u0026#39;uniquify) 設定 自分は ファイル名\u0026lt;フォルダ名\u0026gt; みたいな表示になる形式にしている。その方がファイル名が主という感じになって使いやすそうだなって。\nそういう意味では post-foward の方が幅を使わない分良いかもしれない。いつか検討しても良いかもしれない。\n(setq uniquify-buffer-name-style \u0026#39;post-forward-angle-brackets) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/unused/",
	"title": "unused",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/view-mode/",
	"title": "view-mode",
	"tags": [],
	"description": "",
	"content": "概要 view-mode は Emacs に標準で組込まれているモードで、バッファを閲覧専用にする機能を提供してくれるやつ。コードを眺めたい時などに使っている。\nキーバインド view-mode の時は文字入力をする必要がないので通常のモードの時とは違うキーバインドが使えるようにしている。\n(defun my/setup-view-mode-keymap () (let ((keymap view-mode-map)) (define-key keymap (kbd \u0026#34;h\u0026#34;) \u0026#39;backward-char) (define-key keymap (kbd \u0026#34;j\u0026#34;) \u0026#39;next-line) (define-key keymap (kbd \u0026#34;k\u0026#34;) \u0026#39;previous-line) (define-key keymap (kbd \u0026#34;l\u0026#34;) \u0026#39;forward-char) (define-key keymap (kbd \u0026#34;e\u0026#34;) \u0026#39;forward-word) (define-key keymap (kbd \u0026#34;b\u0026#34;) \u0026#39;scroll-down) (define-key keymap (kbd \u0026#34;SPC\u0026#34;) \u0026#39;scroll-up) (define-key keymap (kbd \u0026#34;g\u0026#34;) \u0026#39;beginning-of-buffer) (define-key keymap (kbd \u0026#34;G\u0026#34;) \u0026#39;end-of-buffer) (define-key keymap (kbd \u0026#34;\u0026lt;\u0026#34;) \u0026#39;beginning-of-buffer) (define-key keymap (kbd \u0026#34;\u0026gt;\u0026#34;) \u0026#39;end-of-buffer))) Key 効果 h 1文字戻る j 1行下がる k 1行上がる l 1文字進む e 単語の直後に移動 b 1スクロール戻る SPC 1スクロール進む g, \u0026lt; バッファの先頭に移動 G, \u0026gt; バッファの末尾に移動 適当だけど Vim の通常モードの時みたいな操作ができるようにしている。\nこれで不要に左手小指を痛める可能性が下がるであろう。\nhook 上でキーバインドを設定できる関数を用意してあるので view-mode が有効になる時にそれを hook して設定されるようにしている。\nが、 hook する必要あるのか疑問ではあるな。ま、動いているからとりあえずいいけど。\n(defun my/view-mode-hook () (my/setup-view-mode-keymap)) (add-hook \u0026#39;view-mode-hook \u0026#39;my/view-mode-hook) Toggle するコマンド view-mode にしたり戻したりするコマンドを用意している。\nview-mode を有効にする時には hl-line-mode も有効にしているのでその時眺めている行がハイライトされるようになっている。普段はそれがあるかどうかでどっちもモードかざっくり判断している。\n他にも mode-line の色を変更するなどの技があるようだがひとまず今の設定でそう困ってないのでいいかな。\n(defun my/toggle-view-mode () \u0026#34;view-mode と通常モードの切り替えコマンド\u0026#34; (interactive) (cond (view-mode (hl-line-mode -1) (view-mode -1)) (t (hl-line-mode 1) (view-mode 1)))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/vue-js/",
	"title": "Vue.js",
	"tags": [],
	"description": "",
	"content": "概要 ここでは Vue.js アプリケーションを書く上での設定を書いている。\nauto-insert の設定 Vue.js のコンポーネントファイルを新規作成する時にテンプレートが自動挿入できるようにしている\nテンプレート Vue.js の単一ファイルコンポーネントなので template, script, style を出力している。\ntemplate には pug を、CSS には scss を使っている。\n\u0026lt;template lang=\u0026#39;pug\u0026#39;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { }; \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#39;scss\u0026#39; scoped\u0026gt; \u0026lt;/style\u0026gt; テンプレートを適用可能にする .vue という拡張子のファイルを新規作成する時には上で定義したテンプレートが自動的に挿入されるようにする。\n(define-auto-insert \u0026#34;\\\\.vue$\u0026#34; \u0026#34;template.vue\u0026#34;) パッケージのインストール ここでは Vue.js 開発に使っている関連パッケージを入れている。\nvue-mode vue-mode は mmm-mode をベースにして作られた Vue.js の単一ファイルコンポーネント用のモード。 mmm-mode ベースなので template, script, css 部分でそれぞれ別のメジャーモードが動くようになっている。\nインストール el-get レシピは自前で用意している\n(:name vue-mode :description \u0026#34;Major mode for vue component based on mmm-mode\u0026#34; :type github :pkgname \u0026#34;AdamNiederer/vue-mode\u0026#34; :depends (ssass-mode mmm-mode edit-indirect vue-html-mode)) また、依存しているパッケージもいくつかレシピを自前で用意している\n(:name vue-html-mode :description \u0026#34;Major mode for editing Vue.js templates\u0026#34; :type github :pkgname \u0026#34;AdamNiederer/vue-html-mode\u0026#34;) (:name edit-indirect :description \u0026#34;Edit regions in separate buffers\u0026#34; :type github :pkgname \u0026#34;Fanael/edit-indirect\u0026#34;) (:name ssass-mode :description \u0026#34;Edit Sass without a Turing Machine\u0026#34; :type github :pkgname \u0026#34;AdamNiederer/ssass-mode\u0026#34;) (:name mmm-mode :description \u0026#34;Allow Multiple Major Modes in a buffer\u0026#34; :type github :pkgname \u0026#34;purcell/mmm-mode\u0026#34; :depends (cl-lib)) いつも透り el-get で入れている\n(el-get-bundle vue-mode) 備考 あまり更新は活発でなく微妙な挙動もあるので mmm-mode に乗り換えたり web-mode を使うようにしている人も多い様子。\n自分もそういった乗り換えを検討した方がいいかもと思いつつ最近あまり Vue.js 触ってないから、まあいいかという気持ちもある。\nなお vue-mode では JS 部分は js2-mode は使えないはず。 mmm-mode の方が何かの制限で使えないという話だったはずなので。 https://github.com/mooz/js2-mode/issues/124\npug-mode pug-mode は pug というテンプレートエンジンを使って記述するためのモード。 Vue.js でテンプレートエンジンに pug を利用することが多いので入れている。麦汁さんは HTML をそのまま書くようなことは好きじゃないのです。\nインストール いつも透り el-get で入れている\n(el-get-bundle hlissner/emacs-pug-mode) hooks css-mode と vue-mode だけは hook を定義している。 pug-mode や js-mode についても何か手を入れた方がいいのかもしれない。\ncss-mode Vue.js では style に scss を指定いちえる場合には css-mode が利用されるようになっているので css-mode の hook としている。 https://github.com/AdamNiederer/vue-mode/blob/031edd1f97db6e7d8d6c295c0e6d58dd128b9e71/vue-mode.el#L63\n(defun my/css-mode-hook () (setq-local flycheck-checker \u0026#39;css-stylelint) (rainbow-mode 1)) (add-hook \u0026#39;css-mode-hook \u0026#39;my/css-mode-hook) 見ての透り rainbow-mode と flycheck-checker の設定ぐらいしかしてない。 scss-mode の方ではもう少し手を入れているので同じようなのをここに反映してもいいかもしれない。\nもしくは設定を統合するという手もあるかも。\nvue-mode (defun my/vue-mode-hook () (display-line-numbers-mode t) (lsp) (flycheck-mode 1)) (add-hook \u0026#39;vue-mode-hook \u0026#39;my/vue-mode-hook) 行番号表示 lsp を有効化 flyckeck-mode を有効化 しているだけである。 lsp-ui とか色々設定の余地はありそうな気がする。\nキーバインド これもろくに設定してないし、ろくに使ってないもいないが、一応設定自体はある。\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define css-mode (:quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-alltheicon \u0026#34;css3\u0026#34;) \u0026#34; CSS\u0026#34;)) (\u0026#34;Edit\u0026#34; ((\u0026#34;v\u0026#34; my/replace-var \u0026#34;replace-var\u0026#34;))))) Key 効果 v リージョンの値で CSS 変数を検索して置き換えるやつ。自作コマンドを利用している "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/wakatime-mode/",
	"title": "wakatime-mode",
	"tags": [],
	"description": "",
	"content": "概要 wakatime-mode は WakaTime というサービスと連携するためのパッケージ。\nWakaTime は自分がどのプロジェクトの作業をしているかを計測してくれるようなツール。普段の行動の改善に使えるかもしれないので、なんとなく連携してみている。\nインストール いつも通り el-get から入れている\n(el-get-bundle wakatime-mode) APIキーの設定 APIキーは .authinfo.gpg に保存しているのでそこから引っ張り出している。\n(custom-set-variables \u0026#39;(wakatime-cli-path \u0026#34;/usr/bin/wakatime\u0026#34;) \u0026#39;(wakatime-api-key (funcall (plist-get (nth 0 (auth-source-search :host \u0026#34;wakatime.com\u0026#34; :max 1)) :secret)))) 有効化 Emacs を使っている間は常に有効になっていて欲しいので global-wakatime-mode を有効にしている。\n(global-wakatime-mode 1) APIキーが取れてない時はやたらエラーを吐くので何かしら調整はしてもいいかもしれない。\n(if (boundp \u0026#39;wakatime-api-key) (global-wakatime-mode 1)) みたいにして API キーが取れている時だけ有効にするとかね。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/which-key/",
	"title": "which-key",
	"tags": [],
	"description": "",
	"content": "概要 which-key は prefix となるキーを入力してしばらく操作しなかった場合に minibuffer とかで「続けて押せるキーはこれだよ」ってのを示してくれるやつ。\nインストール こいつは el-get 本体にレシピがあるので el-get-bundle でインストールしている\n(el-get-bundle which-key) 有効化 特に設定は弄らないで有効化している\n(which-key-mode 1) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/whitespace/",
	"title": "whitespace",
	"tags": [],
	"description": "",
	"content": "概要 whitespace-mode は Emacs に標準添付されている、空白文字を可視化したりするためのモード。\n全角空白を可視化したり、行末の空白を可視化したりしておくと便利なので入れている。\n設定 (require \u0026#39;whitespace) 可視化対象 可視化対象の空白について設定している。\n(setq whitespace-style \u0026#39;(face trailing tabs spaces empty space-mark tab-mark)) 値 意味 face face による可視化を有効にする。これがないと *-mark 以外が有効にならない trailing 行末の空白を可視化する tabs タブ文字の可視化 spaces 空白の可視化。ただし後の設定で全角のみを可視化するようにている empty バッファの前後に空行があれば可視化 space-mark 空白文字を別の文字に置き換える設定。置き換え文字は後述 tab-mark タブ文字を別の文字に置き換える設定。置き換え文字は後述 他にも lines, lines-tail, indentation, big-indent, newline-mark などがある\nlines-tail あたりを使うと1行80文字制限でコーディングする時などに便利かもしれないなって思ってる。設定したことがないからわからんが……。\n置き換え表示用の文字の設定 (setq whitespace-display-mappings \u0026#39;((space-mark ?\\u3000 [?\\u25a1]) ;; WARNING: the mapping below has a problem. ;; When a TAB occupies exactly one column, it will display the ;; character ?\\xBB at that column followed by a TAB which goes to ;; the next TAB column. ;; If this is a problem for you, please, comment the line below. (tab-mark ?\\t [?\\u00BB ?\\t] [?\\\\ ?\\t]))) 置き換え元 置き換え先 空白文字 タブ文字 » + TAB を表示する。もしそれが表示できない時は \\ + TAB で代替する どこかからコピペしてきたやつなので英語のコメントもあるが「なんかうまく動かなかったらコメントアウトしてくれよな」って感じ。ま、うまく動いてそうなのでヨシッ!\nスペースは全角のみを可視化 半角スペースまでいちいち可視化されてたら邪魔だし気付きたいのは全角スペースが紛れてるかどうかなので、空白文字ではそれだけを可視化するようにしている。\n(setq whitespace-space-regexp \u0026#34;\\\\(\\u3000+\\\\)\u0026#34;) 行末の空白も表示 通常の半角空白と No Break Space(\u0026amp;nbsp; で表示されるやつ) を行末での可視化対象としている。\n(setq whitespace-trailing-regexp \u0026#34;\\\\([ \\u00A0]+\\\\)$\u0026#34;) タブも入れてもまあいいんだろうけど、別途可視化しているからわざわざ入れなくても良いということでこうしている気がする。\n保存前に自動でクリーンアップ 保存時なんかに自動的に余計な空白を消すような設定。保存する時に、バッファ前後の無駄な空白や末尾の空白なんかを取り除いてくれる。\n(setq whitespace-action \u0026#39;(auto-cleanup)) 実はスペースとタブが混ざってる時などもいい感じに対応してくれそうな雰囲気があるけどそもそもスペースとタブが混ざるような設定にしてないのでそれは観測できてない。\nEmacs 全体で有効化 とまあ、上で設定してきたように、色々可視化されたり余計な空白を処理してくれたりで便利なやつなので、 Emacs 全体で有効にしている。\n(global-whitespace-mode 1) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/programming/yaml-mode/",
	"title": "yaml-mode",
	"tags": [],
	"description": "",
	"content": "概要 yaml-mode は yaml を編集する時のメジャーモード。インデントを調整しやすい。\nインストール いつも通り el-get でインストール\n(el-get-bundle yaml-mode) hook mode に対する hook は関数を定義してその中で呼びたいコードを書いていくようにしている。\nlambda で書いてしまうと hook を弄りたい時に結構面倒なのだけど関数を定義しておくと、その関数の中身を変更して評価しておくだけで hook で動作する中身が変更できて便利。\nとりあえず yaml-mode では以下のようにして highlight-indent-guides を有効にしている。\n(defun my/yaml-mode-hook () (lsp 1) (highlight-indent-guides-mode 1)) で、その hook を最後に yaml-mode-hook に追加している。\n(add-hook \u0026#39;yaml-mode-hook \u0026#39;my/yaml-mode-hook) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/yascroll/",
	"title": "yascroll",
	"tags": [],
	"description": "",
	"content": "概要 yascroll は標準のスクロールバーとは異なるスクロールバーを表示するやつ。\nデフォルトだと右側の fringe 領域に表示するのであまり邪魔にならないし表示領域を必要以上に狭めないので気に入っている。\n最初に作られたっぽい記事は 主張しないスクロールバーモード、yascroll.elをリリースしました - Functional Emacser にある。タイトル通り、あまり主張しない感じで良い。\nインストール いつも通り el-get でインストールしている\n(el-get-bundle yascroll) これだけで大体いい感じに表示されるので便利。たまに表示されなくなることもあるが、まあそこまで重要なやつでもないのであまり気にしていない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/yasnippet/",
	"title": "yasnippet",
	"tags": [],
	"description": "",
	"content": "概要 yasnippet はテンプレートを挿入する機能を持ったパッケージ。 Emacs でそこそこ何かを書いている人なら大体知ってるような有名なやつだと思う。\nインストール いつも通り el-get でインストール\n(el-get-bundle yasnippet) 有効化 どこでも使いたいぐらい便利なやつなので global に有効化している\n(yas-global-mode 1) キーバインド 基本的に覚えられないので Hydra を使って定義している\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define yasnippet-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;Yasnippet\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Edit\u0026#34; ((\u0026#34;n\u0026#34; yas-new-snippet \u0026#34;New\u0026#34;) (\u0026#34;v\u0026#34; yas-visit-snippet-file \u0026#34;Visit\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;i\u0026#34; yas-insert-snippet \u0026#34;Insert\u0026#34;) (\u0026#34;l\u0026#34; yas-describe-tables \u0026#34;List\u0026#34;) (\u0026#34;r\u0026#34; yas-reload-all \u0026#34;Reload all\u0026#34;))))) Key 効果 n 現在のメジャーモード用に新しい snippet を作る v 現在のメジャーモードの登録済 snippet ファイルを開く i snippet の挿入。選択は ivy で行われる。 l 現在のメジャーモードの登録済 snippet の一覧表示 r snippet を全部 load し直す その他 実は、どういう snippet があれば便利なのかよくわかってなくて snippet をほとんど登録してない。\nyasnippet-snippets などのよくある snippet 集は、そんなの省略形をまず覚えられないだろと思っている。 ivy で選択可能なので省略形は長くていいので中身がわかりやすい方が良い。\nまた導入はしてないが ivy-yasnippet を入れるとさらにそのあたりがやりやすくなるんじゃないかと思う。\nそれから company-yasnippet で補完できるようにしているとより良いかもれない。\nとはいえ snippet を充実させてない今だとどうにもイマイチそのあたりを充実させる気力がない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/zoom/",
	"title": "zoom",
	"tags": [],
	"description": "",
	"content": "概要 zoom はフォーカスが当たっている Window が大きく表示されるようにするやつ。最近流行りのビデオチャットツールではない。\nどこにフォーカスが当たっているかわかりやすくなるし、狭い画面でも見たい部分を広げて表示できるので便利。\nインストール el-get のレシピは自前で用意している\n(:name zoom :type github :description \u0026#34;Fixed and automatic balanced window layout.\u0026#34; :pkgname \u0026#34;cyrus-and/zoom\u0026#34; :minimum-emacs-version (24 4)) そして el-get で入れる。 GitHub から直接取得するように設定している。\n(el-get-bundle cyrus-and/zoom) 設定 起動時に有効化 1画面しか使えない時は必須なので 比率を黄金比に変更 この方が使いやすいっぽい。 という設定をしている。\n(custom-set-variables \u0026#39;(zoom-mode t) \u0026#39;(zoom-size \u0026#39;(0.618 . 0.618))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/zoom-window/",
	"title": "zoom-window",
	"tags": [],
	"description": "",
	"content": "概要 zoom-window は tmux の prefix z のような動きをするやつ。表示している window をフレーム全体に広げたり戻したりすることができる。\nインストール いつも通り el-get から入れている\n(el-get-bundle zoom-window) その他 キーバインドは 80-global-keybinds に書いたけど C-x 1 に割り当てている。\nただそれだと tmux と使い勝手が違うなって感じているのでそのうち hydra の中の z にでもアサインしようかと思う。\nあと、その window を最大化して戻すことよりも単に他の window が邪魔なことの方が多い気もしている。。。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/gcmh/",
	"title": "ガベージコレクション",
	"tags": [],
	"description": "",
	"content": "概要 ガベージコレクションには gcmh というのを利用してみている。\nhttps://github.com/emacsmirror/gcmh\n普段は GC を控えめにしながら操作してない間に GC が走るような作りになっている。便利そう。\nインストール (el-get-bundle gcmh) これだけで有効化もされる。\nその他 以前の設定も折り畳んで残しておく\n使わなくなったコード gcmh を入れる前に設定していたコード。 gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。\n;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf ;; Increase threshold to fire garbage collection (setq gc-cons-threshold 1073741824) (setq garbage-collection-messages t) ;; Run GC every 60 seconds if emacs is idle. (run-with-idle-timer 60.0 t #\u0026#39;garbage-collect) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/global-keybinds/",
	"title": "グローバルキーバインド",
	"tags": [],
	"description": "",
	"content": "概要 Emacs では様々なグローバルマイナーモードが存在したりしていていつでも使えるようなコマンドが多数存在するのでここでまとめて定義している。\nが、Hydra 関係もここに書くと項目が大きくなりすぎるので、それはまた別途定義している。\nMac での修飾キー変更 (if (eq window-system \u0026#39;ns) (progn (setq ns-alternate-modifier (quote super)) ;; option =\u0026gt; super (setq ns-command-modifier (quote meta)))) ;; command =\u0026gt; meta C-h を backspace に変更 C-h で文字を消せないと不便なのでずっと昔からこの設定は入れている。\n(keyboard-translate ?\\C-h ?\\C-?) (global-set-key \u0026#34;\\C-h\u0026#34; nil) M-g rをstring-replaceに割り当て string-replace はよく使うのでそれなりに使いやすいキーにアサインしている\n(global-set-key (kbd \u0026#34;M-g r\u0026#34;) \u0026#39;replace-string) replace-regexp もまあまあ使うけどそれはキーを当ててないのでどこかでなんとかしたい。 Hydra 使う?\nC-\\ で SKK が有効になるようにする C-\\ で skk-mode を起動できるようにしている。 C-x C-j の方も設定は生きているが使ってない。っていうか忘れてた。\n(global-set-key (kbd \u0026#34;C-\\\\\u0026#34;) \u0026#39;skk-mode) 余談だけど org-mode とか commit message 書く時とかは自動で有効になるようにしたい気はする。\nC-s を swiper に置き換え デフォルトだと C-s でインクリメンタルサーチが起動するが swiper の方が絞り込みができて便利だしカッチョいいのでそっちを使うようにしている\n(global-set-key (kbd \u0026#34;C-s\u0026#34;) \u0026#39;swiper) window 間の移動 C-x o を ace-window に置き換え C-x o はデフォルトだと順番に window を移動するコマンドだが ace-window を使えばたくさん画面分割している時の移動が楽だし 2分割の時は元の挙動と同様に2つの window を行き来する感じになので完全に置き換えても大丈夫と判断して、置き換えている。\n(global-set-key (kbd \u0026#34;C-x o\u0026#34;) \u0026#39;ace-window) ace-window は他にもコマンドがあって Hydra の方で ace-swap-window は使えるようにしている\nShift+カーソルキーで window 移動 シフトキーを押しながらカーソルキーを押すことでも window を移動できるようにしている\n(windmove-default-keybindings) ただし org-mode のキーバインドとぶつかるので実はあまり使ってないしそろそろ無効にしてもいいんじゃないかなという気もしている\nundo/redo undo と redo には undo-fu を使っている\n(global-set-key (kbd \u0026#34;C-/\u0026#34;) \u0026#39;undo-fu-only-undo) (global-set-key (kbd \u0026#34;C-M-/\u0026#34;) \u0026#39;undo-fu-only-redo) \\ を入力した時に円マークにならないようにする設定 Mac だとデフォルト状態だと \\ を入れると円マークになるのだがプログラムを書く上ではバックスラッシュであってほしいので円マークが入力された時はバックスラッシュが入力されたように扱われるようにしている。\n(define-key global-map [?¥] [?\\\\]) (define-key global-map [?\\C-¥] [?\\C-\\\\]) (define-key global-map [?\\M-¥] [?\\M-\\\\]) (define-key global-map [?\\C-\\M-¥] [?\\C-\\M-\\\\]) ただ、たまに円マークを出したくなる時があるのでその時はどうすべきかという課題がある。\nmultiple-cursors カーソルを複数表示できる multiple-cursors 用のキーバインド。基本的には公式 README に従って設定している。\n;; multiple-cursors (global-set-key (kbd \u0026#34;C-:\u0026#34;) \u0026#39;mc/edit-lines) (global-set-key (kbd \u0026#34;C-\u0026gt;\u0026#34;) \u0026#39;mc/mark-next-like-this) (global-set-key (kbd \u0026#34;C-\u0026lt;\u0026#34;) \u0026#39;mc/mark-previous-like-this) (global-set-key (kbd \u0026#34;C-c C-\u0026lt;\u0026#34;) \u0026#39;mc/mark-all-like-this) Ladicle さんの https://ladicle.com/post/config/#multiple-cursor の設定が便利そうだなって思って気になってるけどまだ試してない。\nHelm 最近はほぼ Ivy に乗り換えてるのでほとんど出番はないのだけど helm-find-file が便利でそこだけ乗り換えできてないのでそれだけ定義がコメントアウトされずに残っている。\n;; (global-set-key (kbd \u0026#34;M-y\u0026#34;) \u0026#39;helm-show-kill-ring) (global-set-key (kbd \u0026#34;C-;\u0026#34;) \u0026#39;helm-for-files) ;; (global-set-key (kbd \u0026#34;M-x\u0026#34;) \u0026#39;helm-M-x) ;; (global-set-key (kbd \u0026#34;C-x b\u0026#34;) \u0026#39;helm-mini) ;; (global-set-key (kbd \u0026#34;C-x C-f\u0026#34;) \u0026#39;helm-find-files) Ivy Helm から乗り換えて今はこちらをメインで使っている。基本的には既存のキーバインドの持っていた機能が強化されるようなコマンドを代わりに割り当てている。デフォルトより良い感じで良い。\n(global-set-key (kbd \u0026#34;M-x\u0026#34;) \u0026#39;counsel-M-x) (global-set-key (kbd \u0026#34;M-y\u0026#34;) \u0026#39;counsel-yank-pop) (global-set-key (kbd \u0026#34;C-x b\u0026#34;) \u0026#39;counsel-switch-buffer) (global-set-key (kbd \u0026#34;C-x C-f\u0026#34;) \u0026#39;counsel-find-file) Key 効果 M-x コマンド実行。絞り込みができるのでコマンド名がうろ覚えでも実行できて便利 M-y kill-ring の候補表示。適当に複数 kill-ring に入れておいてこれを起動して絞り込んで貼り付けとかできて便利 C-x b バッファ切替。これも適当にバッファを絞り込めて便利 C-x C-f find-file の置き換え。ido より便利な感じの絞り込み選択ができる。 zoom-window zoom-window は tmux の zoom 機能のように選択している window だけを表示したり戻したりができるパッケージ。\n(global-set-key (kbd \u0026#34;C-x 1\u0026#34;) \u0026#39;zoom-window-zoom) 実は戻すことがあんまりないので、このキーバインドは戻してもいいかもしれないなと思っていたりする。\nneotree Neotree は IDE みたいにファイルツリーを表示を表示するパッケージ。有効にしているとちょっぴりモダンな雰囲気になるぞい。\n(global-set-key [f8] \u0026#39;neotree-toggle) f8 にバインドしているけど Helm でも起動できるようにしているので、こっちの設定は外してもいいかもなとか思っている。\norg-mode みんな大好き org-mode 用にもキーバインドを設定している。\n(setq my/org-mode-prefix-key \u0026#34;C-c o \u0026#34;) (global-set-key (kbd (concat my/org-mode-prefix-key \u0026#34;a\u0026#34;)) \u0026#39;org-agenda) (global-set-key (kbd (concat my/org-mode-prefix-key \u0026#34;c\u0026#34;)) \u0026#39;org-capture) (global-set-key (kbd (concat my/org-mode-prefix-key \u0026#34;l\u0026#34;)) \u0026#39;org-store-link) けど org-mode 用の Hydra も用意しているのでこれもそろそろ削除かな……\nkeychord keycohrd は2つのキーを同時押しというキーバインドを実現するパッケージ。麦汁は https://github.com/zk-phi/key-chord/ のバージョンを利用している。\nとりあえず jk を入力するとグローバルに使いたいコマンドを載せた Hydra が起動するようにしている。めっちゃ使ってる。便利。\n(key-chord-define-global \u0026#34;jk\u0026#34; \u0026#39;pretty-hydra-usefull-commands/body) yes or no ではなく y or n で質問する 何か質問された時に yes とか入力するのがだるいので y だけで済ませられるようにしている。\n;; Don\u0026#39;t ask yes or no. (defalias \u0026#39;yes-or-no-p \u0026#39;y-or-n-p) 一応 Emacs 的には重要なのは yes/no で回答するようになっていたはずなのでより安全に使いたい人はこの設定は入れない方が良いはず。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/browse-url/",
	"title": "ブラウザ設定",
	"tags": ["unused"],
	"description": "",
	"content": "browse-url の時の開くプログラムの指定。\n(setq browse-url-generic-program \u0026#34;vivaldi\u0026#34;) Vivaldi を指定しているが、最近 Emacs から何かブラウザ立ち上げても Firefox がいつも開いているし、この設定ほんとうに生きてる? って感じ。\nWSL2 を入れてる Windows の方は Vivladi 入れてないし Mac の方は入れてるけど別に Emacs から Vivaldi が立ち上がるのも観測してないしほんと謎……。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/load-libraries/",
	"title": "ライブラリの読み込み",
	"tags": [],
	"description": "",
	"content": "設定ファイル内で文字列操作をするだろうということで s.el を読み込んでいる。\n(el-get-bundle s) (require \u0026#39;s) けど、どういう関数があったか覚えてないぐらいには使ってない……。ま、あると便利なのでそのまま入れておくつもり。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/",
	"title": "麦汁&#39;s Emacs Config",
	"tags": [],
	"description": "",
	"content": "ここは @mugijiru の Emacs の設定ファイルの一部を解説しているページです。\nhttps://github.com/mugijiru/.emacs.d/blob/master/init.org から ox-hugo を使ってWebサイトに仕立て上げています。\n動作確認環境 主に以下の環境で使用しています。が、動作を保証するものではありません。\nManjaro Linux 23.0.0 pacman で手に入る Emacs 28.2 また macOS や Ubuntu 20.04 LTS で利用していたのでところどころにそのあたりの設定も残っています\n注意点 まだ全ての設定を init.org に記載できていない上に init.org からの出力設定も済ませていないので極一部の設定ファイルのみの解説となります。\n"
}]