[
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/",
	"title": "with-simulated-input",
	"tags": [],
	"description": "",
	"content": "概要 with-simulated-input は入力処理をシミュレートするためのプラグイン。\n公式のドキュメントにあるように\n(with-simulated-input \u0026#34;hello SPC world RET\u0026#34; (read-string \u0026#34;Say hello to the world: \u0026#34;)) を評価すると read-string に対して「hello world」を入力したことになるので echo エリアに「hello world」と表示される。\nこれで何が嬉しいかというと Emacs Lisp でやっていることはインタラクティブな部分が大きいのでそういった要素をテストできるようになる。\n具体的な使用例は test:my/org-todo で示す。\nインストール el-get-bundle で GitHub からインストールしている\n(el-get-bundle DarwinAwardWinner/with-simulated-input) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/",
	"title": "基本設定",
	"tags": [],
	"description": "",
	"content": "Emacs の基本動作に関わる部分をここでは設定している\n auto-save 編集中状態の自動保存や編集前の状態のバックアップに関する設定 auth-source 認証情報の取り扱いファイルの設定 exec-path PATH などの環境変数を shell と合わせる設定 font-config フォントの設定 load-path Emacs Lisp が読み込める path の設定 savehist ミニバッファの履歴などを保存してくれる機能。 ガベージコレクション メモリの開放関係の設定  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/execution/",
	"title": "実行方法",
	"tags": [],
	"description": "",
	"content": "テストする時は以下のように叩いたら動く。\nemacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el 今まで .emacs.d にいる状態でしか叩いたことないので他の場所にいる時に実行しても大丈夫かはわからない。\n単体でテストしたい時は\n-l ~/.emacs.d/inits/test/*-test.el の部分を書き換えたらいいんじゃないかな。やったことないけど。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/",
	"title": "mocker.el",
	"tags": ["unused"],
	"description": "",
	"content": "概要 mocker.el は Emacs Lisp のテストで使う Mock ライブラリ。\n使おうと思って導入したけど、自分のやりたいことはちょっと違ったので死蔵中\n便利そうなのでとりあえず置いといている。\nインストール el-get で GitHub から取得している。\n(el-get-bundle sigma/mocker.el) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/run-tests/",
	"title": "run-tests",
	"tags": [],
	"description": "",
	"content": "読み込んだテストをまるっとテストするためのコードをとりあえず置いている。\n(if noninteractive (let ((ert-quiet t)) (ert-run-tests-batch-and-exit))) 後述の テストライブラリの読み込み などはここで担うべきかとも考えるが今はテストファイルが1つしかないので気にしないことにする。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/",
	"title": "キーバインド",
	"tags": [],
	"description": "",
	"content": "ここでは全体に関わるキーバインド系の設定を記載している。\n Google 連携 Google 連携する機能のキーバインドをまとめている key-chord 同時押しというキーバインドを提供してくれるやつ sticky-control Control の入力を sticky にしてくれるやつ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/",
	"title": "my-org-commands-test",
	"tags": [],
	"description": "",
	"content": "org-mode 用に定義したコマンドや関数のテストコード\nSetup テストライブラリの読み込み 標準でついてくる ert を採用しているのでそれを読み込んでいる。\n(require \u0026#39;ert) el-get の設定の読み込み プラグイン管理には el-get を利用しているのでその設定ファイルを読み込んでいる。\n;; プラグイン読み込みの前準備 (load (expand-file-name (concat user-emacs-directory \u0026#34;/init-el-get.el\u0026#34;))) テスト補助のプラグイン読み込み with-simulated-input 上で説明しているが、入力をシミュレートするためのプラグインをテストで利用しているのでここで読み込んでいる。\n;; 入力シミュレート用のプラグイン (load (expand-file-name (concat user-emacs-directory \u0026#34;/inits/99-with-simulated-input\u0026#34;))) 依存プラグインの読み込み テスト対象が依存しているプラグインを読み込んでいる。本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが現状だとその状態で GitHub Actions で動かせる方法がわからないので一旦個別に読み込むようにしている。\nswiper ivy-read を使った機能のテストをするので読み込んでいる。\n(el-get-bundle abo-abo/swiper) テスト対象の読み込み テストしたいファイルをここで読んでる。\n;; テスト対象の読み込み (load (expand-file-name (concat user-emacs-directory \u0026#34;/inits/68-my-org-commands.el\u0026#34;))) ert-deftest test:my/org-todo-keyword-strings org-todo-keywords から \u0026ldquo;|\u0026rdquo; という区切りを除外したり \u0026ldquo;(s)\u0026rdquo; とかのような高速アクセスのためのキーワードは ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。\n(ert-deftest test:my/org-todo-keyword-strings () \u0026#34;Test of `my/org-todo-keyword-strings\u0026#39;.\u0026#34; (let ((org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;)))) (should (equal \u0026#39;(\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;DONE\u0026#34; \u0026#34;SOMEDAY\u0026#34;) (my/org-todo-keyword-strings))))) なお、ここでテストしている関数では TODO キーワードを ivy で扱いやすいように整えているだけで実際の選択は別の関数が担っている\ntest:my/org-todo org-todo を ivy で選択する関数のテストを書いている。\n(ert-deftest test:my/org-todo () \u0026#34;Test of `my/org-todo\u0026#39;.\u0026#34; (let ((org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;))) (result)) ;; org-mode を読まずに済むように org-todo を差し替えてテストしている (cl-letf (((symbol-function \u0026#39;org-todo) (lambda (keyword) (setq result keyword)))) (with-simulated-input \u0026#34;DOI RET\u0026#34; (my/org-todo)) (should (equal \u0026#34;DOING\u0026#34; result))))) ポイントは cl-letf を使って、内部で叩いている関数 org-todo を一時的に\n(lambda (keyword) (setq result keyword)) に差し替えているところ。\norg-mode を呼び出さずに代わりの関数に差し替えているのでテストがしやすくなっている。Stub 的なやつかな。\n何度も使うならこの差し替え処理自体をテストヘルパーにしても良いかもしれない。\nまた ivy で選択するので with-simulated-input を使って入力操作を代替している。便利。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/",
	"title": "ファイル編集/入力補助",
	"tags": [],
	"description": "",
	"content": "ここにはファイル編集や入力補助の設定をまとめている\n auto-insert ファイル新規作成時にテンプレートを挿入する機能 company-mode プラグイン拡張方式を採用した、入力補完インターフェースを提供してくれるやつ smartparens カッコや引用符などのペアになるやつの入力補助をしてくれるやつ undo-fu シンプルな undo/redo の機能を提供してくれるやつ yasnippet テンプレート挿入機能を提供してくれるやつ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/",
	"title": "UI",
	"tags": [],
	"description": "",
	"content": "ここでは Emacs の UI を変更するようなものを載せている\n alert 共通インターフェースで色々な通知機能と連携して通知するやつ all-the-icons Emacs で様々なアイコンを表示できるようにするやつ git-gutter-fringe 最後のコミットからどう弄ったかを fringe 領域に表示してくれるやつ helm 絞り込みインターフェースを提供するやつ helm-posframe Helm を posframe で使えるようにするやつ highlight-indent-guides インデント毎にラインを引いたりして見易くしてくれるやつ hydra サブコマンドをビジュアル的に表示してくれるメニューを提供してくれるやつ Neotree フォルダ構造を IDE みたいにツリー表示するやつ posframe いい感じの位置に child frame を表示する機能を提供するやつ show-paren-mode 対応するカッコとコッカをハイライトしてくれたりするやつ toolbar Emacs 標準のボタンなどの UI 部分の設定 uniquify 同名ファイルを開いている時にどこのファイルかまで表示してくれるやつ yascroll 主張の大人しいスクロールバーを表示してくれるやつ zoom フォーカスが当たってるウインドウを大きく表示してくれるやつ zoom-window 見ている window を最大化したり戻したりしてくれるやつ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/",
	"title": "ナビゲーション",
	"tags": [],
	"description": "",
	"content": "ここではカーソル移動やファイル移動などのナビゲーション系の設定を記載していく\n ace-window 3つ以上にウインドウを分割している際のウインドウ切替を楽にしてくれるパッケージ avy 表示されてるところの好きな場所にさくっとジャンプするためのパッケージ browse-at-remote 表示している行の GitHub などのサービス上の位置でブラウザで開いてくれるパッケージ dumb-jump カーソル下の関数とかの定義場所にジャンプしてくれるパッケージ projectile プロジェクト内のファイルなどを開いたりするのに便利なパッケージ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/language-config/",
	"title": "言語毎の設定",
	"tags": [],
	"description": "",
	"content": "ここでは各言語毎の設定をまとめている\n es6 ES2015 以降の JS に関する設定。es6 としているのは過去の経緯のため。 markdown Markdown を書く時の設定 plantuml-mode PlantUML を書く時のメジャーモードの設定 yaml-mode YAML を書く時のメジャーモードの設定  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/framework-config/",
	"title": "フレームワーク用の設定",
	"tags": [],
	"description": "",
	"content": "開発に使っている各フレームワーク用の設定をここにまとめている。\n Ember.js Web フロントエンド MVC フレームワークである Ember.js 用の設定を書いている  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/",
	"title": "外部連携ツール設定",
	"tags": [],
	"description": "",
	"content": "ここでは外部のサービスと連携するようなやつをまとめています\n forge magit と GitHub を連携して Emacs 上で PR を眺めたりできるようにするパッケージ google-this Google 検索機能を提供してくれるパッケージ google-translate Emacs から Google 翻訳するためのパッケージ magit Emacs 上で Git の操作をするのにとても便利なパッケージ wakatime-mode Emacs と WakaTime を連携してどのプロジェクトの作業をどのぐらいしてたかを計測するパッケージ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/",
	"title": "テスト用ツール",
	"tags": [],
	"description": "",
	"content": "自動テストを実行するにあたり、追加インストールしているパッケージをここに載せている\n with-simulated-input 入力処理をシミュレートしてくれるパッケージ mocker.el Mock/Stub するためのパッケージ。まだ使ってない  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/",
	"title": "テストコード",
	"tags": [],
	"description": "",
	"content": "一部のコマンドなどの設定を書き始めているので設けたセクション。\n暫定的にここに置いているが設定と近い方が良さそうなのでいずれドキュメント内の位置を移動しそう。\n 実行方法 とりあえず書かれているテストを動かす方法を書いている。 run-tests テスト全体を動かすための共通設定ファイルの説明 my-org-commands-test org-mode 用に自分が生やしたコマンドのテストファイルの解説  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/ace-window/",
	"title": "ace-window",
	"tags": [],
	"description": "",
	"content": "概要 Window 間の移動を ace-jump や avy のように表示されてる文字の Window に移動するやつ。\nWindow が2分割の時は文字も出ないで別の Window に移動してくれる。\nC-x o にデフォルトで設定されている other-window は別の window に順番に移動するコマンドなので大量に分割していると移動がしんどいのだが ace-window を使うと起動して 1 ストロークで移動できるので C-x o をデフォルトの other-window から ace-window そのまま置き換えても便利に使える。\nインストール いつも通り el-get でインストールしている。\n(el-get-bundle ace-window) 設定 キーバインドは別の箇所で定義しているが C-x o で ace-window が起動するようにしている。\nまた Hydra からは ace-swap-window が起動できるようにしている。\nace-window には色々な機能があるからそれ用の Hydra を別途定義してもいいかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/alert/",
	"title": "alert",
	"tags": [],
	"description": "",
	"content": "概要 alert は色々な通知システムに対応した通知を飛ばせるパッケージ。 Mac だと Growl だったり terminal-notifier だったり Win だと toast だったり Linux だと libnotify だったりを使ってその環境での標準的な通知機能を使って通知ができるやつ。\nインストール いつも通りに el-get でインストール。\n(el-get-bundle alert) 設定 業務では Mac を使ってるので terminal-notifier を設定している。他の環境では大人しく message にしている。\n(if (or (eq window-system \u0026#39;ns) (eq window-system \u0026#39;mac)) (setq alert-default-style \u0026#39;notifier) ;; use terminal-notifier (setq alert-default-style \u0026#39;message)) 本当は WSL2 でもいい感じに通知されるようにしたいが WSLで通知を出すメモ - cobodoのブログ とかを見てるとちょっと面倒そうなのでまた今度にする。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/all-the-icons/",
	"title": "all-the-icons",
	"tags": [],
	"description": "",
	"content": "概要 all-the-icons は Emacs で様々なアイコンを表示できるようにして華やかにしてくれるパッケージです。 Neotree などでも対応していてアイコンでファイルの種類が表示されるようになってモダンな雰囲気が出ます。\nインストール いつも通り el-get-bundle で入れている。明示的に require している理由は忘れました。\n(el-get-bundle all-the-icons) (require \u0026#39;all-the-icons) フォントのインストール 以下のコマンドを叩くことでフォントをインストールすることができる。 all-the-icons のインストール直後に叩いておいたら普段は叩かなくて良いはず。\n(all-the-icons-install-fonts) all-the-icons の更新後は叩いた方がいいかもしれない\nキーバインド キーバインドは覚えられないし、使えるキーも大分埋まってるので、 pretty-hydra を使って all-the-icons 用の Hydra を用意している。\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define all-the-icons-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;All the icons\u0026#34; :exit t :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Insert\u0026#34; ((\u0026#34;a\u0026#34; all-the-icons-insert-alltheicon \u0026#34;All the icons\u0026#34;) (\u0026#34;f\u0026#34; all-the-icons-insert-fileicon \u0026#34;File icons\u0026#34;) (\u0026#34;F\u0026#34; all-the-icons-insert-faicons \u0026#34;FontAwesome\u0026#34;) (\u0026#34;m\u0026#34; all-the-icons-insert-material \u0026#34;Material\u0026#34;) (\u0026#34;o\u0026#34; all-the-icons-insert-octicon \u0026#34;Octicon\u0026#34;) (\u0026#34;w\u0026#34; all-the-icons-insert-wicon \u0026#34;Weather\u0026#34;) (\u0026#34;*\u0026#34; all-the-icons-insert \u0026#34;All\u0026#34;)))))    Key 効果     a all-the-icons で追加されてるアイコンを検索して挿入   f ファイルアイコンを検索して挿入   F FontAwesome アイコンを検索して挿入   m Material アイコンを検索して挿入   o Octicon のアイコンを検索して挿入   w 天気アイコンを検索して挿入   * 全てのアイコンを検索して挿入    フォントのインストールコマンドもここに収めてしまうのが良さそうな気がする\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/auth-source/",
	"title": "auth-source",
	"tags": [],
	"description": "",
	"content": "概要 auth-source は Emacs でパスワードのような秘匿情報を扱うための仕組み。 Emacs の各パッケージが認証情報を要求する時にこいつ経由で取得できるようにしておくと秘匿もできて便利っぽい。\nパスワードの保存先はデフォルトだと (\u0026quot;~/.authinfo\u0026quot; \u0026quot;~/.authinfo.gpg\u0026quot; \u0026quot;~/.netrc\u0026quot;) となっている。\n拡張子が gpg だと EagyPG Assistant で保存時に暗号化されるので便利。\nファイル指定 自分は Emacs でしか使わないであろう情報ということで /.emacs.d/.authinfo.gpg を指定している。\n(custom-set-variables \u0026#39;(auth-sources (quote (\u0026#34;~/.emacs.d/.authinfo.gpg\u0026#34;)))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/auto-insert/",
	"title": "auto-insert",
	"tags": [],
	"description": "",
	"content": "概要 auto-insert はファイルを新規作成した時にファイル名に応じたテンプレートを挿入する機能。\nEmacs が標準で持ってるライブラリなのでインストールは不要\n設定 Emacs の設定は .emacs.d の中に閉じ込めたいので auto-insert のテンプレートも ~/.emacs.d/insert に閉じ込める設定にしている。\n(custom-set-variables \u0026#39;(auto-insert-directory \u0026#34;~/.emacs.d/insert/\u0026#34;)) 有効化 あとは単に有効化している。\n(auto-insert-mode 1) 他の設定 ファイル名を正規表現でマッチさせてテンプレートが選択されるので各言語やフレームワーク毎に設定を入れることにしている。\n実際は今のところ inits/41-vue.el でのみ追加設定を入れている。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/auto-save/",
	"title": "auto-save",
	"tags": ["replacement"],
	"description": "",
	"content": "概要 編集中状態の自動保存や、編集前や保存直後の状態のバックアップに関する設定をここでは書いている。\nEmacs ではデフォルトでも編集中ファイルの自動保存や、編集前の状態の自動バックアップもしてくれるが開いているファイルとは違う場所に保存したりすることで、より便利になるのでいくつかの設定を入れている。\n設定 自動保存設定 デフォルトだと #hoge.txt# みたいなファイル名で作られる、自動保存に関する設定。\nまあこの自動保存されてやつを活用できてる気がしないのでこの自動保存自体不要な気はしているが、とりあえず場所を移動して邪魔にはならないようにはしている。\n自動保存のタイミング 自動保存のタイミングは\n auto-save-timeout auto-save-interval  で制御されている。\nまず auto-save-timeout で設定した秒数が経過すると再度自動保存が実行される。\nこれがデフォルトだと 30 秒なのだが、ちょっと長いのでその半分の 15 秒で保存されるように設定を変更している。\n(setq auto-save-timeout 15) また auto-save-interval で設定した回数のキーイベントが発生すると再度自動保存を実行する。\nこれもデフォルトだと 300 と結構なキーを叩く必要があるので 60 回としている。\n(setq auto-save-interval 60) 自動保存先を変更する 自動保存はそのままだと弄ってるファイルの場所に作られる。が、これは以下のようにすると ~/.emacs.d/backup/ 一応変更可能。\n(setq auto-save-file-name-transforms \u0026#39;((\u0026#34;.*\u0026#34; \u0026#34;~/.emacs.d/backup/\u0026#34; t))) ただ、デフォルト値が\n((\u0026#34;\\\\`/[^/]*:\\\\([^/]*/\\\\)*\\\\([^/]*\\\\)\\\\\u0026#39;\u0026#34; \u0026#34;/tmp/\\\\2\u0026#34; t)) なので .* にしているのは乱暴そうな気がしている。\nというわけで https://masutaka.net/chalow/2014-05-11-1.html に書かれているのを真似して\n((\u0026#34;~/\\\\([^/]*/\\\\)*\\\\([^/]*\\\\)$\u0026#34; \u0026#34;~/.emacs.d/backup/\\\\2\u0026#34; t)) とでもした方が良いかもしれない。\nバックアップファイル 自動保存とは別に、ファイルを開いた時点のバージョンや保存した時点のバージョンを取っておいてくれる自動バックアップ機能もあるのでその設定も弄っている。\nバックアップ先のフォルダ指定 デフォルトでは編集しているファイルと同じフォルダにバックアップファイルを作成するようになっている。\nだけど、こいつが結構邪魔なのでバックアップファイルは ~/.emacs.d/backup/ に全部保存するようにしている。\nまた、普段 tramp は使っていないが何かの拍子で使った時にバックアップが取られると邪魔そうなのでそれは保存しないようにしている。\n(setq backup-directory-alist \u0026#39;((\u0026#34;.*\u0026#34; . \u0026#34;~/.emacs.d/backup\u0026#34;) (,tramp-file-name-regexp . nil))) バージョン管理 バックアップにはバージョン管理機能もある。が、標準では無効化されている。\nとりあえず古いバージョンを引っ張り出せると便利かもと思って有効化している。\n(setq version-control t) が、実際それを使ったことはない。。。\nまた、古過ぎるバックアップファイルは要らないので、自動的に消されるように設定している。\n(setq delete-old-versions t) その他 Emacs の自動保存などについては http://yohshiy.blog.fc2.com/blog-entry-319.html によくまとめられているので、いずれその内容を設定に反映させたい。\nまた super-save というやつを使って実ファイルに自動保存したりしたらこれも不要になると思われる。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/avy/",
	"title": "avy",
	"tags": [],
	"description": "",
	"content": "概要 avy は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。 Vimium の f とかに似てる。\nインストール el-get で普通にインストールしている\n(el-get-bundle avy) 設定 文字の上に重なると元の文字列がよくわからなくなるので、移動先の文字の前に表示するようにしている\n(setq avy-style \u0026#39;pre) キーバインド グローバルなキーバインドを汚染したくなかったのでひとまず Hydra を定義している。\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define avy-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;avy\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Char\u0026#34; ((\u0026#34;c\u0026#34; avy-goto-char \u0026#34;Char\u0026#34;) (\u0026#34;C\u0026#34; avy-goto-char-2 \u0026#34;Char 2\u0026#34;) (\u0026#34;x\u0026#34; avy-goto-char-timer \u0026#34;Char Timer\u0026#34;)) \u0026#34;Word\u0026#34; ((\u0026#34;w\u0026#34; avy-goto-word-1 \u0026#34;Word\u0026#34;) (\u0026#34;W\u0026#34; avy-goto-word-0 \u0026#34;Word 0\u0026#34;)) \u0026#34;Line\u0026#34; ((\u0026#34;l\u0026#34; avy-goto-line \u0026#34;Line\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;r\u0026#34; avy-resume \u0026#34;Resume\u0026#34;)))))    Key 効果     c 1文字からの絞り込み   C 2文字から絞り込み   x 任意の文字列からの絞り込み   w 1文字絞り込んで単語先頭に移動   W 絞り込みなしの単語移動   l 列移動   r 繰り返し同じコマンドを実行    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/browse-at-remote/",
	"title": "browse-at-remote",
	"tags": [],
	"description": "",
	"content": "概要 browse-at-remote は Emacs で見ているファイルについて GitHub や GitLab などのサービス上での該当ブランチ、該当ファイル、該当行を開いてくれる便利なやつ。\n業務だとレビュー中に「ここにこういう関数あるよ」みたいに示すことがあるけどその時に Emacs 内で関数を探して browse-at-remote で GitHub 上の位置を開くことでそこへのリンクを拾いやすく便利。\nインストール いつも透り el-get で入れている。\n(el-get-bundle browse-at-remote) 使い方 ブラウザで見たい行の上で M-x browse-at-remote を実行する。\nまたは Region を選択している状態で実行すると、その範囲を選択している状態で開いてくれる。便利。\nその他 Hydra でいつでも使えるようにキーバインドを割り当てている。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/company-mode/",
	"title": "company-mode",
	"tags": [],
	"description": "",
	"content": "概要 company-mode は Emacs での補完機能を提供してくれるパッケージです。プラグイン式に拡張しやすいのが特徴っぽい。\nインストール いつも透り el-get から入れている\n(el-get-bundle company-mode) 設定 ほとんど設定は入れていない。有効な時に C-s を入力すると検索ができる程度。\nというのも最近の更新で、デフォルトが結構好みのキーバインドになったのでキーバインドはこだわる必要がなくなったのと、ついでに色もそこで好みな感じになってくれた。\nというわけで設定は以下のようにとてもシンプル。\n(with-eval-after-load \u0026#39;company ;; active (define-key company-active-map (kbd \u0026#34;C-s\u0026#34;) \u0026#39;company-search-candidates)) その他 グローバルでは有効にしていなくて各モードで有効にするような hook を入れている。\nグローバルで有効でもいい気がしている。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/dumb-jump/",
	"title": "dumb-jump",
	"tags": [],
	"description": "",
	"content": "概要 dumb-jump は関数とかの定義されてる場所にお手軽にジャンプできるようにするパッケージ。めっちゃ色々な言語をサポートしている。\nインストール いつも通り el-get でインストールしている。\n(el-get-bundle dumb-jump) 設定 デフォルトプロジェクトの変更 デフォルトだと ~/ がデフォルトプロジェクトらしいがそんなに上の階層から調べられてもしょうがない気がするのでソースコードを置いているフォルダを指定している。\n(setq dumb-jump-default-project \u0026#34;~/projects\u0026#34;) 複数マッチした時に使う絞り込み 最近はできるだけ ivy を使うようにしているので dumb-jump でも ivy を使うように指定している。\n(setq dumb-jump-selector \u0026#39;ivy) キーバインド README に書いている hydra の設定をほぼパクってるけど pretty-hydra を使ってキーを定義している\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define dumb-jump-pretty-hydra (:foreign-keys warn :title \u0026#34;Dumb jump\u0026#34; :quit-key \u0026#34;q\u0026#34; :color blue :separator \u0026#34;-\u0026#34;) (\u0026#34;Go\u0026#34; ((\u0026#34;j\u0026#34; dumb-jump-go \u0026#34;Jump\u0026#34;) (\u0026#34;o\u0026#34; dumb-jump-go-other-window \u0026#34;Other window\u0026#34;)) \u0026#34;External\u0026#34; ((\u0026#34;e\u0026#34; dumb-jump-go-prefer-external \u0026#34;Go external\u0026#34;) (\u0026#34;x\u0026#34; dumb-jump-go-prefer-external-other-window \u0026#34;Go external other window\u0026#34;)) \u0026#34;Lock\u0026#34; ((\u0026#34;l\u0026#34; dumb-jump-quick-look \u0026#34;Quick look\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;b\u0026#34; dumb-jump-back \u0026#34;Back\u0026#34;)))))    Key 効果     j 定義場所にジャンプ   o 定義場所を別 window で開く   e 定義場所にジャンプ。ただし同じファイルより外部ファイルとのマッチを優先   x 定義場所を別 window で開く。ただし同じファイルより外部ファイルとのマッチを優先   l クイックルック。定義をツールチップ表示する   b 最後にジャンプされた場所に戻る。今は既に obsolute 扱い    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/framework-config/ember-js/",
	"title": "Ember.js",
	"tags": [],
	"description": "",
	"content": "概要 Ember.js 用の Emacs の拡張としては ember-mode と handlebars-mode が存在する\nember-mode ember-mode は Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。実は麦汁さんは使えてない。\nインストールするだけではダメで、 ember-mode を明示的に起動しないといけない。\nそのためには dir-locals を使うとか projectile なんかがやってるようにフォルダ構成から判定させるみたいなことが必要そう。だるい。\nというわけで死蔵中。\nついでにいうとキーバインドもだるい系なので使う時は Hydra を用意した方が良さそう\n(el-get-bundle madnificent/ember-mode) handlebars-mode handlebars-mode は Ember.js のテンプレートエンジンとして採用されている Handlebars を書くためのモード。\nsyntax highlight と、いくつかの編集機能を備えている。が、今のところ麦汁さんは syntax highlight しか使えてない。\n編集コマンドは major-mode-hydra で使えるようにしてあげれば良さそう\n(el-get-bundle handlebars-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/language-config/es6/",
	"title": "es6",
	"tags": [],
	"description": "",
	"content": "概要 ES5 以前ではない JS を書くための設定。 es6 といいつつ ES2016(ES7) などもこの設定のまま書いている。\nsprockets-es6 を使って ES6 対応をしていた時に es6 という拡張子を使っていたのでこのファイル名になっている。\nインストール es6 はつまり JS なのでとりあえず el-get で js2-mode を入れている。\n(el-get-bundle js2-mode) Hook  flycheck を有効にしてリアルタイムに文法チェックをしている  また javascript-eslint を使いたいので他2つは disable にしている   company-mode で補完できるようにしている smartparens-strict-mode でカッコなどの入力補助をしている インデントは空白2文字としている   (defun my/js2-mode-hook () (flycheck-mode 1) (setq flycheck-disabled-checkers \u0026#39;(javascript-standard javascript-jshint)) (company-mode 1) (turn-on-smartparens-strict-mode) (setq js2-basic-offset 2)) という Hook 用関数を用意しておいて\n(add-hook \u0026#39;js2-mode-hook \u0026#39;my/js2-mode-hook) という感じで js2-mode-hook に追加している。\nLambda で一括でやる方法もあるけども、関数名つけて分離しておくと中身を簡単に入れ替えられて便利。\nes6 を js2-mode で扱うようにする (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.es6$\u0026#34; . js2-mode)) 他に気になるツール xref-js2 https://github.com/js-emacs/xref-js2\nコード間の移動が楽になるかもしれない。けど dumb-jump があるから別に要らない気もする\njs2-refactor https://github.com/js-emacs/js2-refactor.el\nリファクタリングツール。キーバインドは覚えるのつらそうだから Hydra を用意する必要がありそう。\nskewer-mode https://github.com/skeeto/skewer-mode\nWeb ブラウザと連携して JS の評価をしたりとかしてくれたり一部の変更を反映してくれたりするらしい。\n保存したら自動リロードされる環境はともかくそうじゃない環境だと楽かもしねあい。\njs-import https://github.com/jakoblind/js-import\nimport を書くのを楽にしてくれるっぽい。\nindium https://github.com/NicolasPetton/indium\nNode.js と連携してステップ実行とかができるようになるらしい。便利そう。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/exec-path/",
	"title": "exec-path",
	"tags": [],
	"description": "",
	"content": "概要 Emacs は通常最小限の環境変数しか利用しないようになっている。\nが、それだと普段使う上で「ああ、このコマンドが使えなくてもどかしい……!」と感じてしまう。\nそこで exec-path-from-shell というのを使って Emacs が見える PATH 環境変数をシェルが見てる PATH 環境変数と揃うようにしている。\nインストール いつも通り el-get からインストールしている\n(el-get-bundle exec-path-from-shell) 有効化 理由は忘れたが Mac の環境でのみ有効化している。その内 Linux 環境でも有効化を試みた方が良さそう\n(when (memq window-system \u0026#39;(mac ns)) (exec-path-from-shell-initialize)) なお、これでシェルと共通の環境変数が使われるようになるのは デフォルトでは PATH と MANPATH のみである\nその他 なぜか以下のようなコメントを書いていた。普段使っている zsh で持ってる PATH は使わないのだろうか? :thinking_face:\n;; for exec path ;; use .bashrc setted path "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/font-config/",
	"title": "font-config",
	"tags": [],
	"description": "",
	"content": "概要 Emacs で利用するフォントの設定。それなりの設定をしないとガタついたりするので通常あまり手を入れないで済ませている。\n設定 Mac では 14, それ以外(Linux) では 12 を基準としている。\nMac と Linux で基準のサイズを変えているがなぜかこの方がガタガタもしないし大き過ぎもしないしでいい感じになる。\n(let* ((size (if (or (eq window-system \u0026#39;ns) (eq window-system \u0026#39;mac)) 14 12)) (asciifont \u0026#34;Ricty Diminished\u0026#34;) ; ASCII fonts (jpfont \u0026#34;Ricty Diminished\u0026#34;) ; Japanese fonts (h (* size 10)) (fontspec (font-spec :family asciifont)) (jp-fontspec (font-spec :family jpfont))) (set-face-attribute \u0026#39;default nil :family asciifont :height h) (set-fontset-font nil \u0026#39;japanese-jisx0213.2004-1 jp-fontspec) (set-fontset-font nil \u0026#39;japanese-jisx0213-2 jp-fontspec) (set-fontset-font nil \u0026#39;katakana-jisx0201 jp-fontspec) (set-fontset-font nil \u0026#39;(#x0080 . #x024F) fontspec) (set-fontset-font nil \u0026#39;(#x0370 . #x03FF) fontspec)) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/forge/",
	"title": "forge",
	"tags": [],
	"description": "",
	"content": "概要 forge は magit と github を連携させるやつ。一応入れているけど実は使えてないのであまりこの設定を呼んでも意味はなさそう\nインストール いつも通り el-get でインストール\n(el-get-bundle forge) 読み込み magit の拡張なので magit を読み込んで後に読み込まれるようにしている\n(with-eval-after-load \u0026#39;magit (require \u0026#39;forge)) その他 リポジトリのコミット数が多いとまともに使えない感じだけどどうしたらいいの。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/git-gutter-fringe/",
	"title": "git-gutter-fringe",
	"tags": ["improvement"],
	"description": "",
	"content": "概要 git-gutter-fringe は git-gutter の派生版。最後のコミットからどの行を弄ったかを fringe 領域に表示してくれる。\n他にも hunk の操作をできる機能とかあるみたいだけどそのあたりは使ったことがない……。\n派生元の git-gutter は linum-mode と同じ領域を使って描画をしているようで併用ができなかったので git-gutter-fringe を利用している。\nが、Emacs 26 から display-line-numbers-mode が搭載されて linum-mode が不要になったので git-gutter に乗り換えても良さそう\nインストール いつも通り el-get でインストールしている\n(el-get-bundle git-gutter-fringe) 有効化 Git 管理しているやつは全部差分情報が表示されて欲しいのでグローバルマイナーモードを有効にしている。\n(global-git-gutter-mode t) その他 git-gutter ほどではないけど多少のカスタマイズはできるはずだがデフォルト設定で特に不満はないので何もしてない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/google-integration/",
	"title": "Google 連携",
	"tags": [],
	"description": "",
	"content": "概要 Google と連携するパッケージとして google-this と google-translate を入れているが、どっちも Google を使うので1つの Hydra にまとめていた方が扱いやすいと思って統合している\nキーバインド (with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define google-pretty-hydra (:foreign-keys warn :title \u0026#34;Google\u0026#34; :quit-key \u0026#34;q\u0026#34; :color blue :separator \u0026#34;-\u0026#34;) (\u0026#34;Current\u0026#34; ((\u0026#34;SPC\u0026#34; google-this-noconfirm \u0026#34;No Confirm\u0026#34;) (\u0026#34;RET\u0026#34; google-this \u0026#34;Auto\u0026#34;) (\u0026#34;w\u0026#34; google-this-word \u0026#34;Word\u0026#34;) (\u0026#34;l\u0026#34; google-this-line \u0026#34;Line\u0026#34;) (\u0026#34;s\u0026#34; google-this-symbol \u0026#34;Symbol\u0026#34;) (\u0026#34;r\u0026#34; google-this-region \u0026#34;Region\u0026#34;) (\u0026#34;e\u0026#34; google-this-error \u0026#34;Error\u0026#34;)) \u0026#34;Feeling Lucky\u0026#34; ((\u0026#34;L\u0026#34; google-this-lucky-search \u0026#34;Lucky\u0026#34;) (\u0026#34;i\u0026#34; google-this-lucky-and-insert-url \u0026#34;Insert URL\u0026#34;)) \u0026#34;Translate\u0026#34; ((\u0026#34;t\u0026#34; google-translate-at-point \u0026#34;EN =\u0026gt; JP\u0026#34;) (\u0026#34;T\u0026#34; google-translate-at-point-reverse \u0026#34;JP =\u0026gt; EN\u0026#34;)) \u0026#34;Tool\u0026#34; ((\u0026#34;W\u0026#34; google-this-forecast \u0026#34;Weather\u0026#34;)))))    Key 効果     SPC 確認なしで検索   RET どの範囲の情報で検索するか自動判定して検索   w 近くの単語で検索   l その行の内容で検索。エラーの検索とかに良いかも   s シンボルで検索。使うのは Emacs Lisp の関数調べる時ぐらいか?   r リージョンで検索。まあリージョン選択してたら RET とかでいいんだけども   e コンパイルバッファのエラーで検索するっぽい   L 1件目を開く   i 1件目の URL を挿入する   t 英語→日本語翻訳   T 日本語→英語翻訳   w 天気を調べる    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/google-this/",
	"title": "google-this",
	"tags": [],
	"description": "",
	"content": "概要 google-this は Google 検索を Emacs の中から行えるやつ。\nインストール いつも通り el-get でインストール\n(el-get-bundle google-this) で、本来の使い方だとこのあとに\n(google-this-mode 1) とやって有効化することになるがそれをしても google-this のデフォルトキーバインドが設定されるぐらいで自分はそのデフォルトキーバインドを使う気がないので有効化はしてない。\nキーバインド キーバインドは Hydra で設定しているが、 google-translate と統合したので キーバインド \u0026gt; Google 連携 に記載している。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/google-translate/",
	"title": "google-translate",
	"tags": [],
	"description": "",
	"content": "概要 google-translate は Google 翻訳する機能を提供するパッケージ。\nインストール いつも通り el-get でインストール\n(el-get-bundle google-translate) 関数のオーバーライド どうも最新版でも壊れっぱなしのようなので https://github.com/atykhonov/google-translate/issues/52#issuecomment-727920888 にあるように関数を上書きしている。\n(with-eval-after-load \u0026#39;google-translate-tk (defun google-translate--search-tkk () \u0026#34;Search TKK.\u0026#34; (list 430675 2721866130))) google-translate-tk に定義されていて、それが読まれた後に上書きしないといけないので with-eval-after-load を使っている。\ndefault-ui の読み込み Google Translate は UI を defauult と smooth のどちらかから選べるようになっている。\ndefault だと\n google-translate-default-source-language google-translate-default-target-language  を設定しておいて\n M-x google-translate-at-point source → target の翻訳 M-x google-translate-at-point-reverse target → source の翻訳  という使い方をする。\nsmooth だと翻訳の source, target を複数設定して多言語対応ができるが、英語以外を翻訳することがないので smooth でなくていいかという感じで default を採用している。\n(with-eval-after-load \u0026#39;popup (require \u0026#39;google-translate-default-ui)) popup.el に依存しているのでそれが読まれた後に require しないといけなかった。というわけで with-eval-after-load で対応している。\nカスタム変数の設定 上述の通り default UI を使うことにしたのでその変数をいくらか設定している。\n(custom-set-variables \u0026#39;(google-translate-default-source-language \u0026#34;en\u0026#34;) \u0026#39;(google-translate-default-target-language \u0026#34;ja\u0026#34;) \u0026#39;(google-translate-output-destination \u0026#39;popup))  google-translate-default-source-language 翻訳元言語 google-translate-default-target-language 翻訳先言語 google-translate-output-destination 翻訳結果の表示  日本語を母国語としていて英語はからきしという人間なので当然英日変換されるように設定していてあとは変換結果の表示方法は popup でツールチップ表示するようにしている。\npopup 表示の欠点としては、その結果をコピペできないところだけど current-buffer への挿入も邪魔そうだし kill-ring に入れるのも違うしなどを考えた結果、消去法でこれにしてみた。\n(my/google-translate-at-point-output-tempbuf () (let ((google-translate-output-destination nil)) (google-translate-at-point))) とか用意しておいたらその時だけデフォルト動作の temporary buffer への出力ができそうだけどもね。ただこれだと逆版も作らないといけなさそうなのでちょっと方法考えるか。別で output destination を切り替えるようにするとか。\nキーバインド google-this と同じく Google 連係機能なので キーバインド \u0026gt; Google 連携 でまとめて Hydra を定義している\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/helm/",
	"title": "helm",
	"tags": [],
	"description": "",
	"content": "概要 helm は anything.el の後継であり、インクリメンタルに候補の絞り込みをしたりする UI を提供する便利なパッケージ。\npeco とか fzf とかと似ているっちゃ似ているかな? fzf 使ったことないけど。\n一時期開発が止まってるようだったけど最近(2021年)はまた更新が活発になっている。\nただ、麦汁さんは ivy に乗り換えようとしているので helm の設定は頑張っていない。 helm-for-files が便利なのでまだ捨てられてないけど……。\nインストール helm で使いたい拡張として helm-descbinds と helm-ag というのがあるのでそれらも同時に入れている。\n(el-get-bundle helm) (el-get-bundle helm-descbinds) (el-get-bundle helm-ag) ただ descbinds は counsel-descbinds に置き換えたし helm-ag ももう使ってない気がする\n設定 オススメの設定が helm に同梱されている helm-config に入ってるのでまずはそれを読み込んでいる。\n(require \u0026#39;helm-config) また helm-descbinds を使えるように有効にしている。けど、上にも書いたけどもう counsel-descbinds に置き換えちゃったのよね……。\n(helm-descbinds-mode) あとは helm-migemo-mode というのを有効にしている。これがあると helm で検索する時に migemo れて便利。\n(helm-migemo-mode 1) ivy の方でも migemo 対応したいけどまだできてない……。\nその他 helm 系の設定は他の設定にも色々影響も大きそうなので読み込み順は結構早いタイミングにしている(init-loader で 20 を prefix にしている)\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/helm-posframe/",
	"title": "helm-posframe",
	"tags": [],
	"description": "",
	"content": "概要 helm-posframe は helm の拡張で Helm のバッファの表示を posframe を使うようにしてくれるやつ。\n実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなのでいずれ外すかもしれない。\nただ確か本体の方の挙動が気に入らなかったような気はする。\nインストール いつも通り el-get でインストール。 GitHub にあるのでそれを取得するようにしている。\n(el-get-bundle tumashu/helm-posframe) 有効化 (helm-posframe-enable) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/",
	"title": "highlight-indent-guides",
	"tags": [],
	"description": "",
	"content": "概要 highlight-indent-guides はインデント毎にラインを引いたりして見易くしてくれるパッケージ。通常のプログラムを書く時にも便利だけど、 YAML などのインデントがそのまま構造になるような言語を弄る時にとても便利。\nインストール これもいつも通り el-get でインストールしている。また GitHub にあるので、そこから直接インストールしている。\n(el-get-bundle DarthFennec/highlight-indent-guides) 設定 今いる行がどのインデントにいるのかをわかりやすくするために responsive モードを有効にしている。\n(setq highlight-indent-guides-responsive \u0026#34;stack\u0026#34;) defcustom で定義されてる変数なので custom-set-variables で設定した方がいいかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/hydra/",
	"title": "hydra",
	"tags": [],
	"description": "",
	"content": "概要 Hydra は Emacs の貴重なキーバインドを節約できる便利なパッケージ。\n自分で定義した各 Hydra コマンドを実行するとそれに紐付くサブコマンドとそれらのキーバインド一覧を表示させることができるというやつ。\nインストール Hydra 本体と関連パッケージをここでインスコしている\nHydra 本体のインストール Hydra 本体は el-get で普通に入れている\n(el-get-bundle hydra) hydra-posframe のインストール Hydra は通常だと minibuffer あたりに表示されるけど画面の真ん中に表示される方が視線移動が少なくて便利なので hydra-posframe を使って画面中央に表示されるようにしている。\nインストールはいつも通り el-get で行っている。\n(el-get-bundle hydra-posframe) そして Emacs の初期化処理が完了したタイミングでそれが使われるように after-init-hook で hydra-posframe を有効化している\n(add-hook \u0026#39;after-init-hook \u0026#39;hydra-posframe-enable) major-mode-hydra のインストール 自分以外で使っている人を見たことはないけど麦汁さんは major-mode-hydra というものを利用している。\nこれは major mode 用に簡単に Hydra の設定ができるというやつ。なので emacs-lisp-mode 用の Hydra とか js2-mode 用の Hydra などを定義できて便利。\nどちらの場合も M-x major-mode-hydra で起動するので迷わないで済むのも良い。\n内部では同じリポジトリにある pretty-hydra というのを利用していてそいつが UI の定義をせずともそれなりの感じに Hydra のメニューを構築してくれるようになっている。これもズボラな麦汁さんは気に入っている。導入していても表示にこだわりたい場合は直接 defhydra したらいいだけだしね。\nってことでそれを el-get を使って GitHub からインストールしている。\n(el-get-bundle jerrypnz/major-mode-hydra.el) キーバインド Hydra でいくつかのキーバインドを設定していて他の機能に属さないものはここでまとめてキーバインドを定義している。\nel-get 他の機能に属さないものは、と書いたな? ありゃ嘘だ。 el-get の Hydra はここで定義してしまっている。その内 el-get 用の設定ファイルにでも移動したい気がする。\n(pretty-hydra-define el-get-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;el-get\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Install\u0026#34; ((\u0026#34;i\u0026#34; el-get-install \u0026#34;Install\u0026#34;) (\u0026#34;I\u0026#34; el-get-reinstall \u0026#34;Re-install\u0026#34;) (\u0026#34;D\u0026#34; el-get-remove \u0026#34;Uninstall\u0026#34;)) \u0026#34;Update\u0026#34; ((\u0026#34;s\u0026#34; el-get-self-update \u0026#34;Self Update\u0026#34;) (\u0026#34;u\u0026#34; el-get-update \u0026#34;Update\u0026#34;) (\u0026#34;A\u0026#34; el-get-update-all \u0026#34;Update All\u0026#34;) (\u0026#34;r\u0026#34; el-get-reload \u0026#34;Reload\u0026#34;)) \u0026#34;Recipe\u0026#34; ((\u0026#34;f\u0026#34; el-get-find-recipe-file \u0026#34;Find recipe\u0026#34;)) \u0026#34;Lock\u0026#34; ((\u0026#34;C\u0026#34; el-get-lock-checkout \u0026#34;Checkout\u0026#34;) (\u0026#34;U\u0026#34; el-get-lock-unlock \u0026#34;Unlock\u0026#34;))))    Key 効果     i パッケージの新規インストール。正直このキー叩いた記憶がない   I パッケージの再インストール   D パッケージの削除   s el-get 自身のアップデート   u 指定パッケージのアップデート   A 全パッケージのアップデート   r パッケージの読み直し   f パッケージのインストール用レシピファイルを開く   C 指定したパッケージを el-get-lock でロックされたバージョンをチェックアウト   U 指定したパッケージの el-get-lock のロックを解除    Toggle Switches ここでは ON/OFF を切り替えるような機能のコントロールを行っている。\n(pretty-hydra-define toggle-hydra (:separator \u0026#34;-\u0026#34; :title (concat (all-the-icons-faicon \u0026#34;toggle-on\u0026#34;) \u0026#34; Toggle Switches\u0026#34;) :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;View\u0026#34; ((\u0026#34;z\u0026#34; zoom-mode \u0026#34;zoom-mode\u0026#34; :toggle zoom-mode) (\u0026#34;Z\u0026#34; toggle-frame-fullscreen \u0026#34;Fullscreen\u0026#34; :toggle (frame-parameter nil \u0026#39;fullscreen)) (\u0026#34;b\u0026#34; display-battery-mode \u0026#34;Battery\u0026#34; :toggle display-battery-mode) (\u0026#34;L\u0026#34; display-line-numbers-mode \u0026#34;Line Number\u0026#34; :toggle display-line-numbers-mode) (\u0026#34;N\u0026#34; neotree-toggle \u0026#34;Neotree\u0026#34; :toggle (if (fboundp \u0026#39;neo-global--window-exists-p) (neo-global--window-exists-p) nil))) \u0026#34;Behavior\u0026#34; ((\u0026#34;S\u0026#34; my/notify-slack-toggle \u0026#34;Notify Slack\u0026#34; :toggle my/notify-slack-enable-p) (\u0026#34;v\u0026#34; my/toggle-view-mode \u0026#34;Readonly\u0026#34; :toggle view-mode) (\u0026#34;E\u0026#34; toggle-debug-on-error \u0026#34;Debug on error\u0026#34; :toggle debug-on-error))))    Key 効果     z zoom-mode のON/OFF切替。狭いディスプレイの時は ON にするが、大きいディスプレイだと OFF にしている   Z フルスクリーンの切替。狭いディスプレイの時は ON にするが、大きいディスプレイだと OFF にしている   b バッテリー表示モードの切替。OFF にしたことないな……   L 行番号表示の切替。邪魔になる時もあるので ON/OFF 切り替えている   N Neotree の表示切替。普段は邪魔なので OFF にしている   S Slack 通知の切替。org-clock-in とかのタイミングで Slack に通知を飛ばしているが切る時もある   v view-mode にしたり戻したり。コードを眺めたい時などに ON にする   E エラー時のデバッグモードの切替。設定を弄ってる時はバックトレースある方が嬉しいよね    Sub Tools 最初に起動した Hydra からは外してるけど、そこそこ使うコマンド群を適当に詰めてるやつ。\n(pretty-hydra-define subtools-hydra (:separator \u0026#34;-\u0026#34; :color teal :foreign-key warn :title (concat (all-the-icons-material \u0026#34;build\u0026#34;) \u0026#34; Sub tools\u0026#34;) :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Describe\u0026#34; ((\u0026#34;b\u0026#34; counsel-descbinds \u0026#34;Keybind\u0026#34;) (\u0026#34;f\u0026#34; counsel-describe-function \u0026#34;Function\u0026#34;) (\u0026#34;v\u0026#34; counsel-describe-variable \u0026#34;Variable\u0026#34;) (\u0026#34;m\u0026#34; describe-minor-mode \u0026#34;Minor mode\u0026#34;)) ;; (\u0026#34;P\u0026#34; my/open-review-requested-pr \u0026#34;Open Requested PR\u0026#34;) \u0026#34;Other\u0026#34; ((\u0026#34;@\u0026#34; all-the-icons-hydra/body \u0026#34;List icons\u0026#34;))))    Key 効果     b キーバインドを調べる   f Emacs Lisp の関数を調べる   v Emacs Lisp の変数を調べる   m minor-mode を調べる   @ All the icons の Hydra を起動    Text Scale 文字サイズの切替用。たまに字を大きくしたりしたいので。\n(pretty-hydra-define text-scale-hydra (:separator \u0026#34;-\u0026#34; :title (concat (all-the-icons-material \u0026#34;text_fields\u0026#34;) \u0026#34; Text Scale\u0026#34;) :exit nil :quit-key \u0026#34;q\u0026#34;) (\u0026#34;Scale\u0026#34; ((\u0026#34;+\u0026#34; text-scale-increase \u0026#34;Increase\u0026#34;) (\u0026#34;-\u0026#34; text-scale-decrease \u0026#34;Decrease\u0026#34;) (\u0026#34;0\u0026#34; text-scale-adjust \u0026#34;Adjust\u0026#34;))))    Key 効果     + 文字サイズを大きくする   - 文字サイズを小さくする   0 文字サイズを元に戻す    Main よく使うコマンドをまとめたやつ。 key-chord を使って jk 同時押しで起動できるようにしている。\n(pretty-hydra-define pretty-hydra-usefull-commands (:separator \u0026#34;-\u0026#34; :color teal :foreign-key warn :title (concat (all-the-icons-material \u0026#34;build\u0026#34;) \u0026#34; Usefull commands\u0026#34;) :quit-key \u0026#34;q\u0026#34;) (\u0026#34;File\u0026#34; ((\u0026#34;p\u0026#34; projectile-hydra/body \u0026#34;Projectile\u0026#34;) (\u0026#34;f\u0026#34; counsel-find-file \u0026#34;Find File\u0026#34;) (\u0026#34;d\u0026#34; counsel-find-dir \u0026#34;Find Dir\u0026#34;) (\u0026#34;r\u0026#34; counsel-recentf \u0026#34;Recentf\u0026#34;) (\u0026#34;l\u0026#34; counsel-locate \u0026#34;Locate\u0026#34;) (\u0026#34;A\u0026#34; counsel-osx-app \u0026#34;macOS App\u0026#34;)) \u0026#34;Edit\u0026#34; ((\u0026#34;a\u0026#34; align-regexp \u0026#34;Align Regexp\u0026#34;) (\u0026#34;;\u0026#34; comment-dwim \u0026#34;Comment\u0026#34;)) \u0026#34;Code\u0026#34; ((\u0026#34;G\u0026#34; counsel-projectile-ag \u0026#34;Grep\u0026#34;) (\u0026#34;j\u0026#34; dumb-jump-pretty-hydra/body \u0026#34;Dumb jump\u0026#34;) (\u0026#34;g\u0026#34; avy-hydra/body \u0026#34;Avy\u0026#34;) (\u0026#34;i\u0026#34; counsel-imenu \u0026#34;imenu\u0026#34;) (\u0026#34;y\u0026#34; yasnippet-hydra/body \u0026#34;Yasnippet\u0026#34;) (\u0026#34;B\u0026#34; browse-at-remote \u0026#34;Browse\u0026#34;) (\u0026#34;m\u0026#34; magit-status \u0026#34;Magit\u0026#34;)) \u0026#34;View\u0026#34; ((\u0026#34;D\u0026#34; delete-other-windows \u0026#34;Only This Win\u0026#34;) (\u0026#34;W\u0026#34; window-control-hydra/body \u0026#34;Window Control\u0026#34;) (\u0026#34;+\u0026#34; text-scale-hydra/body \u0026#34;Text Scale\u0026#34;) (\u0026#34;w\u0026#34; ace-swap-window \u0026#34;Swap Window\u0026#34;)) \u0026#34;Tool\u0026#34; ((\u0026#34;SPC\u0026#34; major-mode-hydra \u0026#34;Hydra(Major)\u0026#34;) (\u0026#34;s\u0026#34; toggle-hydra/body \u0026#34;Toggle switches\u0026#34;) (\u0026#34;c\u0026#34; counsel-org-capture \u0026#34;Capture\u0026#34;) (\u0026#34;o\u0026#34; global-org-hydra/body \u0026#34;Org\u0026#34;) (\u0026#34;e\u0026#34; el-get-hydra/body \u0026#34;el-get\u0026#34;) (\u0026#34;/\u0026#34; google-pretty-hydra/body \u0026#34;Google\u0026#34;) (\u0026#34;t\u0026#34; subtools-hydra/body \u0026#34;Sub Tools\u0026#34;))))    Key 効果     p Projectile 用の Hydra 起動   f counsel でファイルを開く   d counsel でフォルダ開く   r counsel で最近使ったファイルを開く   l counsel で locate する。Mac だと mdfind だけど   A counsel で macOS の Application を開く   a 正規表現に基いて整形   ; コメント挿入。 M-; を使ってるから要らないかも   G projectile 内の検索。関係ないのがかかる時もあるので調整必要   j dumb-jump 用の Hydra 起動   g 画面上の好きな位置にジャンプする avy の起動   i counsel-imenu 起動。使ってない気がする   y yasnippet 用の Hydra 起動   B browse-at-remote で GitHub などのコード位置を開く   m magit を起動   D 他の Window を消す   W フレームサイズや位置を弄るための Hydra を起動。ほぼ使ってない   + 文字サイズ変更用 Hydra の起動   w Window の入替   SPC major-mode-hydra の起動   s ON/OFF 切替系の Hydra を起動する   c counsel-org-capture を呼び出す   o org-mode 用の Hydra を起動する   e el-get 用の Hydra を起動する   t 第一階層には入れてないけどまあまあ便利なコマンドを詰めた Hydra を起動する    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/improvement/",
	"title": "improvement",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/key-chord/",
	"title": "key-chord",
	"tags": [],
	"description": "",
	"content": "概要 key-chord はキーを同時に押した時にコマンドを発動させるということができるようにしてくれるパッケージ。\nなのですが本家の方だと誤爆が多いということなのでそれを改善した zk-phi/key-chord の方を利用している。\nまあほとんど使えてないので改良版の恩恵をまだ受けてないけど……。\nインストール いつも通り el-get でインストールしている。本家の方じゃないので GitHub のリポジトリから突っ込んでいる。\n(el-get-bundle zk-phi/key-chord) 設定 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。\n(setq key-chord-two-keys-delay 0.15 key-chord-safety-interval-backward 0.1 key-chord-safety-interval-forward 0.15) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。\n改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動に使っている上に Hydra で叩けるやつでよく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。\n有効化 設定を入れた後は有効にするだけである。\n(key-chord-mode 1) 実際のキーバインド設定は各モードだったりグローバルキーバインドを設定しているファイルだったりで書く感じ。\nといいつつ現状では Hydra 起動のやつしか使ってないので、グローバルキーバインド設定でしか書いてない。\nその他 sticky-control も control 限定で似たようなことをしているので key-chord に全部置き換えできるかもしれない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/load-path/",
	"title": "load-path",
	"tags": [],
	"description": "",
	"content": "概要 load-path は Emacs の設定でも重要な項目でこのリストに追加されている path は load または require する際に走査される path となっている。\n即ち load-path を通しておけば、そこに置いている emacs lisp のファイルは簡単に読み出せるようになる。\nなお package-install や el-get を使っておけば基本的に自分で load-path を通す必要はない。\n秘匿情報を入れてるフォルダを読み込み可能にする パスワードなどの秘匿情報を持っている部分は ~/.emacs.d/secret というフォルダで管理している。そのためここに入ってる emacs lisp のファイルも読み込めるように load-path に追加している。\n(add-to-list \u0026#39;load-path (expand-file-name \u0026#34;~/.emacs.d/secret\u0026#34;)) my/load-config ~/.emacs.d/secret は個人マシンか会社マシンかによって置いてるデータが異なったりするためもしもファイルがなくてもエラーにならないような方法で load する方法が必要だった。\nというわけでファイルがなかったら読み込まずにメッセージを出力して終了するような関数を用意している。\n(defun my/load-config (file) (condition-case nil (load file) (file-missing (message \u0026#34;Load error: %s\u0026#34; file)))) ただ、これって結局\n(load file nil t) で十分な気もするので、置き換えを検討した方が良さそう。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/magit/",
	"title": "magit",
	"tags": [],
	"description": "",
	"content": "概要 magit は Emacs の上で Git の色々な操作ができるやつ。結構使いやすいのでオススメなやつ。\nforge を使うと GitHub や GitLab とも連携できてさらに便利、なはず。\nインストール (el-get-bundle magit) 使い方 Git 管理されてるファイルを開いている時に M-x magit とかすると Git 管理用のバッファが出て来るしそこで ? を叩いたらどういうコマンドが使えるのか教えてくれるよ(雑)\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/language-config/markdown/",
	"title": "markdown",
	"tags": [],
	"description": "",
	"content": "概要 Markdown を書くための設定。といいつつ markdown-mode を入れてるだけだけども。\n手元でテキストドキュメントを弄るのは org-mode が多いからなあ……\nインストール いつも通り el-get で入れている。\n(el-get-bundle markdown-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/neotree/",
	"title": "Neotree",
	"tags": ["replacement"],
	"description": "",
	"content": "概要 Neotree は Emacs でフォルダのツリー表示ができるやつ。メンテは活発じゃないようなので、その内乗り換えたい。\nレシピ Neotree でメンテされているのは dev ブランチだけど el-get の公式のレシピでは master ブランチを見ているので自前で recipe を用意してそれを使っている。\n(:name emacs-neotree-dev :website \u0026#34;https://github.com/jaypei/emacs-neotree\u0026#34; :description \u0026#34;An Emacs tree plugin like NerdTree for Vim.\u0026#34; :type github :branch \u0026#34;dev\u0026#34; :pkgname \u0026#34;jaypei/emacs-neotree\u0026#34;) インストール 上に書いたレシピを使ってインストールしている。\n(el-get-bundle emacs-neotree-dev) 使わなくなったコード 元々設定していたが、 counsel-projectile を使ってると projectile-switch-project-action を設定していても反映されず意味がないのに気付いたので使わなくなった\nhttps://github.com/mugijiru/.emacs.d/pull/183/files#r541843206\n(setq projectile-switch-project-action \u0026#39;neotree-projectile-action) テーマの設定 GUI で起動している時はアイコン表示しそうでない場合は ▾ とかで表示する\n(setq neo-theme (if (display-graphic-p) \u0026#39;icons \u0026#39;arrow)) のだけど、実際に今使ってるやつだともっとグラフィカルな表示なので all-the-icons の設定で上書きしている気がするので要確認\nmajor-mode-hydra いちいちキーバインドを覚えてられないので major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。\nとはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define neotree-mode (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-octicon \u0026#34;list-unordered\u0026#34;) \u0026#34; Neotree\u0026#34;)) (\u0026#34;Nav\u0026#34; ((\u0026#34;u\u0026#34; neotree-select-up-node \u0026#34;Up\u0026#34;) (\u0026#34;g\u0026#34; neotree-refresh \u0026#34;Refresh\u0026#34;) (\u0026#34;Q\u0026#34; neotree-hide \u0026#34;Hide\u0026#34;)) \u0026#34;File\u0026#34; ((\u0026#34;a\u0026#34; neo-open-file-ace-window \u0026#34;Ace\u0026#34;) (\u0026#34;N\u0026#34; neotree-create-node \u0026#34;Create\u0026#34;) (\u0026#34;R\u0026#34; neotree-rename-node \u0026#34;Rename\u0026#34;) (\u0026#34;C\u0026#34; neotree-copy-node \u0026#34;Copy\u0026#34;) (\u0026#34;D\u0026#34; neotree-delete-node \u0026#34;Delete\u0026#34;) (\u0026#34;SPC\u0026#34; neotree-quick-look \u0026#34;Look\u0026#34;) ;; (\u0026#34;d\u0026#34; neo-open-dired \u0026#34;Dired\u0026#34;) ;; (\u0026#34;O\u0026#34; neo-open-dir-recursive \u0026#34;Recursive\u0026#34;) ) \u0026#34;Toggle\u0026#34; ((\u0026#34;z\u0026#34; neotree-stretch-toggle \u0026#34;Size\u0026#34; :toggle (not (neo-window--minimize-p))) (\u0026#34;h\u0026#34; neotree-hidden-file-toggle \u0026#34;Hidden file\u0026#34; :toggle neo-buffer--show-hidden-file-p))))) キーバインド ナビゲーション    Key 効果     u 上のノードに移動   g 再描画   Q Neotree を隠す    ファイル操作    Key 効果     a ファイルを開く。その際に ace-window で開く window を指定する   N 新しいノードを作る   R ノードの名前を変える   C ノードのコピー   D ノードの削除   SPC クイックルック    Toggle    Key 効果     z Neotree のサイズを大きくしたり小さくしたり   h 隠しファイルを表示したり隠したり    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/language-config/plantuml-mode/",
	"title": "plantuml-mode",
	"tags": [],
	"description": "",
	"content": "概要 plantuml-mode は PlantUML という、テキストだけで UML 図などが描けるツール用のモード。\nインストール いつも通り el-get で入れてる\n(el-get-bundle plantuml-mode) 設定 実行モードは 'jar を指定している。デフォルトは 'server なんだけどオフラインの時も使いたいししね。\n(setq plantuml-default-exec-mode \u0026#39;jar) el-get でインスコすると jar ファイルも自動で拾って来て plantuml-mode と同じディレクトリに設置して plantuml-jar-path も通してくれるからそっち使う方が便利だしね。\nその他 最新の develop ブランチだとインデントを調整できる機能が入っているので乗り換えたいけどそのためには el-get のレシピを書いてあげる必要がありそうで放置している。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/posframe/",
	"title": "posframe",
	"tags": [],
	"description": "",
	"content": "概要 posframe は child frame を表示させるためのパッケージ。 Emacs のど真ん中に表示したり、今あるカーソル位置のすぐそばに出したりできる。\nivy なんかを使う時に ivy-posframe ど真ん中に出すと、いつもそこに表示されるし真ん中なの視線移動が少なくて済むし ddskk-posframe なんかで変換候補をカーソル位置のそばに出て来るので一般的な日本語変換ソフトと同様にこれまた視線移動が少なくて便利。\nという感じで色々なものの拡張として使わているやつ。\nインストール いつも通り el-get で入れているだけ。\n(el-get-bundle posframe) こいつ自体には特に設定を入れてない。というか設定項目自体2個しか存在していない。\nま、こいつ単体で使うものでもないしね。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/projectile/",
	"title": "projectile",
	"tags": [],
	"description": "",
	"content": "概要 projectile はプロジェクト内のファイルを検索したりするのに便利なパッケージ\nインストール いつも通り el-get からインストールする\n(el-get-bundle projectile) helm との連携 helm-projectile を使って helm と連携できるようにしている。けど ivy に乗り換えを進めているので多分これ使ってないんだよな……。というわけでこの設定は消す候補に入っている。\n(el-get-bundle helm-projectile) (helm-projectile-on) 有効化 このあたりで有効化しておいている。この順序に意味があったかは忘れた……。\n(projectile-mode) 無視リスト 普段 Rails ばっかりやってるのでそれ関係のものを無視リストに入れている。けどあんまりメンテしてない。\n無視するディレクトリ (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;tmp\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;.tmp\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;vendor\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;.sass-cache\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;coverage\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;cache\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-directories \u0026#34;log\u0026#34;) node_modules もここに突っ込んでも良いかもしれない。\n無視するファイル (add-to-list \u0026#39;projectile-globally-ignored-files \u0026#34;gems.tags\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-files \u0026#34;project.tags\u0026#34;) (add-to-list \u0026#39;projectile-globally-ignored-files \u0026#34;manifest.json\u0026#34;) tags ファイルは昔は使っていたけど、最近は dumb-jump が優秀なのと、面倒で使ってないのでそろそろ gems.tags と project.tags は不要かもしれない。\nivy/counsel との連携 上の方で helm との連携処理を入れていたが今は大体 ivy に乗り換えているので ivy 連携もしている。\n(setq projectile-completion-system \u0026#39;ivy) (el-get-bundle counsel-projectile) counsel-projectile はいくつかの絞り込み処理を提供してくれて便利。それでも足りなかったら自前で何か作ることになるのかなと思っている。\nキーバインド デフォルトでいくつかのキーバインドが用意されてるようだけどそんなものさっぱり覚えられないのでとりあえずいくつかを Hydra で叩けるようにしている\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define projectile-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;Projectile\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;File\u0026#34; ((\u0026#34;f\u0026#34; counsel-projectile-find-file \u0026#34;Find File\u0026#34;) (\u0026#34;d\u0026#34; counsel-projectile-find-dir \u0026#34;Find Dir\u0026#34;) (\u0026#34;r\u0026#34; projectile-recentf \u0026#34;Recentf\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;p\u0026#34; (counsel-projectile-switch-project \u0026#39;neotree-dir) \u0026#34;Switch Project\u0026#34;)))))    Key 効果     f プロジェクト内のファイルを検索   d プロジェクト内のフォルダを検索   r プロジェクト内で最近触ったファイルのリスト表示   p 別のプロジェクトに切り替え     projectile-find-implementation-or-test projectile-replace projectile-replace-regxp  あたりも使えるようにするともしかしたら便利かもしれない。あとは counsel-projectile-grep とかの類か。\nその他 基本的に Rails のプロジェクトをやっているので projectile-rails をベースにいつも触ってるので projectile そのものはあまり弄ってないのであった\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/replacement/",
	"title": "replacement",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/savehist/",
	"title": "savehist",
	"tags": [],
	"description": "",
	"content": "概要 Emacs 標準でついている、ミニバッファの履歴などを保存してくれる機能。\n有効化 標準でついているので以下のようにするだけで有効化可能。\n(savehist-mode 1) 設定 標準で保存されるもの以外だと kill-ring だけを保存対象にしている。これで Emacs を終了させても kill-ring は残るようになるはず。だけど最近使えてない気がするな……。検証が必要そう。\n(setq savehist-additional-variables \u0026#39;(kill-ring)) 他にも有効にしたら便利そうなのがあれば追加したい。が、ぱっとは思い付かない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/show-paren-mode/",
	"title": "show-paren-mode",
	"tags": [],
	"description": "",
	"content": "概要 show-paren-mode は Emacs に標準で入っているやつで開き括弧と閉じ括弧の対応を示してくれたり括弧の中身を強調表示したりする機能を提供してくれるやつ。\n有効化 デフォで入ってるので以下のようにするだけで有効化される。\n(show-paren-mode 1) デフォ設定だと対応する括弧を強調表示するだけだけどまあそれで悪くないと思ってるので今のところデフォルト設定のままである。\nその他 http://syohex.hatenablog.com/entry/20110331/1301584188\nの記事へのリンクを設定ファイルの中に残していたけど設定は特に弄ってないのでまたその記事読んだりで設定弄ってみてもいいかもしれない。\nまた smartparens.el にも似た機能はあるようだけど Emacs 標準機能の方が軽そうなのでとりあえずこのままにするつもり。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/smartparens/",
	"title": "smartparens",
	"tags": [],
	"description": "",
	"content": "概要 smartparens はカッコとかクォートとかのペアになるようなものの入力補助をしてくれるやつ。\nstrict モードだとペアが崩れないように強制するので雑に C-k で行削除しててもペアが維持されて便利。\nインストール いつも透り el-get で導入している\n(el-get-bundle smartparens) 設定 実は導入して間もないので、提供されてるオススメ設定のみ突っ込んでいる。オススメ設定は別途 reqiure したら良いという作りなので、以下のようにして突っ込んでいる。\n(require \u0026#39;smartparens-config) その他 各言語の hook で smartparens-strict-mode を有効にしている。なんか常に有効だと困りそうな気がしたので。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/",
	"title": "sticky-control",
	"tags": [],
	"description": "",
	"content": "概要 指定したキーを2回叩いたら Control が押されてるような状態にしてくれるプラグイン。\nその2回の間隔はデフォルトだと 0.5 秒以内となっている。そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる\nさらに sticky-control-shortcuts に指定されてる一部のキーについては sticky 用のキーを押した直後に shortcuts のキーを押すと Control を押している状態でそのキーを押したことになる。\n例えば私は , を sticky 用のキーにしていて shortcuts に c を入れているので ,c と素早くタイプをすればそれだけで C-c が押された状態になる。\nインストール まずは el-get-bundle でインストール。\n(el-get-bundle sticky-control) ちなみにレシピは公式ではなかったのでとりあえず自分の環境で使えるように自作レシピを置いている。\n(:name sticky-control :description \u0026#34;save your left little finger\u0026#34; :type http :url \u0026#34;https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el\u0026#34; :features \u0026#34;sticky-control\u0026#34;) 元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど最近そこからは取得できなくなったので https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el から取得して利用している\n設定 まずは「2回叩いたら Control を押している状態になる」キーを指定する。\n(sticky-control-set-key \u0026#39;sticky-control-key ?,) 私は , を sticky-control のキーにしているのでこの指定。\nそして次に sticky-control-shortuts の指定。ここに指定しておくと、例えば ,c と素早くタイプすることで C-c が入力された状態とすることができる。\n(setq sticky-control-shortcuts \u0026#39;((?c . \u0026#34;\\C-c\u0026#34;) (?g . \u0026#34;\\C-g\u0026#34;) (?k . \u0026#34;\\C-k\u0026#34;) (?a . \u0026#34;\\C-a\u0026#34;) (?e . \u0026#34;\\C-e\u0026#34;) (?n . \u0026#34;\\C-n\u0026#34;) (?o . \u0026#34;\\C-o\u0026#34;) (?p . \u0026#34;\\C-p\u0026#34;) (?j . \u0026#34;\\C-j\u0026#34;) (?f . \u0026#34;\\C-f\u0026#34;) (?b . \u0026#34;\\C-b\u0026#34;) (?x . \u0026#34;\\C-x\u0026#34;) (?r . \u0026#34;\\C-r\u0026#34;) (?s . \u0026#34;\\C-s\u0026#34;))) 結構な数を指定しているけど、普段そんなに使えているわけでもない。まあ、大体 Control を押しながら使いそうなところは押さえてあるので何も考えずとも使えるようにしてある。\n有効化 最後に有効化\n(sticky-control-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/toolbar/",
	"title": "toolbar",
	"tags": [],
	"description": "",
	"content": "概要 Emacs 標準の toolbar の設定。麦汁さんは使わないし幅を取るので隠す派。\n設定 単に無効にして隠している\n(tool-bar-mode -1) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/undo-fu/",
	"title": "undo-fu",
	"tags": [],
	"description": "",
	"content": "概要 undo-fu はシンプルな undo/redo 機能を提供してくれるやつ。\n昔はもっと色々できる undo-tree を使っていたけどそっちにバグがあるっぽいので乗り換えた。\nインストール (el-get-bundle undo-fu) キーバインド 別の場所で定義しているけど、以下のキーバインドにしている。\n   Key 効果     C-/ undo   C-M-/ redo    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/uniquify/",
	"title": "uniquify",
	"tags": [],
	"description": "",
	"content": "概要 同じ名前のファイルを開いている時に祖先のディレクトリ名を表示してくれてどこのファイルかわかりやすくしてくれるやつ。\nすぐ親とかも同名でも、名前が違うところまで遡って表示してくれる。\n有効化 Emacs に標準で入ってるので require するだけで有効にできる\n(require \u0026#39;uniquify) 設定 自分は ファイル名\u0026lt;フォルダ名\u0026gt; みたいな表示になる形式にしている。その方がファイル名が主という感じになって使いやすそうだなって。\nそういう意味では post-foward の方が幅を使わない分良いかもしれない。いつか検討しても良いかもしれない。\n(setq uniquify-buffer-name-style \u0026#39;post-forward-angle-brackets) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/unused/",
	"title": "unused",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/external-tool/wakatime-mode/",
	"title": "wakatime-mode",
	"tags": [],
	"description": "",
	"content": "概要 wakatime-mode は WakaTime というサービスと連携するためのパッケージ。\nWakaTime は自分がどのプロジェクトの作業をしているかを計測してくれるようなツール。普段の行動の改善に使えるかもしれないので、なんとなく連携してみている。\nインストール いつも通り el-get から入れている\n(el-get-bundle wakatime-mode) APIキーの設定 APIキーは .authinfo.gpg に保存しているのでそこから引っ張り出している。\n(custom-set-variables \u0026#39;(wakatime-api-key (funcall (plist-get (nth 0 (auth-source-search :host \u0026#34;wakatime.com\u0026#34; :max 1)) :secret)))) 有効化 Emacs を使っている間は常に有効になっていて欲しいので global-wakatime-mode を有効にしている。\n(global-wakatime-mode 1) APIキーが取れてない時はやたらエラーを吐くので何かしら調整はしてもいいかもしれない。\n(if (boundp \u0026#39;wakatime-api-key) (global-wakatime-mode 1)) みたいにして API キーが取れている時だけ有効にするとかね。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/language-config/yaml-mode/",
	"title": "yaml-mode",
	"tags": [],
	"description": "",
	"content": "概要 yaml-mode は yaml を編集する時のメジャーモード。インデントを調整しやすい。\nインストール いつも通り el-get でインストール\n(el-get-bundle yaml-mode) hook mode に対する hook は関数を定義してその中で呼びたいコードを書いていくようにしている。\nlambda で書いてしまうと hook を弄りたい時に結構面倒なのだけど関数を定義しておくと、その関数の中身を変更して評価しておくだけで hook で動作する中身が変更できて便利。\nとりあえず yaml-mode では以下のようにして highlight-indent-guides を有効にしている。\n(defun my/yaml-mode-hook () (highlight-indent-guides-mode 1)) で、その hook を最後に yaml-mode-hook に追加している。\n(add-hook \u0026#39;yaml-mode-hook \u0026#39;my/yaml-mode-hook) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/yascroll/",
	"title": "yascroll",
	"tags": [],
	"description": "",
	"content": "概要 yascroll は標準のスクロールバーとは異なるスクロールバーを表示するやつ。\nデフォルトだと右側の fringe 領域に表示するのであまり邪魔にならないし表示領域を必要以上に狭めないので気に入っている。\n最初に作られたっぽい記事は 主張しないスクロールバーモード、yascroll.elをリリースしました - Functional Emacser にある。タイトル通り、あまり主張しない感じで良い。\nインストール いつも通り el-get でインストールしている\n(el-get-bundle yascroll) これだけで大体いい感じに表示されるので便利。たまに表示されなくなることもあるが、まあそこまで重要なやつでもないのであまり気にしていない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/yasnippet/",
	"title": "yasnippet",
	"tags": [],
	"description": "",
	"content": "概要 yasnippet はテンプレートを挿入する機能を持ったパッケージ。 Emacs でそこそこ何かを書いている人なら大体知ってるような有名なやつだと思う。\nインストール いつも通り el-get でインストール\n(el-get-bundle yasnippet) 有効化 どこでも使いたいぐらい便利なやつなので global に有効化している\n(yas-global-mode 1) キーバインド 基本的に覚えられないので Hydra を使って定義している\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define yasnippet-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;Yasnippet\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Edit\u0026#34; ((\u0026#34;n\u0026#34; yas-new-snippet \u0026#34;New\u0026#34;) (\u0026#34;v\u0026#34; yas-visit-snippet-file \u0026#34;Visit\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;i\u0026#34; yas-insert-snippet \u0026#34;Insert\u0026#34;) (\u0026#34;l\u0026#34; yas-describe-tables \u0026#34;List\u0026#34;) (\u0026#34;r\u0026#34; yas-reload-all \u0026#34;Reload all\u0026#34;)))))    Key 効果     n 現在のメジャーモード用に新しい snippet を作る   v 現在のメジャーモードの登録済 snippet ファイルを開く   i snippet の挿入。選択は ivy で行われる。   l 現在のメジャーモードの登録済 snippet の一覧表示   r snippet を全部 load し直す    その他 実は、どういう snippet があれば便利なのかよくわかってなくて snippet をほとんど登録してない。\nyasnippet-snippets などのよくある snippet 集は、そんなの省略形をまず覚えられないだろと思っている。 ivy で選択可能なので省略形は長くていいので中身がわかりやすい方が良い。\nまた導入はしてないが ivy-yasnippet を入れるとさらにそのあたりがやりやすくなるんじゃないかと思う。\nそれから company-yasnippet で補完できるようにしているとより良いかもれない。\nとはいえ snippet を充実させてない今だとどうにもイマイチそのあたりを充実させる気力がない\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/zoom/",
	"title": "zoom",
	"tags": [],
	"description": "",
	"content": "概要 zoom はフォーカスが当たっている Window が大きく表示されるようにするやつ。最近流行りのビデオチャットツールではない。\nどこにフォーカスが当たっているかわかりやすくなるし、狭い画面でも見たい部分を広げて表示できるので便利。\nインストール いつも通り el-get から入れる。 GitHub から直接取得するように設定している。\n(el-get-bundle cyrus-and/zoom) 設定  起動時に有効化 1画面しか使えない時は必須なので 比率を黄金比に変更 この方が使いやすいっぽい。  という設定をしている。\n(custom-set-variables \u0026#39;(zoom-mode t) \u0026#39;(zoom-size \u0026#39;(0.618 . 0.618))) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/zoom-window/",
	"title": "zoom-window",
	"tags": [],
	"description": "",
	"content": "概要 zoom-window は tmux の prefix z のような動きをするやつ。表示している window をフレーム全体に広げたり戻したりすることができる。\nインストール いつも通り el-get から入れている\n(el-get-bundle zoom-window) その他 キーバインドは 80-global-keybinds に書いたけど C-x 1 に割り当てている。\nただそれだと tmux と使い勝手が違うなって感じているのでそのうち hydra の中の z にでもアサインしようかと思う。\nあと、その window を最大化して戻すことよりも単に他の window が邪魔なことの方が多い気もしている。。。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/gcmh/",
	"title": "ガベージコレクション",
	"tags": [],
	"description": "",
	"content": "概要 ガベージコレクションには gcmh というのを利用してみている。\nhttps://github.com/emacsmirror/gcmh\n普段は GC を控えめにしながら操作してない間に GC が走るような作りになっている。便利そう。\nインストール (el-get-bundle gcmh) これだけで有効化もされる。\nその他 以前の設定も折り畳んで残しておく\n  使わなくなったコード  gcmh を入れる前に設定していたコード。 gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。\n;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf ;; Increase threshold to fire garbage collection (setq gc-cons-threshold 1073741824) (setq garbage-collection-messages t) ;; Run GC every 60 seconds if emacs is idle. (run-with-idle-timer 60.0 t #\u0026#39;garbage-collect) \n "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/",
	"title": "麦汁&#39;s Emacs Config",
	"tags": [],
	"description": "",
	"content": "ここは @mugijiru の Emacs の設定ファイルの一部を解説しているページです。\nhttps://github.com/mugijiru/.emacs.d/blob/master/init.org から ox-hugo を使ってWebサイトに仕立て上げています。\n動作確認環境 以下の環境で使用しています。が、動作を保証するものではありません。\n macOS emacsmacport で用意されている Emacs Ubuntu 20.04 LTS apt で手に入る Emacs 26.3  注意点 まだ全ての設定を init.org に記載できていない上に init.org からの出力設定も済ませていないので極一部の設定ファイルのみの解説となります。\n"
}]