[
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/",
	"title": "with-simulated-input",
	"tags": [],
	"description": "",
	"content": "概要 with-simulated-input は入力処理をシミュレートするためのプラグイン。\n公式のドキュメントにあるように\n(with-simulated-input \u0026#34;hello SPC world RET\u0026#34; (read-string \u0026#34;Say hello to the world: \u0026#34;)) を評価すると read-string に対して「hello world」を入力したことになるので echo エリアに「hello world」と表示される。\nこれで何が嬉しいかというと Emacs Lisp でやっていることはインタラクティブな部分が大きいのでそういった要素をテストできるようになる。\n具体的な使用例は test:my/org-todo で示す。\nインストール el-get-bundle で GitHub からインストールしている\n(el-get-bundle DarwinAwardWinner/with-simulated-input) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/",
	"title": "基本設定",
	"tags": [],
	"description": "",
	"content": "Emacs の基本動作に関わる部分をここでは設定している\n exec-path PATH などの環境変数を shell と合わせる設定 load-path Emacs Lisp が読み込める path の設定 savehist ミニバッファの履歴などを保存してくれる機能。 ガベージコレクション メモリの開放関係の設定  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/execution/",
	"title": "実行方法",
	"tags": [],
	"description": "",
	"content": "テストする時は以下のように叩いたら動く。\nemacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el 今まで .emacs.d にいる状態でしか叩いたことないので他の場所にいる時に実行しても大丈夫かはわからない。\n単体でテストしたい時は\n-l ~/.emacs.d/inits/test/*-test.el の部分を書き換えたらいいんじゃないかな。やったことないけど。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/",
	"title": "mocker.el",
	"tags": ["unused"],
	"description": "",
	"content": "概要 mocker.el は Emacs Lisp のテストで使う Mock ライブラリ。\n使おうと思って導入したけど、自分のやりたいことはちょっと違ったので死蔵中\n便利そうなのでとりあえず置いといている。\nインストール el-get で GitHub から取得している。\n(el-get-bundle sigma/mocker.el) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/run-tests/",
	"title": "run-tests",
	"tags": [],
	"description": "",
	"content": "読み込んだテストをまるっとテストするためのコードをとりあえず置いている。\n(if noninteractive (let ((ert-quiet t)) (ert-run-tests-batch-and-exit))) 後述の テストライブラリの読み込み などはここで担うべきかとも考えるが今はテストファイルが1つしかないので気にしないことにする。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/",
	"title": "キーバインド",
	"tags": [],
	"description": "",
	"content": "ここでは全体に関わるキーバインド系の設定を記載している。\n sticky-control Control の入力を sticky にしてくれるやつ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/",
	"title": "my-org-commands-test",
	"tags": [],
	"description": "",
	"content": "org-mode 用に定義したコマンドや関数のテストコード\nSetup テストライブラリの読み込み 標準でついてくる ert を採用しているのでそれを読み込んでいる。\n(require \u0026#39;ert) el-get の設定の読み込み プラグイン管理には el-get を利用しているのでその設定ファイルを読み込んでいる。\n;; プラグイン読み込みの前準備 (load (expand-file-name (concat user-emacs-directory \u0026#34;/init-el-get.el\u0026#34;))) テスト補助のプラグイン読み込み with-simulated-input 上で説明しているが、入力をシミュレートするためのプラグインをテストで利用しているのでここで読み込んでいる。\n;; 入力シミュレート用のプラグイン (load (expand-file-name (concat user-emacs-directory \u0026#34;/inits/99-with-simulated-input\u0026#34;))) 依存プラグインの読み込み テスト対象が依存しているプラグインを読み込んでいる。本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが現状だとその状態で GitHub Actions で動かせる方法がわからないので一旦個別に読み込むようにしている。\nswiper ivy-read を使った機能のテストをするので読み込んでいる。\n(el-get-bundle abo-abo/swiper) テスト対象の読み込み テストしたいファイルをここで読んでる。\n;; テスト対象の読み込み (load (expand-file-name (concat user-emacs-directory \u0026#34;/inits/68-my-org-commands.el\u0026#34;))) ert-deftest test:my/org-todo-keyword-strings org-todo-keywords から \u0026ldquo;|\u0026rdquo; という区切りを除外したり \u0026ldquo;(s)\u0026rdquo; とかのような高速アクセスのためのキーワードは ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。\n(ert-deftest test:my/org-todo-keyword-strings () \u0026#34;Test of `my/org-todo-keyword-strings\u0026#39;.\u0026#34; (let ((org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;)))) (should (equal \u0026#39;(\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;DONE\u0026#34; \u0026#34;SOMEDAY\u0026#34;) (my/org-todo-keyword-strings))))) なお、ここでテストしている関数では TODO キーワードを ivy で扱いやすいように整えているだけで実際の選択は別の関数が担っている\ntest:my/org-todo org-todo を ivy で選択する関数のテストを書いている。\n(ert-deftest test:my/org-todo () \u0026#34;Test of `my/org-todo\u0026#39;.\u0026#34; (let ((org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DOING(!)\u0026#34; \u0026#34;WAIT\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(!)\u0026#34; \u0026#34;SOMEDAY(s)\u0026#34;))) (result)) ;; org-mode を読まずに済むように org-todo を差し替えてテストしている (cl-letf (((symbol-function \u0026#39;org-todo) (lambda (keyword) (setq result keyword)))) (with-simulated-input \u0026#34;DOI RET\u0026#34; (my/org-todo)) (should (equal \u0026#34;DOING\u0026#34; result))))) ポイントは cl-letf を使って、内部で叩いている関数 org-todo を一時的に\n(lambda (keyword) (setq result keyword)) に差し替えているところ。\norg-mode を呼び出さずに代わりの関数に差し替えているのでテストがしやすくなっている。Stub 的なやつかな。\n何度も使うならこの差し替え処理自体をテストヘルパーにしても良いかもしれない。\nまた ivy で選択するので with-simulated-input を使って入力操作を代替している。便利。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/",
	"title": "ファイル編集",
	"tags": [],
	"description": "",
	"content": "ここにはファイル編集系の設定をまとめている\n auto-insert ファイル新規作成時にテンプレートを挿入する機能  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/",
	"title": "UI",
	"tags": [],
	"description": "",
	"content": "ここでは Emacs の UI を変更するようなものを載せている\n helm-posframe Helm を posframe で使えるようにするやつ Neotree フォルダ構造を IDE みたいにツリー表示するやつ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/",
	"title": "ナビゲーション",
	"tags": [],
	"description": "",
	"content": "ここではカーソル移動やファイル移動などのナビゲーション系の設定を記載していく\n avy 表示されてるところの好きな場所にさくっとジャンプするためのパッケージ  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/framework-config/",
	"title": "フレームワーク用の設定",
	"tags": [],
	"description": "",
	"content": "開発に使っている各フレームワーク用の設定をここにまとめている。\n Ember.js Web フロントエンド MVC フレームワークである Ember.js 用の設定を書いている  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing-tool/",
	"title": "テスト用ツール",
	"tags": [],
	"description": "",
	"content": "自動テストを実行するにあたり、追加インストールしているパッケージをここに載せている\n with-simulated-input 入力処理をシミュレートしてくれるパッケージ mocker.el Mock/Stub するためのパッケージ。まだ使ってない  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/testing/",
	"title": "テストコード",
	"tags": [],
	"description": "",
	"content": "一部のコマンドなどの設定を書き始めているので設けたセクション。\n暫定的にここに置いているが設定と近い方が良さそうなのでいずれドキュメント内の位置を移動しそう。\n 実行方法 とりあえず書かれているテストを動かす方法を書いている。 run-tests テスト全体を動かすための共通設定ファイルの説明 my-org-commands-test org-mode 用に自分が生やしたコマンドのテストファイルの解説  "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/editing/auto-insert/",
	"title": "auto-insert",
	"tags": [],
	"description": "",
	"content": "概要 auto-insert はファイルを新規作成した時にファイル名に応じたテンプレートを挿入する機能。\nEmacs が標準で持ってるライブラリなのでインストールは不要\n設定 Emacs の設定は .emacs.d の中に閉じ込めたいので auto-insert のテンプレートも ~/.emacs.d/insert に閉じ込める設定にしている。\n(custom-set-variables \u0026#39;(auto-insert-directory \u0026#34;~/.emacs.d/insert/\u0026#34;)) 有効化 あとは単に有効化している。\n(auto-insert-mode 1) 他の設定 ファイル名を正規表現でマッチさせてテンプレートが選択されるので各言語やフレームワーク毎に設定を入れることにしている。\n実際は今のところ inits/41-vue.el でのみ追加設定を入れている。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/nav/avy/",
	"title": "avy",
	"tags": [],
	"description": "",
	"content": "概要 avy は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。 Vimium の f とかに似てる。\nインストール el-get で普通にインストールしている\n(el-get-bundle avy) 設定 文字の上に重なると元の文字列がよくわからなくなるので、移動先の文字の前に表示するようにしている\n(setq avy-style \u0026#39;pre) キーバインド グローバルなキーバインドを汚染したくなかったのでひとまず Hydra を定義している。\n(with-eval-after-load \u0026#39;pretty-hydra (pretty-hydra-define avy-hydra (:separator \u0026#34;-\u0026#34; :title \u0026#34;avy\u0026#34; :foreign-key warn :quit-key \u0026#34;q\u0026#34; :exit t) (\u0026#34;Char\u0026#34; ((\u0026#34;c\u0026#34; avy-goto-char \u0026#34;Char\u0026#34;) (\u0026#34;C\u0026#34; avy-goto-char-2 \u0026#34;Char 2\u0026#34;) (\u0026#34;x\u0026#34; avy-goto-char-timer \u0026#34;Char Timer\u0026#34;)) \u0026#34;Word\u0026#34; ((\u0026#34;w\u0026#34; avy-goto-word-1 \u0026#34;Word\u0026#34;) (\u0026#34;W\u0026#34; avy-goto-word-0 \u0026#34;Word 0\u0026#34;)) \u0026#34;Line\u0026#34; ((\u0026#34;l\u0026#34; avy-goto-line \u0026#34;Line\u0026#34;)) \u0026#34;Other\u0026#34; ((\u0026#34;r\u0026#34; avy-resume \u0026#34;Resume\u0026#34;)))))    Key 効果     c 1文字からの絞り込み   C 2文字から絞り込み   x 任意の文字列からの絞り込み   w 1文字絞り込んで単語先頭に移動   W 絞り込みなしの単語移動   l 列移動   r 繰り返し同じコマンドを実行    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/framework-config/ember-js/",
	"title": "Ember.js",
	"tags": [],
	"description": "",
	"content": "概要 Ember.js 用の Emacs の拡張としては ember-mode と handlebars-mode が存在する\nember-mode ember-mode は Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。実は麦汁さんは使えてない。\nインストールするだけではダメで、 ember-mode を明示的に起動しないといけない。\nそのためには dir-locals を使うとか projectile なんかがやってるようにフォルダ構成から判定させるみたいなことが必要そう。だるい。\nというわけで死蔵中。\nついでにいうとキーバインドもだるい系なので使う時は Hydra を用意した方が良さそう\n(el-get-bundle madnificent/ember-mode) handlebars-mode handlebars-mode は Ember.js のテンプレートエンジンとして採用されている Handlebars を書くためのモード。\nsyntax highlight と、いくつかの編集機能を備えている。が、今のところ麦汁さんは syntax highlight しか使えてない。\n編集コマンドは major-mode-hydra で使えるようにしてあげれば良さそう\n(el-get-bundle handlebars-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/exec-path/",
	"title": "exec-path",
	"tags": [],
	"description": "",
	"content": "概要 Emacs は通常最小限の環境変数しか利用しないようになっている。\nが、それだと普段使う上で「ああ、このコマンドが使えなくてもどかしい……!」と感じてしまう。\nそこで exec-path-from-shell というのを使って Emacs が見える PATH 環境変数をシェルが見てる PATH 環境変数と揃うようにしている。\nインストール いつも通り el-get からインストールしている\n(el-get-bundle exec-path-from-shell) 有効化 理由は忘れたが Mac の環境でのみ有効化している。その内 Linux 環境でも有効化を試みた方が良さそう\n(when (memq window-system \u0026#39;(mac ns)) (exec-path-from-shell-initialize)) なお、これでシェルと共通の環境変数が使われるようになるのは デフォルトでは PATH と MANPATH のみである\nその他 なぜか以下のようなコメントを書いていた。普段使っている zsh で持ってる PATH は使わないのだろうか? :thinking_face:\n;; for exec path ;; use .bashrc setted path "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/helm-posframe/",
	"title": "helm-posframe",
	"tags": [],
	"description": "",
	"content": "概要 helm-posframe は helm の拡張で Helm のバッファの表示を posframe を使うようにしてくれるやつ。\n実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなのでいずれ外すかもしれない。\nただ確か本体の方の挙動が気に入らなかったような気はする。\nインストール いつも通り el-get でインストール。 GitHub にあるのでそれを取得するようにしている。\n(el-get-bundle tumashu/helm-posframe) 有効化 (helm-posframe-enable) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/load-path/",
	"title": "load-path",
	"tags": [],
	"description": "",
	"content": "概要 load-path は Emacs の設定でも重要な項目でこのリストに追加されている path は load または require する際に走査される path となっている。\n即ち load-path を通しておけば、そこに置いている emacs lisp のファイルは簡単に読み出せるようになる。\nなお package-install や el-get を使っておけば基本的に自分で load-path を通す必要はない。\n秘匿情報を入れてるフォルダを読み込み可能にする パスワードなどの秘匿情報を持っている部分は ~/.emacs.d/secret というフォルダで管理している。そのためここに入ってる emacs lisp のファイルも読み込めるように load-path に追加している。\n(add-to-list \u0026#39;load-path (expand-file-name \u0026#34;~/.emacs.d/secret\u0026#34;)) my/load-config ~/.emacs.d/secret は個人マシンか会社マシンかによって置いてるデータが異なったりするためもしもファイルがなくてもエラーにならないような方法で load する方法が必要だった。\nというわけでファイルがなかったら読み込まずにメッセージを出力して終了するような関数を用意している。\n(defun my/load-config (file) (condition-case nil (load file) (file-missing (message \u0026#34;Load error: %s\u0026#34; file)))) ただ、これって結局\n(load file nil t) で十分な気もするので、置き換えを検討した方が良さそう。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/ui/neotree/",
	"title": "Neotree",
	"tags": ["replacement"],
	"description": "",
	"content": "概要 Neotree は Emacs でフォルダのツリー表示ができるやつ。メンテは活発じゃないようなので、その内乗り換えたい。\nレシピ Neotree でメンテされているのは dev ブランチだけど el-get の公式のレシピでは master ブランチを見ているので自前で recipe を用意してそれを使っている。\n(:name emacs-neotree-dev :website \u0026#34;https://github.com/jaypei/emacs-neotree\u0026#34; :description \u0026#34;An Emacs tree plugin like NerdTree for Vim.\u0026#34; :type github :branch \u0026#34;dev\u0026#34; :pkgname \u0026#34;jaypei/emacs-neotree\u0026#34;) インストール 上に書いたレシピを使ってインストールしている。\n(el-get-bundle emacs-neotree-dev) 使わなくなったコード 元々設定していたが、 counsel-projectile を使ってると projectile-switch-project-action を設定していても反映されず意味がないのに気付いたので使わなくなった\nhttps://github.com/mugijiru/.emacs.d/pull/183/files#r541843206\n(setq projectile-switch-project-action \u0026#39;neotree-projectile-action) テーマの設定 GUI で起動している時はアイコン表示しそうでない場合は ▾ とかで表示する\n(setq neo-theme (if (display-graphic-p) \u0026#39;icons \u0026#39;arrow)) のだけど、実際に今使ってるやつだともっとグラフィカルな表示なので all-the-icons の設定で上書きしている気がするので要確認\nmajor-mode-hydra いちいちキーバインドを覚えてられないので major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。\nとはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。\n(with-eval-after-load \u0026#39;major-mode-hydra (major-mode-hydra-define neotree-mode (:separator \u0026#34;-\u0026#34; :quit-key \u0026#34;q\u0026#34; :title (concat (all-the-icons-octicon \u0026#34;list-unordered\u0026#34;) \u0026#34; Neotree\u0026#34;)) (\u0026#34;Nav\u0026#34; ((\u0026#34;u\u0026#34; neotree-select-up-node \u0026#34;Up\u0026#34;) (\u0026#34;g\u0026#34; neotree-refresh \u0026#34;Refresh\u0026#34;) (\u0026#34;Q\u0026#34; neotree-hide \u0026#34;Hide\u0026#34;)) \u0026#34;File\u0026#34; ((\u0026#34;a\u0026#34; neo-open-file-ace-window \u0026#34;Ace\u0026#34;) (\u0026#34;N\u0026#34; neotree-create-node \u0026#34;Create\u0026#34;) (\u0026#34;R\u0026#34; neotree-rename-node \u0026#34;Rename\u0026#34;) (\u0026#34;C\u0026#34; neotree-copy-node \u0026#34;Copy\u0026#34;) (\u0026#34;D\u0026#34; neotree-delete-node \u0026#34;Delete\u0026#34;) (\u0026#34;SPC\u0026#34; neotree-quick-look \u0026#34;Look\u0026#34;) ;; (\u0026#34;d\u0026#34; neo-open-dired \u0026#34;Dired\u0026#34;) ;; (\u0026#34;O\u0026#34; neo-open-dir-recursive \u0026#34;Recursive\u0026#34;) ) \u0026#34;Toggle\u0026#34; ((\u0026#34;z\u0026#34; neotree-stretch-toggle \u0026#34;Size\u0026#34; :toggle (not (neo-window--minimize-p))) (\u0026#34;h\u0026#34; neotree-hidden-file-toggle \u0026#34;Hidden file\u0026#34; :toggle neo-buffer--show-hidden-file-p))))) キーバインド ナビゲーション    Key 効果     u 上のノードに移動   g 再描画   Q Neotree を隠す    ファイル操作    Key 効果     a ファイルを開く。その際に ace-window で開く window を指定する   N 新しいノードを作る   R ノードの名前を変える   C ノードのコピー   D ノードの削除   SPC クイックルック    Toggle    Key 効果     z Neotree のサイズを大きくしたり小さくしたり   h 隠しファイルを表示したり隠したり    "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/replacement/",
	"title": "replacement",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/savehist/",
	"title": "savehist",
	"tags": [],
	"description": "",
	"content": "概要 Emacs 標準でついている、ミニバッファの履歴などを保存してくれる機能。\n有効化 標準でついているので以下のようにするだけで有効化可能。\n(savehist-mode 1) 設定 標準で保存されるもの以外だと kill-ring だけを保存対象にしている。これで Emacs を終了させても kill-ring は残るようになるはず。だけど最近使えてない気がするな……。検証が必要そう。\n(setq savehist-additional-variables \u0026#39;(kill-ring)) 他にも有効にしたら便利そうなのがあれば追加したい。が、ぱっとは思い付かない。\n"
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/",
	"title": "sticky-control",
	"tags": [],
	"description": "",
	"content": "概要 指定したキーを2回叩いたら Control が押されてるような状態にしてくれるプラグイン。\nその2回の間隔はデフォルトだと 0.5 秒以内となっている。そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる\nさらに sticky-control-shortcuts に指定されてる一部のキーについては sticky 用のキーを押した直後に shortcuts のキーを押すと Control を押している状態でそのキーを押したことになる。\n例えば私は , を sticky 用のキーにしていて shortcuts に c を入れているので ,c と素早くタイプをすればそれだけで C-c が押された状態になる。\nインストール まずは el-get-bundle でインストール。\n(el-get-bundle sticky-control) ちなみにレシピは公式ではなかったのでとりあえず自分の環境で使えるように自作レシピを置いている。\n(:name sticky-control :description \u0026#34;save your left little finger\u0026#34; :type http :url \u0026#34;https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el\u0026#34; :features \u0026#34;sticky-control\u0026#34;) 元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど最近そこからは取得できなくなったので https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el から取得して利用している\n設定 まずは「2回叩いたら Control を押している状態になる」キーを指定する。\n(sticky-control-set-key \u0026#39;sticky-control-key ?,) 私は , を sticky-control のキーにしているのでこの指定。\nそして次に sticky-control-shortuts の指定。ここに指定しておくと、例えば ,c と素早くタイプすることで C-c が入力された状態とすることができる。\n(setq sticky-control-shortcuts \u0026#39;((?c . \u0026#34;\\C-c\u0026#34;) (?g . \u0026#34;\\C-g\u0026#34;) (?k . \u0026#34;\\C-k\u0026#34;) (?a . \u0026#34;\\C-a\u0026#34;) (?e . \u0026#34;\\C-e\u0026#34;) (?n . \u0026#34;\\C-n\u0026#34;) (?o . \u0026#34;\\C-o\u0026#34;) (?p . \u0026#34;\\C-p\u0026#34;) (?j . \u0026#34;\\C-j\u0026#34;) (?f . \u0026#34;\\C-f\u0026#34;) (?b . \u0026#34;\\C-b\u0026#34;) (?x . \u0026#34;\\C-x\u0026#34;) (?r . \u0026#34;\\C-r\u0026#34;) (?s . \u0026#34;\\C-s\u0026#34;))) 結構な数を指定しているけど、普段そんなに使えているわけでもない。まあ、大体 Control を押しながら使いそうなところは押さえてあるので何も考えずとも使えるようにしてある。\n有効化 最後に有効化\n(sticky-control-mode) "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/tags/unused/",
	"title": "unused",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/basics/gcmh/",
	"title": "ガベージコレクション",
	"tags": [],
	"description": "",
	"content": "概要 ガベージコレクションには gcmh というのを利用してみている。\nhttps://github.com/emacsmirror/gcmh\n普段は GC を控えめにしながら操作してない間に GC が走るような作りになっている。便利そう。\nインストール (el-get-bundle gcmh) これだけで有効化もされる。\nその他 以前の設定も折り畳んで残しておく\n  使わなくなったコード  gcmh を入れる前に設定していたコード。 gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。\n;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf ;; Increase threshold to fire garbage collection (setq gc-cons-threshold 1073741824) (setq garbage-collection-messages t) ;; Run GC every 60 seconds if emacs is idle. (run-with-idle-timer 60.0 t #\u0026#39;garbage-collect) \n "
},
{
	"uri": "https://mugijiru.github.io/.emacs.d/",
	"title": "麦汁&#39;s Emacs Config",
	"tags": [],
	"description": "",
	"content": "ここは @mugijiru の Emacs の設定ファイルの一部を解説しているページです。\nhttps://github.com/mugijiru/.emacs.d/blob/master/init.org から ox-hugo を使ってWebサイトに仕立て上げています。\n動作確認環境 以下の環境で使用しています。が、動作を保証するものではありません。\n macOS emacsmacport で用意されている Emacs Ubuntu 20.04 LTS apt で手に入る Emacs 26.3  注意点 まだ全ての設定を init.org に記載できていない上に init.org からの出力設定も済ませていないので極一部の設定ファイルのみの解説となります。\n"
}]