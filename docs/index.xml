<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>麦汁&#39;s Emacs Config</title>
    <link>https://mugijiru.github.io/.emacs.d/</link>
    <description>Recent content on 麦汁&#39;s Emacs Config</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language><atom:link href="https://mugijiru.github.io/.emacs.d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>with-simulated-input</title>
      <link>https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/</guid>
      <description>概要 with-simulated-input は入力処理をシミュレートするためのプラグイン。
公式のドキュメントにあるように
(with-simulated-input &amp;#34;hello SPC world RET&amp;#34; (read-string &amp;#34;Say hello to the world: &amp;#34;)) を評価すると read-string に対して「hello world」を入力したことになるので echo エリアに「hello world」と表示される。
これで何が嬉しいかというと Emacs Lisp でやっていることはインタラクティブな部分が大きいのでそういった要素をテストできるようになる。
具体的な使用例は test:my/org-todo で示す。
インストール el-get-bundle で GitHub からインストールしている
(el-get-bundle DarwinAwardWinner/with-simulated-input) </description>
    </item>
    
    <item>
      <title>実行方法</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/execution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/execution/</guid>
      <description>テストする時は以下のように叩いたら動く。
emacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el 今まで .emacs.d にいる状態でしか叩いたことないので他の場所にいる時に実行しても大丈夫かはわからない。
単体でテストしたい時は
-l ~/.emacs.d/inits/test/*-test.el の部分を書き換えたらいいんじゃないかな。やったことないけど。</description>
    </item>
    
    <item>
      <title>mocker.el</title>
      <link>https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/</guid>
      <description>概要 mocker.el は Emacs Lisp のテストで使う Mock ライブラリ。
使おうと思って導入したけど、自分のやりたいことはちょっと違ったので死蔵中
便利そうなのでとりあえず置いといている。
インストール el-get で GitHub から取得している。
(el-get-bundle sigma/mocker.el) </description>
    </item>
    
    <item>
      <title>run-tests</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/run-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/run-tests/</guid>
      <description>読み込んだテストをまるっとテストするためのコードをとりあえず置いている。
(if noninteractive (let ((ert-quiet t)) (ert-run-tests-batch-and-exit))) 後述の テストライブラリの読み込み などはここで担うべきかとも考えるが今はテストファイルが1つしかないので気にしないことにする。</description>
    </item>
    
    <item>
      <title>my-org-commands-test</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/</guid>
      <description>org-mode 用に定義したコマンドや関数のテストコード
Setup テストライブラリの読み込み 標準でついてくる ert を採用しているのでそれを読み込んでいる。
(require &amp;#39;ert) el-get の設定の読み込み プラグイン管理には el-get を利用しているのでその設定ファイルを読み込んでいる。
;; プラグイン読み込みの前準備 (load (expand-file-name (concat user-emacs-directory &amp;#34;/init-el-get.el&amp;#34;))) テスト補助のプラグイン読み込み with-simulated-input 上で説明しているが、入力をシミュレートするためのプラグインをテストで利用しているのでここで読み込んでいる。
;; 入力シミュレート用のプラグイン (load (expand-file-name (concat user-emacs-directory &amp;#34;/inits/99-with-simulated-input&amp;#34;))) 依存プラグインの読み込み テスト対象が依存しているプラグインを読み込んでいる。本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが現状だとその状態で GitHub Actions で動かせる方法がわからないので一旦個別に読み込むようにしている。
swiper ivy-read を使った機能のテストをするので読み込んでいる。
(el-get-bundle abo-abo/swiper) テスト対象の読み込み テストしたいファイルをここで読んでる。
;; テスト対象の読み込み (load (expand-file-name (concat user-emacs-directory &amp;#34;/inits/68-my-org-commands.el&amp;#34;))) ert-deftest test:my/org-todo-keyword-strings org-todo-keywords から &amp;ldquo;|&amp;rdquo; という区切りを除外したり &amp;ldquo;(s)&amp;rdquo; とかのような高速アクセスのためのキーワードは ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。
(ert-deftest test:my/org-todo-keyword-strings () &amp;#34;Test of `my/org-todo-keyword-strings&amp;#39;.&amp;#34; (let ((org-todo-keywords &amp;#39;((sequence &amp;#34;TODO&amp;#34; &amp;#34;DOING(!</description>
    </item>
    
    <item>
      <title>ace-window</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/ace-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/ace-window/</guid>
      <description>概要 Window 間の移動を ace-jump や avy のように表示されてる文字の Window に移動するやつ。
Window が2分割の時は文字も出ないで別の Window に移動してくれる。
C-x o にデフォルトで設定されている other-window は別の window に順番に移動するコマンドなので大量に分割していると移動がしんどいのだが ace-window を使うと起動して 1 ストロークで移動できるので C-x o をデフォルトの other-window から ace-window そのまま置き換えても便利に使える。
インストール いつも通り el-get でインストールしている。
(el-get-bundle ace-window) 設定 キーバインドは別の箇所で定義しているが C-x o で ace-window が起動するようにしている。
また Hydra からは ace-swap-window が起動できるようにしている。
ace-window には色々な機能があるからそれ用の Hydra を別途定義してもいいかもしれない。</description>
    </item>
    
    <item>
      <title>alert</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/alert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/alert/</guid>
      <description>概要 alert は色々な通知システムに対応した通知を飛ばせるパッケージ。 Mac だと Growl だったり terminal-notifier だったり Win だと toast だったり Linux だと libnotify だったりを使ってその環境での標準的な通知機能を使って通知ができるやつ。
インストール いつも通りに el-get でインストール。
(el-get-bundle alert) 設定 業務では Mac を使ってるので terminal-notifier を設定している。他の環境では大人しく message にしている。
(if (or (eq window-system &amp;#39;ns) (eq window-system &amp;#39;mac)) (setq alert-default-style &amp;#39;notifier) ;; use terminal-notifier (setq alert-default-style &amp;#39;message)) 本当は WSL2 でもいい感じに通知されるようにしたいが WSLで通知を出すメモ - cobodoのブログ とかを見てるとちょっと面倒そうなのでまた今度にする。</description>
    </item>
    
    <item>
      <title>all-the-icons</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/all-the-icons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/all-the-icons/</guid>
      <description>概要 all-the-icons は Emacs で様々なアイコンを表示できるようにして華やかにしてくれるパッケージです。 Neotree などでも対応していてアイコンでファイルの種類が表示されるようになってモダンな雰囲気が出ます。
インストール いつも通り el-get-bundle で入れている。明示的に require している理由は忘れました。
(el-get-bundle all-the-icons) (require &amp;#39;all-the-icons) フォントのインストール 以下のコマンドを叩くことでフォントをインストールすることができる。 all-the-icons のインストール直後に叩いておいたら普段は叩かなくて良いはず。
(all-the-icons-install-fonts) all-the-icons の更新後は叩いた方がいいかもしれない
キーバインド キーバインドは覚えられないし、使えるキーも大分埋まってるので、 pretty-hydra を使って all-the-icons 用の Hydra を用意している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define all-the-icons-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;All the icons&amp;#34; :exit t :quit-key &amp;#34;q&amp;#34;) (&amp;#34;Insert&amp;#34; ((&amp;#34;a&amp;#34; all-the-icons-insert-alltheicon &amp;#34;All the icons&amp;#34;) (&amp;#34;f&amp;#34; all-the-icons-insert-fileicon &amp;#34;File icons&amp;#34;) (&amp;#34;F&amp;#34; all-the-icons-insert-faicons &amp;#34;FontAwesome&amp;#34;) (&amp;#34;m&amp;#34; all-the-icons-insert-material &amp;#34;Material&amp;#34;) (&amp;#34;o&amp;#34; all-the-icons-insert-octicon &amp;#34;Octicon&amp;#34;) (&amp;#34;w&amp;#34; all-the-icons-insert-wicon &amp;#34;Weather&amp;#34;) (&amp;#34;*&amp;#34; all-the-icons-insert &amp;#34;All&amp;#34;)))))    Key 効果     a all-the-icons で追加されてるアイコンを検索して挿入   f ファイルアイコンを検索して挿入   F FontAwesome アイコンを検索して挿入   m Material アイコンを検索して挿入   o Octicon のアイコンを検索して挿入   w 天気アイコンを検索して挿入   * 全てのアイコンを検索して挿入    フォントのインストールコマンドもここに収めてしまうのが良さそうな気がする</description>
    </item>
    
    <item>
      <title>auto-insert</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/auto-insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/auto-insert/</guid>
      <description>概要 auto-insert はファイルを新規作成した時にファイル名に応じたテンプレートを挿入する機能。
Emacs が標準で持ってるライブラリなのでインストールは不要
設定 Emacs の設定は .emacs.d の中に閉じ込めたいので auto-insert のテンプレートも ~/.emacs.d/insert に閉じ込める設定にしている。
(custom-set-variables &amp;#39;(auto-insert-directory &amp;#34;~/.emacs.d/insert/&amp;#34;)) 有効化 あとは単に有効化している。
(auto-insert-mode 1) 他の設定 ファイル名を正規表現でマッチさせてテンプレートが選択されるので各言語やフレームワーク毎に設定を入れることにしている。
実際は今のところ inits/41-vue.el でのみ追加設定を入れている。</description>
    </item>
    
    <item>
      <title>auto-save</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/auto-save/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/auto-save/</guid>
      <description>概要 編集中状態の自動保存や、編集前や保存直後の状態のバックアップに関する設定をここでは書いている。
Emacs ではデフォルトでも編集中ファイルの自動保存や、編集前の状態の自動バックアップもしてくれるが開いているファイルとは違う場所に保存したりすることで、より便利になるのでいくつかの設定を入れている。
設定 自動保存設定 デフォルトだと #hoge.txt# みたいなファイル名で作られる、自動保存に関する設定。
まあこの自動保存されてやつを活用できてる気がしないのでこの自動保存自体不要な気はしているが、とりあえず場所を移動して邪魔にはならないようにはしている。
自動保存のタイミング 自動保存のタイミングは
 auto-save-timeout auto-save-interval  で制御されている。
まず auto-save-timeout で設定した秒数が経過すると再度自動保存が実行される。
これがデフォルトだと 30 秒なのだが、ちょっと長いのでその半分の 15 秒で保存されるように設定を変更している。
(setq auto-save-timeout 15) また auto-save-interval で設定した回数のキーイベントが発生すると再度自動保存を実行する。
これもデフォルトだと 300 と結構なキーを叩く必要があるので 60 回としている。
(setq auto-save-interval 60) 自動保存先を変更する 自動保存はそのままだと弄ってるファイルの場所に作られる。が、これは以下のようにすると ~/.emacs.d/backup/ 一応変更可能。
(setq auto-save-file-name-transforms &amp;#39;((&amp;#34;.*&amp;#34; &amp;#34;~/.emacs.d/backup/&amp;#34; t))) ただ、デフォルト値が
((&amp;#34;\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\&amp;#39;&amp;#34; &amp;#34;/tmp/\\2&amp;#34; t)) なので .* にしているのは乱暴そうな気がしている。
というわけで https://masutaka.net/chalow/2014-05-11-1.html に書かれているのを真似して
((&amp;#34;~/\\([^/]*/\\)*\\([^/]*\\)$&amp;#34; &amp;#34;~/.emacs.d/backup/\\2&amp;#34; t)) とでもした方が良いかもしれない。
バックアップファイル 自動保存とは別に、ファイルを開いた時点のバージョンや保存した時点のバージョンを取っておいてくれる自動バックアップ機能もあるのでその設定も弄っている。
バックアップ先のフォルダ指定 デフォルトでは編集しているファイルと同じフォルダにバックアップファイルを作成するようになっている。
だけど、こいつが結構邪魔なのでバックアップファイルは ~/.emacs.d/backup/ に全部保存するようにしている。
また、普段 tramp は使っていないが何かの拍子で使った時にバックアップが取られると邪魔そうなのでそれは保存しないようにしている。</description>
    </item>
    
    <item>
      <title>avy</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/avy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/avy/</guid>
      <description>概要 avy は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。 Vimium の f とかに似てる。
インストール el-get で普通にインストールしている
(el-get-bundle avy) 設定 文字の上に重なると元の文字列がよくわからなくなるので、移動先の文字の前に表示するようにしている
(setq avy-style &amp;#39;pre) キーバインド グローバルなキーバインドを汚染したくなかったのでひとまず Hydra を定義している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define avy-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;avy&amp;#34; :foreign-key warn :quit-key &amp;#34;q&amp;#34; :exit t) (&amp;#34;Char&amp;#34; ((&amp;#34;c&amp;#34; avy-goto-char &amp;#34;Char&amp;#34;) (&amp;#34;C&amp;#34; avy-goto-char-2 &amp;#34;Char 2&amp;#34;) (&amp;#34;x&amp;#34; avy-goto-char-timer &amp;#34;Char Timer&amp;#34;)) &amp;#34;Word&amp;#34; ((&amp;#34;w&amp;#34; avy-goto-word-1 &amp;#34;Word&amp;#34;) (&amp;#34;W&amp;#34; avy-goto-word-0 &amp;#34;Word 0&amp;#34;)) &amp;#34;Line&amp;#34; ((&amp;#34;l&amp;#34; avy-goto-line &amp;#34;Line&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;r&amp;#34; avy-resume &amp;#34;Resume&amp;#34;)))))    Key 効果     c 1文字からの絞り込み   C 2文字から絞り込み   x 任意の文字列からの絞り込み   w 1文字絞り込んで単語先頭に移動   W 絞り込みなしの単語移動   l 列移動   r 繰り返し同じコマンドを実行    </description>
    </item>
    
    <item>
      <title>browse-at-remote</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/browse-at-remote/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/browse-at-remote/</guid>
      <description>概要 browse-at-remote は Emacs で見ているファイルについて GitHub や GitLab などのサービス上での該当ブランチ、該当ファイル、該当行を開いてくれる便利なやつ。
業務だとレビュー中に「ここにこういう関数あるよ」みたいに示すことがあるけどその時に Emacs 内で関数を探して browse-at-remote で GitHub 上の位置を開くことでそこへのリンクを拾いやすく便利。
インストール いつも透り el-get で入れている。
(el-get-bundle browse-at-remote) 使い方 ブラウザで見たい行の上で M-x browse-at-remote を実行する。
または Region を選択している状態で実行すると、その範囲を選択している状態で開いてくれる。便利。
その他 Hydra でいつでも使えるようにキーバインドを割り当てている。</description>
    </item>
    
    <item>
      <title>company-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/company-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/company-mode/</guid>
      <description>概要 company-mode は Emacs での補完機能を提供してくれるパッケージです。プラグイン式に拡張しやすいのが特徴っぽい。
インストール いつも透り el-get から入れている
(el-get-bundle company-mode) 設定 ほとんど設定は入れていない。有効な時に C-s を入力すると検索ができる程度。
というのも最近の更新で、デフォルトが結構好みのキーバインドになったのでキーバインドはこだわる必要がなくなったのと、ついでに色もそこで好みな感じになってくれた。
というわけで設定は以下のようにとてもシンプル。
(with-eval-after-load &amp;#39;company ;; active (define-key company-active-map (kbd &amp;#34;C-s&amp;#34;) &amp;#39;company-search-candidates)) その他 グローバルでは有効にしていなくて各モードで有効にするような hook を入れている。
グローバルで有効でもいい気がしている。</description>
    </item>
    
    <item>
      <title>dumb-jump</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/dumb-jump/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/dumb-jump/</guid>
      <description>概要 dumb-jump は関数とかの定義されてる場所にお手軽にジャンプできるようにするパッケージ。めっちゃ色々な言語をサポートしている。
インストール いつも通り el-get でインストールしている。
(el-get-bundle dumb-jump) 設定 デフォルトプロジェクトの変更 デフォルトだと ~/ がデフォルトプロジェクトらしいがそんなに上の階層から調べられてもしょうがない気がするのでソースコードを置いているフォルダを指定している。
(setq dumb-jump-default-project &amp;#34;~/projects&amp;#34;) 複数マッチした時に使う絞り込み 最近はできるだけ ivy を使うようにしているので dumb-jump でも ivy を使うように指定している。
(setq dumb-jump-selector &amp;#39;ivy) キーバインド README に書いている hydra の設定をほぼパクってるけど pretty-hydra を使ってキーを定義している
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define dumb-jump-pretty-hydra (:foreign-keys warn :title &amp;#34;Dumb jump&amp;#34; :quit-key &amp;#34;q&amp;#34; :color blue :separator &amp;#34;-&amp;#34;) (&amp;#34;Go&amp;#34; ((&amp;#34;j&amp;#34; dumb-jump-go &amp;#34;Jump&amp;#34;) (&amp;#34;o&amp;#34; dumb-jump-go-other-window &amp;#34;Other window&amp;#34;)) &amp;#34;External&amp;#34; ((&amp;#34;e&amp;#34; dumb-jump-go-prefer-external &amp;#34;Go external&amp;#34;) (&amp;#34;x&amp;#34; dumb-jump-go-prefer-external-other-window &amp;#34;Go external other window&amp;#34;)) &amp;#34;Lock&amp;#34; ((&amp;#34;l&amp;#34; dumb-jump-quick-look &amp;#34;Quick look&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;b&amp;#34; dumb-jump-back &amp;#34;Back&amp;#34;)))))    Key 効果     j 定義場所にジャンプ   o 定義場所を別 window で開く   e 定義場所にジャンプ。ただし同じファイルより外部ファイルとのマッチを優先   x 定義場所を別 window で開く。ただし同じファイルより外部ファイルとのマッチを優先   l クイックルック。定義をツールチップ表示する   b 最後にジャンプされた場所に戻る。今は既に obsolute 扱い    </description>
    </item>
    
    <item>
      <title>Ember.js</title>
      <link>https://mugijiru.github.io/.emacs.d/framework-config/ember-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/framework-config/ember-js/</guid>
      <description>概要 Ember.js 用の Emacs の拡張としては ember-mode と handlebars-mode が存在する
ember-mode ember-mode は Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。実は麦汁さんは使えてない。
インストールするだけではダメで、 ember-mode を明示的に起動しないといけない。
そのためには dir-locals を使うとか projectile なんかがやってるようにフォルダ構成から判定させるみたいなことが必要そう。だるい。
というわけで死蔵中。
ついでにいうとキーバインドもだるい系なので使う時は Hydra を用意した方が良さそう
(el-get-bundle madnificent/ember-mode) handlebars-mode handlebars-mode は Ember.js のテンプレートエンジンとして採用されている Handlebars を書くためのモード。
syntax highlight と、いくつかの編集機能を備えている。が、今のところ麦汁さんは syntax highlight しか使えてない。
編集コマンドは major-mode-hydra で使えるようにしてあげれば良さそう
(el-get-bundle handlebars-mode) </description>
    </item>
    
    <item>
      <title>es6</title>
      <link>https://mugijiru.github.io/.emacs.d/language-config/es6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/language-config/es6/</guid>
      <description>概要 ES5 以前ではない JS を書くための設定。 es6 といいつつ ES2016(ES7) などもこの設定のまま書いている。
sprockets-es6 を使って ES6 対応をしていた時に es6 という拡張子を使っていたのでこのファイル名になっている。
インストール es6 はつまり JS なのでとりあえず el-get で js2-mode を入れている。
(el-get-bundle js2-mode) Hook  flycheck を有効にしてリアルタイムに文法チェックをしている  また javascript-eslint を使いたいので他2つは disable にしている   company-mode で補完できるようにしている smartparens-strict-mode でカッコなどの入力補助をしている インデントは空白2文字としている   (defun my/js2-mode-hook () (flycheck-mode 1) (setq flycheck-disabled-checkers &amp;#39;(javascript-standard javascript-jshint)) (company-mode 1) (turn-on-smartparens-strict-mode) (setq js2-basic-offset 2)) という Hook 用関数を用意しておいて
(add-hook &amp;#39;js2-mode-hook &amp;#39;my/js2-mode-hook) という感じで js2-mode-hook に追加している。
Lambda で一括でやる方法もあるけども、関数名つけて分離しておくと中身を簡単に入れ替えられて便利。</description>
    </item>
    
    <item>
      <title>exec-path</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/exec-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/exec-path/</guid>
      <description>概要 Emacs は通常最小限の環境変数しか利用しないようになっている。
が、それだと普段使う上で「ああ、このコマンドが使えなくてもどかしい……!」と感じてしまう。
そこで exec-path-from-shell というのを使って Emacs が見える PATH 環境変数をシェルが見てる PATH 環境変数と揃うようにしている。
インストール いつも通り el-get からインストールしている
(el-get-bundle exec-path-from-shell) 有効化 理由は忘れたが Mac の環境でのみ有効化している。その内 Linux 環境でも有効化を試みた方が良さそう
(when (memq window-system &amp;#39;(mac ns)) (exec-path-from-shell-initialize)) なお、これでシェルと共通の環境変数が使われるようになるのは デフォルトでは PATH と MANPATH のみである
その他 なぜか以下のようなコメントを書いていた。普段使っている zsh で持ってる PATH は使わないのだろうか? :thinking_face:
;; for exec path ;; use .bashrc setted path </description>
    </item>
    
    <item>
      <title>font-config</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/font-config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/font-config/</guid>
      <description>概要 Emacs で利用するフォントの設定。それなりの設定をしないとガタついたりするので通常あまり手を入れないで済ませている。
設定 Mac では 14, それ以外(Linux) では 12 を基準としている。
Mac と Linux で基準のサイズを変えているがなぜかこの方がガタガタもしないし大き過ぎもしないしでいい感じになる。
(let* ((size (if (or (eq window-system &amp;#39;ns) (eq window-system &amp;#39;mac)) 14 12)) (asciifont &amp;#34;Ricty Diminished&amp;#34;) ; ASCII fonts (jpfont &amp;#34;Ricty Diminished&amp;#34;) ; Japanese fonts (h (* size 10)) (fontspec (font-spec :family asciifont)) (jp-fontspec (font-spec :family jpfont))) (set-face-attribute &amp;#39;default nil :family asciifont :height h) (set-fontset-font nil &amp;#39;japanese-jisx0213.2004-1 jp-fontspec) (set-fontset-font nil &amp;#39;japanese-jisx0213-2 jp-fontspec) (set-fontset-font nil &amp;#39;katakana-jisx0201 jp-fontspec) (set-fontset-font nil &amp;#39;(#x0080 .</description>
    </item>
    
    <item>
      <title>forge</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/forge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/forge/</guid>
      <description>概要 forge は magit と github を連携させるやつ。一応入れているけど実は使えてないのであまりこの設定を呼んでも意味はなさそう
インストール いつも通り el-get でインストール
(el-get-bundle forge) 読み込み magit の拡張なので magit を読み込んで後に読み込まれるようにしている
(with-eval-after-load &amp;#39;magit (require &amp;#39;forge)) その他 リポジトリのコミット数が多いとまともに使えない感じだけどどうしたらいいの。</description>
    </item>
    
    <item>
      <title>git-gutter-fringe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/git-gutter-fringe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/git-gutter-fringe/</guid>
      <description>概要 git-gutter-fringe は git-gutter の派生版。最後のコミットからどの行を弄ったかを fringe 領域に表示してくれる。
他にも hunk の操作をできる機能とかあるみたいだけどそのあたりは使ったことがない……。
派生元の git-gutter は linum-mode と同じ領域を使って描画をしているようで併用ができなかったので git-gutter-fringe を利用している。
が、Emacs 26 から display-line-numbers-mode が搭載されて linum-mode が不要になったので git-gutter に乗り換えても良さそう
インストール いつも通り el-get でインストールしている
(el-get-bundle git-gutter-fringe) 有効化 Git 管理しているやつは全部差分情報が表示されて欲しいのでグローバルマイナーモードを有効にしている。
(global-git-gutter-mode t) その他 git-gutter ほどではないけど多少のカスタマイズはできるはずだがデフォルト設定で特に不満はないので何もしてない</description>
    </item>
    
    <item>
      <title>Google 連携</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/google-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/google-integration/</guid>
      <description>概要 Google と連携するパッケージとして google-this と google-translate を入れているが、どっちも Google を使うので1つの Hydra にまとめていた方が扱いやすいと思って統合している
キーバインド (with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define google-pretty-hydra (:foreign-keys warn :title &amp;#34;Google&amp;#34; :quit-key &amp;#34;q&amp;#34; :color blue :separator &amp;#34;-&amp;#34;) (&amp;#34;Current&amp;#34; ((&amp;#34;SPC&amp;#34; google-this-noconfirm &amp;#34;No Confirm&amp;#34;) (&amp;#34;RET&amp;#34; google-this &amp;#34;Auto&amp;#34;) (&amp;#34;w&amp;#34; google-this-word &amp;#34;Word&amp;#34;) (&amp;#34;l&amp;#34; google-this-line &amp;#34;Line&amp;#34;) (&amp;#34;s&amp;#34; google-this-symbol &amp;#34;Symbol&amp;#34;) (&amp;#34;r&amp;#34; google-this-region &amp;#34;Region&amp;#34;) (&amp;#34;e&amp;#34; google-this-error &amp;#34;Error&amp;#34;)) &amp;#34;Feeling Lucky&amp;#34; ((&amp;#34;L&amp;#34; google-this-lucky-search &amp;#34;Lucky&amp;#34;) (&amp;#34;i&amp;#34; google-this-lucky-and-insert-url &amp;#34;Insert URL&amp;#34;)) &amp;#34;Translate&amp;#34; ((&amp;#34;t&amp;#34; google-translate-at-point &amp;#34;EN =&amp;gt; JP&amp;#34;) (&amp;#34;T&amp;#34; google-translate-at-point-reverse &amp;#34;JP =&amp;gt; EN&amp;#34;)) &amp;#34;Tool&amp;#34; ((&amp;#34;W&amp;#34; google-this-forecast &amp;#34;Weather&amp;#34;)))))    Key 効果     SPC 確認なしで検索   RET どの範囲の情報で検索するか自動判定して検索   w 近くの単語で検索   l その行の内容で検索。エラーの検索とかに良いかも   s シンボルで検索。使うのは Emacs Lisp の関数調べる時ぐらいか?</description>
    </item>
    
    <item>
      <title>google-this</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/google-this/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/google-this/</guid>
      <description>概要 google-this は Google 検索を Emacs の中から行えるやつ。
インストール いつも通り el-get でインストール
(el-get-bundle google-this) で、本来の使い方だとこのあとに
(google-this-mode 1) とやって有効化することになるがそれをしても google-this のデフォルトキーバインドが設定されるぐらいで自分はそのデフォルトキーバインドを使う気がないので有効化はしてない。
キーバインド キーバインドは Hydra で設定しているが、 google-translate と統合したので キーバインド &amp;gt; Google 連携 に記載している。</description>
    </item>
    
    <item>
      <title>google-translate</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/google-translate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/google-translate/</guid>
      <description>概要 google-translate は Google 翻訳する機能を提供するパッケージ。
インストール いつも通り el-get でインストール
(el-get-bundle google-translate) 関数のオーバーライド どうも最新版でも壊れっぱなしのようなので https://github.com/atykhonov/google-translate/issues/52#issuecomment-727920888 にあるように関数を上書きしている。
(with-eval-after-load &amp;#39;google-translate-tk (defun google-translate--search-tkk () &amp;#34;Search TKK.&amp;#34; (list 430675 2721866130))) google-translate-tk に定義されていて、それが読まれた後に上書きしないといけないので with-eval-after-load を使っている。
default-ui の読み込み Google Translate は UI を defauult と smooth のどちらかから選べるようになっている。
default だと
 google-translate-default-source-language google-translate-default-target-language  を設定しておいて
 M-x google-translate-at-point source → target の翻訳 M-x google-translate-at-point-reverse target → source の翻訳  という使い方をする。
smooth だと翻訳の source, target を複数設定して多言語対応ができるが、英語以外を翻訳することがないので smooth でなくていいかという感じで default を採用している。</description>
    </item>
    
    <item>
      <title>helm</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/helm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/helm/</guid>
      <description>概要 helm は anything.el の後継であり、インクリメンタルに候補の絞り込みをしたりする UI を提供する便利なパッケージ。
peco とか fzf とかと似ているっちゃ似ているかな? fzf 使ったことないけど。
一時期開発が止まってるようだったけど最近(2021年)はまた更新が活発になっている。
ただ、麦汁さんは ivy に乗り換えようとしているので helm の設定は頑張っていない。 helm-for-files が便利なのでまだ捨てられてないけど……。
インストール helm で使いたい拡張として helm-descbinds と helm-ag というのがあるのでそれらも同時に入れている。
(el-get-bundle helm) (el-get-bundle helm-descbinds) (el-get-bundle helm-ag) ただ descbinds は counsel-descbinds に置き換えたし helm-ag ももう使ってない気がする
設定 オススメの設定が helm に同梱されている helm-config に入ってるのでまずはそれを読み込んでいる。
(require &amp;#39;helm-config) また helm-descbinds を使えるように有効にしている。けど、上にも書いたけどもう counsel-descbinds に置き換えちゃったのよね……。
(helm-descbinds-mode) あとは helm-migemo-mode というのを有効にしている。これがあると helm で検索する時に migemo れて便利。
(helm-migemo-mode 1) ivy の方でも migemo 対応したいけどまだできてない……。
その他 helm 系の設定は他の設定にも色々影響も大きそうなので読み込み順は結構早いタイミングにしている(init-loader で 20 を prefix にしている)</description>
    </item>
    
    <item>
      <title>helm-posframe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/helm-posframe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/helm-posframe/</guid>
      <description>概要 helm-posframe は helm の拡張で Helm のバッファの表示を posframe を使うようにしてくれるやつ。
実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなのでいずれ外すかもしれない。
ただ確か本体の方の挙動が気に入らなかったような気はする。
インストール いつも通り el-get でインストール。 GitHub にあるのでそれを取得するようにしている。
(el-get-bundle tumashu/helm-posframe) 有効化 (helm-posframe-enable) </description>
    </item>
    
    <item>
      <title>highlight-indent-guides</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/</guid>
      <description>概要 highlight-indent-guides はインデント毎にラインを引いたりして見易くしてくれるパッケージ。通常のプログラムを書く時にも便利だけど、 YAML などのインデントがそのまま構造になるような言語を弄る時にとても便利。
インストール これもいつも通り el-get でインストールしている。また GitHub にあるので、そこから直接インストールしている。
(el-get-bundle DarthFennec/highlight-indent-guides) 設定 今いる行がどのインデントにいるのかをわかりやすくするために responsive モードを有効にしている。
(setq highlight-indent-guides-responsive &amp;#34;stack&amp;#34;) defcustom で定義されてる変数なので custom-set-variables で設定した方がいいかもしれない。</description>
    </item>
    
    <item>
      <title>key-chord</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/key-chord/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/key-chord/</guid>
      <description>概要 key-chord はキーを同時に押した時にコマンドを発動させるということができるようにしてくれるパッケージ。
なのですが本家の方だと誤爆が多いということなのでそれを改善した zk-phi/key-chord の方を利用している。
まあほとんど使えてないので改良版の恩恵をまだ受けてないけど……。
インストール いつも通り el-get でインストールしている。本家の方じゃないので GitHub のリポジトリから突っ込んでいる。
(el-get-bundle zk-phi/key-chord) 設定 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。
(setq key-chord-two-keys-delay 0.15 key-chord-safety-interval-backward 0.1 key-chord-safety-interval-forward 0.15) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。
改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動に使っている上に Hydra で叩けるやつでよく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。
有効化 設定を入れた後は有効にするだけである。
(key-chord-mode 1) 実際のキーバインド設定は各モードだったりグローバルキーバインドを設定しているファイルだったりで書く感じ。
といいつつ現状では Hydra 起動のやつしか使ってないので、グローバルキーバインド設定でしか書いてない。
その他 sticky-control も control 限定で似たようなことをしているので key-chord に全部置き換えできるかもしれない。</description>
    </item>
    
    <item>
      <title>load-path</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/load-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/load-path/</guid>
      <description>概要 load-path は Emacs の設定でも重要な項目でこのリストに追加されている path は load または require する際に走査される path となっている。
即ち load-path を通しておけば、そこに置いている emacs lisp のファイルは簡単に読み出せるようになる。
なお package-install や el-get を使っておけば基本的に自分で load-path を通す必要はない。
秘匿情報を入れてるフォルダを読み込み可能にする パスワードなどの秘匿情報を持っている部分は ~/.emacs.d/secret というフォルダで管理している。そのためここに入ってる emacs lisp のファイルも読み込めるように load-path に追加している。
(add-to-list &amp;#39;load-path (expand-file-name &amp;#34;~/.emacs.d/secret&amp;#34;)) my/load-config ~/.emacs.d/secret は個人マシンか会社マシンかによって置いてるデータが異なったりするためもしもファイルがなくてもエラーにならないような方法で load する方法が必要だった。
というわけでファイルがなかったら読み込まずにメッセージを出力して終了するような関数を用意している。
(defun my/load-config (file) (condition-case nil (load file) (file-missing (message &amp;#34;Load error: %s&amp;#34; file)))) ただ、これって結局
(load file nil t) で十分な気もするので、置き換えを検討した方が良さそう。</description>
    </item>
    
    <item>
      <title>magit</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/magit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/magit/</guid>
      <description>概要 magit は Emacs の上で Git の色々な操作ができるやつ。結構使いやすいのでオススメなやつ。
forge を使うと GitHub や GitLab とも連携できてさらに便利、なはず。
インストール (el-get-bundle magit) 使い方 Git 管理されてるファイルを開いている時に M-x magit とかすると Git 管理用のバッファが出て来るしそこで ? を叩いたらどういうコマンドが使えるのか教えてくれるよ(雑)</description>
    </item>
    
    <item>
      <title>markdown</title>
      <link>https://mugijiru.github.io/.emacs.d/language-config/markdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/language-config/markdown/</guid>
      <description>概要 Markdown を書くための設定。といいつつ markdown-mode を入れてるだけだけども。
手元でテキストドキュメントを弄るのは org-mode が多いからなあ……
インストール いつも通り el-get で入れている。
(el-get-bundle markdown-mode) </description>
    </item>
    
    <item>
      <title>Neotree</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/neotree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/neotree/</guid>
      <description>概要 Neotree は Emacs でフォルダのツリー表示ができるやつ。メンテは活発じゃないようなので、その内乗り換えたい。
レシピ Neotree でメンテされているのは dev ブランチだけど el-get の公式のレシピでは master ブランチを見ているので自前で recipe を用意してそれを使っている。
(:name emacs-neotree-dev :website &amp;#34;https://github.com/jaypei/emacs-neotree&amp;#34; :description &amp;#34;An Emacs tree plugin like NerdTree for Vim.&amp;#34; :type github :branch &amp;#34;dev&amp;#34; :pkgname &amp;#34;jaypei/emacs-neotree&amp;#34;) インストール 上に書いたレシピを使ってインストールしている。
(el-get-bundle emacs-neotree-dev) 使わなくなったコード 元々設定していたが、 counsel-projectile を使ってると projectile-switch-project-action を設定していても反映されず意味がないのに気付いたので使わなくなった
https://github.com/mugijiru/.emacs.d/pull/183/files#r541843206
(setq projectile-switch-project-action &amp;#39;neotree-projectile-action) テーマの設定 GUI で起動している時はアイコン表示しそうでない場合は ▾ とかで表示する
(setq neo-theme (if (display-graphic-p) &amp;#39;icons &amp;#39;arrow)) のだけど、実際に今使ってるやつだともっとグラフィカルな表示なので all-the-icons の設定で上書きしている気がするので要確認
major-mode-hydra いちいちキーバインドを覚えてられないので major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。
とはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。</description>
    </item>
    
    <item>
      <title>plantuml-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/language-config/plantuml-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/language-config/plantuml-mode/</guid>
      <description>概要 plantuml-mode は PlantUML という、テキストだけで UML 図などが描けるツール用のモード。
インストール いつも通り el-get で入れてる
(el-get-bundle plantuml-mode) 設定 実行モードは &#39;jar を指定している。デフォルトは &#39;server なんだけどオフラインの時も使いたいししね。
(setq plantuml-default-exec-mode &amp;#39;jar) el-get でインスコすると jar ファイルも自動で拾って来て plantuml-mode と同じディレクトリに設置して plantuml-jar-path も通してくれるからそっち使う方が便利だしね。
その他 最新の develop ブランチだとインデントを調整できる機能が入っているので乗り換えたいけどそのためには el-get のレシピを書いてあげる必要がありそうで放置している。</description>
    </item>
    
    <item>
      <title>posframe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/posframe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/posframe/</guid>
      <description>概要 posframe は child frame を表示させるためのパッケージ。 Emacs のど真ん中に表示したり、今あるカーソル位置のすぐそばに出したりできる。
ivy なんかを使う時に ivy-posframe ど真ん中に出すと、いつもそこに表示されるし真ん中なの視線移動が少なくて済むし ddskk-posframe なんかで変換候補をカーソル位置のそばに出て来るので一般的な日本語変換ソフトと同様にこれまた視線移動が少なくて便利。
という感じで色々なものの拡張として使わているやつ。
インストール いつも通り el-get で入れているだけ。
(el-get-bundle posframe) こいつ自体には特に設定を入れてない。というか設定項目自体2個しか存在していない。
ま、こいつ単体で使うものでもないしね。</description>
    </item>
    
    <item>
      <title>projectile</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/projectile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/projectile/</guid>
      <description>概要 projectile はプロジェクト内のファイルを検索したりするのに便利なパッケージ
インストール いつも通り el-get からインストールする
(el-get-bundle projectile) helm との連携 helm-projectile を使って helm と連携できるようにしている。けど ivy に乗り換えを進めているので多分これ使ってないんだよな……。というわけでこの設定は消す候補に入っている。
(el-get-bundle helm-projectile) (helm-projectile-on) 有効化 このあたりで有効化しておいている。この順序に意味があったかは忘れた……。
(projectile-mode) 無視リスト 普段 Rails ばっかりやってるのでそれ関係のものを無視リストに入れている。けどあんまりメンテしてない。
無視するディレクトリ (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;tmp&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;.tmp&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;vendor&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;.sass-cache&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;coverage&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;cache&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;log&amp;#34;) node_modules もここに突っ込んでも良いかもしれない。
無視するファイル (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;gems.tags&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;project.tags&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;manifest.json&amp;#34;) tags ファイルは昔は使っていたけど、最近は dumb-jump が優秀なのと、面倒で使ってないのでそろそろ gems.tags と project.tags は不要かもしれない。
ivy/counsel との連携 上の方で helm との連携処理を入れていたが今は大体 ivy に乗り換えているので ivy 連携もしている。</description>
    </item>
    
    <item>
      <title>savehist</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/savehist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/savehist/</guid>
      <description>概要 Emacs 標準でついている、ミニバッファの履歴などを保存してくれる機能。
有効化 標準でついているので以下のようにするだけで有効化可能。
(savehist-mode 1) 設定 標準で保存されるもの以外だと kill-ring だけを保存対象にしている。これで Emacs を終了させても kill-ring は残るようになるはず。だけど最近使えてない気がするな……。検証が必要そう。
(setq savehist-additional-variables &amp;#39;(kill-ring)) 他にも有効にしたら便利そうなのがあれば追加したい。が、ぱっとは思い付かない。</description>
    </item>
    
    <item>
      <title>show-paren-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/show-paren-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/show-paren-mode/</guid>
      <description>概要 show-paren-mode は Emacs に標準で入っているやつで開き括弧と閉じ括弧の対応を示してくれたり括弧の中身を強調表示したりする機能を提供してくれるやつ。
有効化 デフォで入ってるので以下のようにするだけで有効化される。
(show-paren-mode 1) デフォ設定だと対応する括弧を強調表示するだけだけどまあそれで悪くないと思ってるので今のところデフォルト設定のままである。
その他 http://syohex.hatenablog.com/entry/20110331/1301584188
の記事へのリンクを設定ファイルの中に残していたけど設定は特に弄ってないのでまたその記事読んだりで設定弄ってみてもいいかもしれない。
また smartparens.el にも似た機能はあるようだけど Emacs 標準機能の方が軽そうなのでとりあえずこのままにするつもり。</description>
    </item>
    
    <item>
      <title>smartparens</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/smartparens/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/smartparens/</guid>
      <description>概要 smartparens はカッコとかクォートとかのペアになるようなものの入力補助をしてくれるやつ。
strict モードだとペアが崩れないように強制するので雑に C-k で行削除しててもペアが維持されて便利。
インストール いつも透り el-get で導入している
(el-get-bundle smartparens) 設定 実は導入して間もないので、提供されてるオススメ設定のみ突っ込んでいる。オススメ設定は別途 reqiure したら良いという作りなので、以下のようにして突っ込んでいる。
(require &amp;#39;smartparens-config) その他 各言語の hook で smartparens-strict-mode を有効にしている。なんか常に有効だと困りそうな気がしたので。</description>
    </item>
    
    <item>
      <title>sticky-control</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/</guid>
      <description>概要 指定したキーを2回叩いたら Control が押されてるような状態にしてくれるプラグイン。
その2回の間隔はデフォルトだと 0.5 秒以内となっている。そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる
さらに sticky-control-shortcuts に指定されてる一部のキーについては sticky 用のキーを押した直後に shortcuts のキーを押すと Control を押している状態でそのキーを押したことになる。
例えば私は , を sticky 用のキーにしていて shortcuts に c を入れているので ,c と素早くタイプをすればそれだけで C-c が押された状態になる。
インストール まずは el-get-bundle でインストール。
(el-get-bundle sticky-control) ちなみにレシピは公式ではなかったのでとりあえず自分の環境で使えるように自作レシピを置いている。
(:name sticky-control :description &amp;#34;save your left little finger&amp;#34; :type http :url &amp;#34;https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el&amp;#34; :features &amp;#34;sticky-control&amp;#34;) 元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど最近そこからは取得できなくなったので https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el から取得して利用している
設定 まずは「2回叩いたら Control を押している状態になる」キーを指定する。
(sticky-control-set-key &amp;#39;sticky-control-key ?,) 私は , を sticky-control のキーにしているのでこの指定。
そして次に sticky-control-shortuts の指定。ここに指定しておくと、例えば ,c と素早くタイプすることで C-c が入力された状態とすることができる。</description>
    </item>
    
    <item>
      <title>toolbar</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/toolbar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/toolbar/</guid>
      <description>概要 Emacs 標準の toolbar の設定。麦汁さんは使わないし幅を取るので隠す派。
設定 単に無効にして隠している
(tool-bar-mode -1) </description>
    </item>
    
    <item>
      <title>undo-fu</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/undo-fu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/undo-fu/</guid>
      <description>概要 undo-fu はシンプルな undo/redo 機能を提供してくれるやつ。
昔はもっと色々できる undo-tree を使っていたけどそっちにバグがあるっぽいので乗り換えた。
インストール (el-get-bundle undo-fu) キーバインド 別の場所で定義しているけど、以下のキーバインドにしている。
   Key 効果     C-/ undo   C-M-/ redo    </description>
    </item>
    
    <item>
      <title>uniquify</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/uniquify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/uniquify/</guid>
      <description>概要 同じ名前のファイルを開いている時に祖先のディレクトリ名を表示してくれてどこのファイルかわかりやすくしてくれるやつ。
すぐ親とかも同名でも、名前が違うところまで遡って表示してくれる。
有効化 Emacs に標準で入ってるので require するだけで有効にできる
(require &amp;#39;uniquify) 設定 自分は ファイル名&amp;lt;フォルダ名&amp;gt; みたいな表示になる形式にしている。その方がファイル名が主という感じになって使いやすそうだなって。
そういう意味では post-foward の方が幅を使わない分良いかもしれない。いつか検討しても良いかもしれない。
(setq uniquify-buffer-name-style &amp;#39;post-forward-angle-brackets) </description>
    </item>
    
    <item>
      <title>yaml-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/language-config/yaml-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/language-config/yaml-mode/</guid>
      <description>概要 yaml-mode は yaml を編集する時のメジャーモード。インデントを調整しやすい。
インストール いつも通り el-get でインストール
(el-get-bundle yaml-mode) hook mode に対する hook は関数を定義してその中で呼びたいコードを書いていくようにしている。
lambda で書いてしまうと hook を弄りたい時に結構面倒なのだけど関数を定義しておくと、その関数の中身を変更して評価しておくだけで hook で動作する中身が変更できて便利。
とりあえず yaml-mode では以下のようにして highlight-indent-guides を有効にしている。
(defun my/yaml-mode-hook () (highlight-indent-guides-mode 1)) で、その hook を最後に yaml-mode-hook に追加している。
(add-hook &amp;#39;yaml-mode-hook &amp;#39;my/yaml-mode-hook) </description>
    </item>
    
    <item>
      <title>yascroll</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/yascroll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/yascroll/</guid>
      <description>概要 yascroll は標準のスクロールバーとは異なるスクロールバーを表示するやつ。
デフォルトだと右側の fringe 領域に表示するのであまり邪魔にならないし表示領域を必要以上に狭めないので気に入っている。
最初に作られたっぽい記事は 主張しないスクロールバーモード、yascroll.elをリリースしました - Functional Emacser にある。タイトル通り、あまり主張しない感じで良い。
インストール いつも通り el-get でインストールしている
(el-get-bundle yascroll) これだけで大体いい感じに表示されるので便利。たまに表示されなくなることもあるが、まあそこまで重要なやつでもないのであまり気にしていない</description>
    </item>
    
    <item>
      <title>yasnippet</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/yasnippet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/yasnippet/</guid>
      <description>概要 yasnippet はテンプレートを挿入する機能を持ったパッケージ。 Emacs でそこそこ何かを書いている人なら大体知ってるような有名なやつだと思う。
インストール いつも通り el-get でインストール
(el-get-bundle yasnippet) 有効化 どこでも使いたいぐらい便利なやつなので global に有効化している
(yas-global-mode 1) キーバインド 基本的に覚えられないので Hydra を使って定義している
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define yasnippet-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;Yasnippet&amp;#34; :foreign-key warn :quit-key &amp;#34;q&amp;#34; :exit t) (&amp;#34;Edit&amp;#34; ((&amp;#34;n&amp;#34; yas-new-snippet &amp;#34;New&amp;#34;) (&amp;#34;v&amp;#34; yas-visit-snippet-file &amp;#34;Visit&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;i&amp;#34; yas-insert-snippet &amp;#34;Insert&amp;#34;) (&amp;#34;l&amp;#34; yas-describe-tables &amp;#34;List&amp;#34;) (&amp;#34;r&amp;#34; yas-reload-all &amp;#34;Reload all&amp;#34;)))))    Key 効果     n 現在のメジャーモード用に新しい snippet を作る   v 現在のメジャーモードの登録済 snippet ファイルを開く   i snippet の挿入。選択は ivy で行われる。   l 現在のメジャーモードの登録済 snippet の一覧表示   r snippet を全部 load し直す    その他 実は、どういう snippet があれば便利なのかよくわかってなくて snippet をほとんど登録してない。</description>
    </item>
    
    <item>
      <title>zoom</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/zoom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/zoom/</guid>
      <description>概要 zoom はフォーカスが当たっている Window が大きく表示されるようにするやつ。最近流行りのビデオチャットツールではない。
どこにフォーカスが当たっているかわかりやすくなるし、狭い画面でも見たい部分を広げて表示できるので便利。
インストール いつも通り el-get から入れる。 GitHub から直接取得するように設定している。
(el-get-bundle cyrus-and/zoom) 設定  起動時に有効化 1画面しか使えない時は必須なので 比率を黄金比に変更 この方が使いやすいっぽい。  という設定をしている。
(custom-set-variables &amp;#39;(zoom-mode t) &amp;#39;(zoom-size &amp;#39;(0.618 . 0.618))) </description>
    </item>
    
    <item>
      <title>zoom-window</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/zoom-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/zoom-window/</guid>
      <description>概要 zoom-window は tmux の prefix z のような動きをするやつ。表示している window をフレーム全体に広げたり戻したりすることができる。
インストール いつも通り el-get から入れている
(el-get-bundle zoom-window) その他 キーバインドは 80-global-keybinds に書いたけど C-x 1 に割り当てている。
ただそれだと tmux と使い勝手が違うなって感じているのでそのうち hydra の中の z にでもアサインしようかと思う。
あと、その window を最大化して戻すことよりも単に他の window が邪魔なことの方が多い気もしている。。。</description>
    </item>
    
    <item>
      <title>ガベージコレクション</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/gcmh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/gcmh/</guid>
      <description>概要 ガベージコレクションには gcmh というのを利用してみている。
https://github.com/emacsmirror/gcmh
普段は GC を控えめにしながら操作してない間に GC が走るような作りになっている。便利そう。
インストール (el-get-bundle gcmh) これだけで有効化もされる。
その他 以前の設定も折り畳んで残しておく
  使わなくなったコード  gcmh を入れる前に設定していたコード。 gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。
;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf ;; Increase threshold to fire garbage collection (setq gc-cons-threshold 1073741824) (setq garbage-collection-messages t) ;; Run GC every 60 seconds if emacs is idle. (run-with-idle-timer 60.0 t #&amp;#39;garbage-collect) 
 </description>
    </item>
    
  </channel>
</rss>
