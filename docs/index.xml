<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>麦汁&#39;s Emacs Config</title>
    <link>https://mugijiru.github.io/.emacs.d/</link>
    <description>Recent content on 麦汁&#39;s Emacs Config</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language><atom:link href="https://mugijiru.github.io/.emacs.d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>with-simulated-input</title>
      <link>https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/</guid>
      <description>概要 with-simulated-input は入力処理をシミュレートするためのプラグイン。
公式のドキュメントにあるように
(with-simulated-input &amp;#34;hello SPC world RET&amp;#34; (read-string &amp;#34;Say hello to the world: &amp;#34;)) を評価すると read-string に対して「hello world」を入力したことになるので echo エリアに「hello world」と表示される。
これで何が嬉しいかというと Emacs Lisp でやっていることはインタラクティブな部分が大きいのでそういった要素をテストできるようになる。
具体的な使用例は test:my/org-todo で示す。
インストール el-get-bundle で GitHub からインストールしている
(el-get-bundle DarwinAwardWinner/with-simulated-input) </description>
    </item>
    
    <item>
      <title>実行方法</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/execution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/execution/</guid>
      <description>テストする時は以下のように叩いたら動く。
emacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el 今まで .emacs.d にいる状態でしか叩いたことないので他の場所にいる時に実行しても大丈夫かはわからない。
単体でテストしたい時は
-l ~/.emacs.d/inits/test/*-test.el の部分を書き換えたらいいんじゃないかな。やったことないけど。</description>
    </item>
    
    <item>
      <title>mocker.el</title>
      <link>https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/</guid>
      <description>概要 mocker.el は Emacs Lisp のテストで使う Mock ライブラリ。
使おうと思って導入したけど、自分のやりたいことはちょっと違ったので死蔵中
便利そうなのでとりあえず置いといている。
インストール el-get で GitHub から取得している。
(el-get-bundle sigma/mocker.el) </description>
    </item>
    
    <item>
      <title>run-tests</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/run-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/run-tests/</guid>
      <description>読み込んだテストをまるっとテストするためのコードをとりあえず置いている。
(if noninteractive (let ((ert-quiet t)) (ert-run-tests-batch-and-exit))) 後述の テストライブラリの読み込み などはここで担うべきかとも考えるが今はテストファイルが1つしかないので気にしないことにする。</description>
    </item>
    
    <item>
      <title>my-org-commands-test</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/</guid>
      <description>org-mode 用に定義したコマンドや関数のテストコード
Setup テストライブラリの読み込み 標準でついてくる ert を採用しているのでそれを読み込んでいる。
(require &amp;#39;ert) el-get の設定の読み込み プラグイン管理には el-get を利用しているのでその設定ファイルを読み込んでいる。
;; プラグイン読み込みの前準備 (load (expand-file-name (concat user-emacs-directory &amp;#34;/init-el-get.el&amp;#34;))) テスト補助のプラグイン読み込み with-simulated-input 上で説明しているが、入力をシミュレートするためのプラグインをテストで利用しているのでここで読み込んでいる。
;; 入力シミュレート用のプラグイン (load (expand-file-name (concat user-emacs-directory &amp;#34;/inits/99-with-simulated-input&amp;#34;))) 依存プラグインの読み込み テスト対象が依存しているプラグインを読み込んでいる。本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが現状だとその状態で GitHub Actions で動かせる方法がわからないので一旦個別に読み込むようにしている。
swiper ivy-read を使った機能のテストをするので読み込んでいる。
(el-get-bundle abo-abo/swiper) テスト対象の読み込み テストしたいファイルをここで読んでる。
;; テスト対象の読み込み (load (expand-file-name (concat user-emacs-directory &amp;#34;/inits/68-my-org-commands.el&amp;#34;))) ert-deftest test:my/org-todo-keyword-strings org-todo-keywords から &amp;ldquo;|&amp;rdquo; という区切りを除外したり &amp;ldquo;(s)&amp;rdquo; とかのような高速アクセスのためのキーワードは ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。
(ert-deftest test:my/org-todo-keyword-strings () &amp;#34;Test of `my/org-todo-keyword-strings&amp;#39;.&amp;#34; (let ((org-todo-keywords &amp;#39;((sequence &amp;#34;TODO&amp;#34; &amp;#34;DOING(!</description>
    </item>
    
    <item>
      <title>1. 基本設定</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/base/</guid>
      <description>概要 ここでは org-mode 周りのベースとなる設定を書いているつもり。といいつつ、まだ書き方が雑だなと思っている。またその内にでも修正しよう
org-mode のインストール Emacs に標準で入っている org-mode は大体古過ぎるのでとりあえずデフォルトで入ってるやつは削除しちゃって el-get でインストールしている。
(el-get-bundle org-mode :checkout &amp;#34;release_9.3.6&amp;#34;) なんか入れてるパッケージの問題か、依存関係が解決できなかったので Git から入れた上でバージョンを固定している。
バージョンぐらいはそのうち上げたいね
org 用ディレクトリの指定 org-mode のファイルを保存するデフォルトのディレクトリを指定している。
デフォルトだと ~/org なのだけどホームディレクトリを汚したくないのと基本的に Mac を使ってるので ~/Documents/org というディレクトリを用意してそこにファイルを置いている。
(setq org-directory (expand-file-name &amp;#34;~/Documents/org/&amp;#34;)) タスク管理ファイルのフォルダの指定 タスク管理ファイルがいくつかに分かれているがそれらをまとめて ~/Documents/org/tasks フォルダに置いている。
(setq my/org-tasks-directory (concat org-directory &amp;#34;tasks/&amp;#34;)) とりあえずこの my/org-tasks-directory という変数を用意することであちらこちらでこれを使い回している。
タスクの状態管理のキーワード指定 org-mode といえば TODO 管理で使ってる人も多いと思う。自分も最初はそういう使い方から始めたし、今でもそれをメインにして使っている。
そして TODO の状態がデフォルトでは
 TODO DONE  の2つしかないけど、それでは足りないので昔見たインターネットのどこかの記事を参考に以下のように設定している。
(setq org-todo-keywords &amp;#39;((sequence &amp;#34;TODO&amp;#34; &amp;#34;DOING(!)&amp;#34; &amp;#34;WAIT&amp;#34; &amp;#34;|&amp;#34; &amp;#34;DONE(!)&amp;#34; &amp;#34;SOMEDAY(s)&amp;#34;))) 初期状態は TODO で、作業開始時点で DOING にして待ちが発生したら WAIT にして完了したら DONE にしている。</description>
    </item>
    
    <item>
      <title>2. org-babel</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-babel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-babel/</guid>
      <description>概要 ここでは org-babel の設定をまとめている。
org-export-blocks-format-plantuml org-mode で PlantUML の図を出力する拡張を入れている。
(el-get-bundle org-export-blocks-format-plantuml) のだけれど https://www.emacswiki.org/emacs/org-export-blocks-format-plantuml.el を見ると Obsolute と書いてますね。今度消さなきゃ。
org-babel で評価可能な言語の指定 なんか普段から使いそうな奴をとりあえず選定しているつもり。
(org-babel-do-load-languages &amp;#39;org-babel-load-languages &amp;#39;((plantuml . t) (sql . t) (gnuplot . t) (emacs-lisp . t) (shell . t) (js . t) (ruby . t)))  js, ruby 仕事でメインで使ってる言語なので入れている。 shell 入れてる方が便利そう、ぐらいの雑な理由。 sql メモしておいて手元から実行できると便利そう plantuml 図の出力。一番使ってる。 gnuplot 趣味で入れてみているけど実際使う機会ほとんどないよなって気がしてきている。  org-babel-execute 後に画像を再表示 PlantUML の処理をすることが多いので以下の hook を設定することで実行後に画像を再表示するようにしている
(add-hook &amp;#39;org-babel-after-execute-hook &amp;#39;org-redisplay-inline-images) org-babel の非同期実行 非同期に org-babel の source を実行するために ob-async を入れている</description>
    </item>
    
    <item>
      <title>ace-window</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/ace-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/ace-window/</guid>
      <description>概要 Window 間の移動を ace-jump や avy のように表示されてる文字の Window に移動するやつ。
Window が2分割の時は文字も出ないで別の Window に移動してくれる。
C-x o にデフォルトで設定されている other-window は別の window に順番に移動するコマンドなので大量に分割していると移動がしんどいのだが ace-window を使うと起動して 1 ストロークで移動できるので C-x o をデフォルトの other-window から ace-window そのまま置き換えても便利に使える。
インストール いつも通り el-get でインストールしている。
(el-get-bundle ace-window) 設定 キーバインドは別の箇所で定義しているが C-x o で ace-window が起動するようにしている。
また Hydra からは ace-swap-window が起動できるようにしている。
ace-window には色々な機能があるからそれ用の Hydra を別途定義してもいいかもしれない。</description>
    </item>
    
    <item>
      <title>alert</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/alert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/alert/</guid>
      <description>概要 alert は色々な通知システムに対応した通知を飛ばせるパッケージ。 Mac だと Growl だったり terminal-notifier だったり Win だと toast だったり Linux だと libnotify だったりを使ってその環境での標準的な通知機能を使って通知ができるやつ。
インストール いつも通りに el-get でインストール。
(el-get-bundle alert) 設定 業務では Mac を使ってるので terminal-notifier を設定している。他の環境では大人しく message にしている。
(if (or (eq window-system &amp;#39;ns) (eq window-system &amp;#39;mac)) (setq alert-default-style &amp;#39;notifier) ;; use terminal-notifier (setq alert-default-style &amp;#39;message)) 本当は WSL2 でもいい感じに通知されるようにしたいが WSLで通知を出すメモ - cobodoのブログ とかを見てるとちょっと面倒そうなのでまた今度にする。</description>
    </item>
    
    <item>
      <title>all-the-icons</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/all-the-icons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/all-the-icons/</guid>
      <description>概要 all-the-icons は Emacs で様々なアイコンを表示できるようにして華やかにしてくれるパッケージです。 Neotree などでも対応していてアイコンでファイルの種類が表示されるようになってモダンな雰囲気が出ます。
インストール いつも通り el-get-bundle で入れている。明示的に require している理由は忘れました。
(el-get-bundle all-the-icons) (require &amp;#39;all-the-icons) フォントのインストール 以下のコマンドを叩くことでフォントをインストールすることができる。 all-the-icons のインストール直後に叩いておいたら普段は叩かなくて良いはず。
(all-the-icons-install-fonts) all-the-icons の更新後は叩いた方がいいかもしれない
キーバインド キーバインドは覚えられないし、使えるキーも大分埋まってるので、 pretty-hydra を使って all-the-icons 用の Hydra を用意している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define all-the-icons-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;All the icons&amp;#34; :exit t :quit-key &amp;#34;q&amp;#34;) (&amp;#34;Insert&amp;#34; ((&amp;#34;a&amp;#34; all-the-icons-insert-alltheicon &amp;#34;All the icons&amp;#34;) (&amp;#34;f&amp;#34; all-the-icons-insert-fileicon &amp;#34;File icons&amp;#34;) (&amp;#34;F&amp;#34; all-the-icons-insert-faicons &amp;#34;FontAwesome&amp;#34;) (&amp;#34;m&amp;#34; all-the-icons-insert-material &amp;#34;Material&amp;#34;) (&amp;#34;o&amp;#34; all-the-icons-insert-octicon &amp;#34;Octicon&amp;#34;) (&amp;#34;w&amp;#34; all-the-icons-insert-wicon &amp;#34;Weather&amp;#34;) (&amp;#34;*&amp;#34; all-the-icons-insert &amp;#34;All&amp;#34;)))))    Key 効果     a all-the-icons で追加されてるアイコンを検索して挿入   f ファイルアイコンを検索して挿入   F FontAwesome アイコンを検索して挿入   m Material アイコンを検索して挿入   o Octicon のアイコンを検索して挿入   w 天気アイコンを検索して挿入   * 全てのアイコンを検索して挿入    フォントのインストールコマンドもここに収めてしまうのが良さそうな気がする</description>
    </item>
    
    <item>
      <title>auth-source</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/auth-source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/auth-source/</guid>
      <description>概要 auth-source は Emacs でパスワードのような秘匿情報を扱うための仕組み。 Emacs の各パッケージが認証情報を要求する時にこいつ経由で取得できるようにしておくと秘匿もできて便利っぽい。
パスワードの保存先はデフォルトだと (&amp;quot;~/.authinfo&amp;quot; &amp;quot;~/.authinfo.gpg&amp;quot; &amp;quot;~/.netrc&amp;quot;) となっている。
拡張子が gpg だと EagyPG Assistant で保存時に暗号化されるので便利。
ファイル指定 自分は Emacs でしか使わないであろう情報ということで /.emacs.d/.authinfo.gpg を指定している。
(custom-set-variables &amp;#39;(auth-sources (quote (&amp;#34;~/.emacs.d/.authinfo.gpg&amp;#34;)))) </description>
    </item>
    
    <item>
      <title>auto-insert</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/auto-insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/auto-insert/</guid>
      <description>概要 auto-insert はファイルを新規作成した時にファイル名に応じたテンプレートを挿入する機能。
Emacs が標準で持ってるライブラリなのでインストールは不要
設定 Emacs の設定は .emacs.d の中に閉じ込めたいので auto-insert のテンプレートも ~/.emacs.d/insert に閉じ込める設定にしている。
(custom-set-variables &amp;#39;(auto-insert-directory &amp;#34;~/.emacs.d/insert/&amp;#34;)) 有効化 あとは単に有効化している。
(auto-insert-mode 1) 他の設定 ファイル名を正規表現でマッチさせてテンプレートが選択されるので各言語やフレームワーク毎に設定を入れることにしている。
実際は今のところ inits/41-vue.el でのみ追加設定を入れている。</description>
    </item>
    
    <item>
      <title>auto-save</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/auto-save/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/auto-save/</guid>
      <description>概要 編集中状態の自動保存や、編集前や保存直後の状態のバックアップに関する設定をここでは書いている。
Emacs ではデフォルトでも編集中ファイルの自動保存や、編集前の状態の自動バックアップもしてくれるが開いているファイルとは違う場所に保存したりすることで、より便利になるのでいくつかの設定を入れている。
設定 自動保存設定 デフォルトだと #hoge.txt# みたいなファイル名で作られる、自動保存に関する設定。
まあこの自動保存されてやつを活用できてる気がしないのでこの自動保存自体不要な気はしているが、とりあえず場所を移動して邪魔にはならないようにはしている。
自動保存のタイミング 自動保存のタイミングは
 auto-save-timeout auto-save-interval  で制御されている。
まず auto-save-timeout で設定した秒数が経過すると再度自動保存が実行される。
これがデフォルトだと 30 秒なのだが、ちょっと長いのでその半分の 15 秒で保存されるように設定を変更している。
(setq auto-save-timeout 15) また auto-save-interval で設定した回数のキーイベントが発生すると再度自動保存を実行する。
これもデフォルトだと 300 と結構なキーを叩く必要があるので 60 回としている。
(setq auto-save-interval 60) 自動保存先を変更する 自動保存はそのままだと弄ってるファイルの場所に作られる。が、これは以下のようにすると ~/.emacs.d/backup/ 一応変更可能。
(setq auto-save-file-name-transforms &amp;#39;((&amp;#34;.*&amp;#34; &amp;#34;~/.emacs.d/backup/&amp;#34; t))) ただ、デフォルト値が
((&amp;#34;\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\&amp;#39;&amp;#34; &amp;#34;/tmp/\\2&amp;#34; t)) なので .* にしているのは乱暴そうな気がしている。
というわけで https://masutaka.net/chalow/2014-05-11-1.html に書かれているのを真似して
((&amp;#34;~/\\([^/]*/\\)*\\([^/]*\\)$&amp;#34; &amp;#34;~/.emacs.d/backup/\\2&amp;#34; t)) とでもした方が良いかもしれない。
バックアップファイル 自動保存とは別に、ファイルを開いた時点のバージョンや保存した時点のバージョンを取っておいてくれる自動バックアップ機能もあるのでその設定も弄っている。
バックアップ先のフォルダ指定 デフォルトでは編集しているファイルと同じフォルダにバックアップファイルを作成するようになっている。
だけど、こいつが結構邪魔なのでバックアップファイルは ~/.emacs.d/backup/ に全部保存するようにしている。
また、普段 tramp は使っていないが何かの拍子で使った時にバックアップが取られると邪魔そうなのでそれは保存しないようにしている。</description>
    </item>
    
    <item>
      <title>avy</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/avy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/avy/</guid>
      <description>概要 avy は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。 Vimium の f とかに似てる。
インストール el-get で普通にインストールしている
(el-get-bundle avy) 設定 文字の上に重なると元の文字列がよくわからなくなるので、移動先の文字の前に表示するようにしている
(setq avy-style &amp;#39;pre) キーバインド グローバルなキーバインドを汚染したくなかったのでひとまず Hydra を定義している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define avy-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;avy&amp;#34; :foreign-key warn :quit-key &amp;#34;q&amp;#34; :exit t) (&amp;#34;Char&amp;#34; ((&amp;#34;c&amp;#34; avy-goto-char &amp;#34;Char&amp;#34;) (&amp;#34;C&amp;#34; avy-goto-char-2 &amp;#34;Char 2&amp;#34;) (&amp;#34;x&amp;#34; avy-goto-char-timer &amp;#34;Char Timer&amp;#34;)) &amp;#34;Word&amp;#34; ((&amp;#34;w&amp;#34; avy-goto-word-1 &amp;#34;Word&amp;#34;) (&amp;#34;W&amp;#34; avy-goto-word-0 &amp;#34;Word 0&amp;#34;)) &amp;#34;Line&amp;#34; ((&amp;#34;l&amp;#34; avy-goto-line &amp;#34;Line&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;r&amp;#34; avy-resume &amp;#34;Resume&amp;#34;)))))    Key 効果     c 1文字からの絞り込み   C 2文字から絞り込み   x 任意の文字列からの絞り込み   w 1文字絞り込んで単語先頭に移動   W 絞り込みなしの単語移動   l 列移動   r 繰り返し同じコマンドを実行    </description>
    </item>
    
    <item>
      <title>browse-at-remote</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/browse-at-remote/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/browse-at-remote/</guid>
      <description>概要 browse-at-remote は Emacs で見ているファイルについて GitHub や GitLab などのサービス上での該当ブランチ、該当ファイル、該当行を開いてくれる便利なやつ。
業務だとレビュー中に「ここにこういう関数あるよ」みたいに示すことがあるけどその時に Emacs 内で関数を探して browse-at-remote で GitHub 上の位置を開くことでそこへのリンクを拾いやすく便利。
インストール いつも透り el-get で入れている。
(el-get-bundle browse-at-remote) 使い方 ブラウザで見たい行の上で M-x browse-at-remote を実行する。
または Region を選択している状態で実行すると、その範囲を選択している状態で開いてくれる。便利。
その他 Hydra でいつでも使えるようにキーバインドを割り当てている。</description>
    </item>
    
    <item>
      <title>company-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/company-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/company-mode/</guid>
      <description>概要 company-mode は Emacs での補完機能を提供してくれるパッケージです。プラグイン式に拡張しやすいのが特徴っぽい。
インストール いつも透り el-get から入れている
(el-get-bundle company-mode) 設定 ほとんど設定は入れていない。有効な時に C-s を入力すると検索ができる程度。
というのも最近の更新で、デフォルトが結構好みのキーバインドになったのでキーバインドはこだわる必要がなくなったのと、ついでに色もそこで好みな感じになってくれた。
というわけで設定は以下のようにとてもシンプル。
(with-eval-after-load &amp;#39;company ;; active (define-key company-active-map (kbd &amp;#34;C-s&amp;#34;) &amp;#39;company-search-candidates)) その他 グローバルでは有効にしていなくて各モードで有効にするような hook を入れている。
グローバルで有効でもいい気がしている。</description>
    </item>
    
    <item>
      <title>custom-file</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/custom-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/custom-file/</guid>
      <description>概要 Emacs では customize 機能などで設定したファイルを標準だと init.el の末尾に追記したりするが自動吐き出しされるものがあるとバージョン管理が難しくなるので別ファイルに出力するようにするなどの調整をしている。
出力先の設定 .emacs.d の中に閉じ込めておく方が管理が楽なので出力先として ~/.emacs.d/custom.el を指定している。
(setq custom-file (expand-file-name &amp;#34;~/.emacs.d/custom.el&amp;#34;)) カスタム設定の読み込み 起動時に、設定が入っているファイルが読み込まれないと保存した設定が有効にならないので load を使って読んでいる。
(load custom-file) その他 カスタムファイルは終盤で読み込む方がいいかと思って init-loader では 99 という最後の方で読まれる番号を振っている。
このあたりの設定を個別のパッケージの設定の方に移動したらこのファイルは空にできるんじゃないかなとも思っているが、それはゆっくり対応していくつもり</description>
    </item>
    
    <item>
      <title>dumb-jump</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/dumb-jump/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/dumb-jump/</guid>
      <description>概要 dumb-jump は関数とかの定義されてる場所にお手軽にジャンプできるようにするパッケージ。めっちゃ色々な言語をサポートしている。
インストール いつも通り el-get でインストールしている。
(el-get-bundle dumb-jump) 設定 デフォルトプロジェクトの変更 デフォルトだと ~/ がデフォルトプロジェクトらしいがそんなに上の階層から調べられてもしょうがない気がするのでソースコードを置いているフォルダを指定している。
(setq dumb-jump-default-project &amp;#34;~/projects&amp;#34;) 複数マッチした時に使う絞り込み 最近はできるだけ ivy を使うようにしているので dumb-jump でも ivy を使うように指定している。
(setq dumb-jump-selector &amp;#39;ivy) キーバインド README に書いている hydra の設定をほぼパクってるけど pretty-hydra を使ってキーを定義している
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define dumb-jump-pretty-hydra (:foreign-keys warn :title &amp;#34;Dumb jump&amp;#34; :quit-key &amp;#34;q&amp;#34; :color blue :separator &amp;#34;-&amp;#34;) (&amp;#34;Go&amp;#34; ((&amp;#34;j&amp;#34; dumb-jump-go &amp;#34;Jump&amp;#34;) (&amp;#34;o&amp;#34; dumb-jump-go-other-window &amp;#34;Other window&amp;#34;)) &amp;#34;External&amp;#34; ((&amp;#34;e&amp;#34; dumb-jump-go-prefer-external &amp;#34;Go external&amp;#34;) (&amp;#34;x&amp;#34; dumb-jump-go-prefer-external-other-window &amp;#34;Go external other window&amp;#34;)) &amp;#34;Lock&amp;#34; ((&amp;#34;l&amp;#34; dumb-jump-quick-look &amp;#34;Quick look&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;b&amp;#34; dumb-jump-back &amp;#34;Back&amp;#34;)))))    Key 効果     j 定義場所にジャンプ   o 定義場所を別 window で開く   e 定義場所にジャンプ。ただし同じファイルより外部ファイルとのマッチを優先   x 定義場所を別 window で開く。ただし同じファイルより外部ファイルとのマッチを優先   l クイックルック。定義をツールチップ表示する   b 最後にジャンプされた場所に戻る。今は既に obsolute 扱い    </description>
    </item>
    
    <item>
      <title>emacs-lisp</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/emacs-lisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/emacs-lisp/</guid>
      <description>概要 Emacs Lisp を書くための設定。まあそんなにしっかり書いてないので、あんまり設定は入ってない
Hook Hook 用の関数を定義してその中に色々書いている。
 とりあえず行数表示が欲しいので display-line-numbers-mode を有効化 当然補完もしたいので company-mode を有効にしている カッコの対応などもいい感じに動いて欲しいので smartparens-mode とその strict-mode を有効にしている   (defun my/emacs-lisp-mode-hook () (display-line-numbers-mode 1) (company-mode 1) (smartparens-mode 1) (turn-on-smartparens-strict-mode)) そんで最後にその関数を hook に突っ込んでる。
(add-hook &amp;#39;emacs-lisp-mode-hook &amp;#39;my/emacs-lisp-mode-hook) アイコン挿入コマンドの用意 時々 UI 設定目的で絵文字を使うことがあるので挿入できるコマンドを用意している。最近使った記憶ないけど。
(defun my/insert-all-the-icons-code (family) (interactive) (let* ((candidates (all-the-icons--read-candidates-for-family family)) (prompt (format &amp;#34;%s Icon: &amp;#34; (funcall (all-the-icons--family-name family)))) (selection (completing-read prompt candidates nil t))) (insert &amp;#34;(all-the-icons-&amp;#34; (symbol-name family) &amp;#34; \&amp;#34;&amp;#34; selection &amp;#34;\&amp;#34;)&amp;#34;))) キーバインド emacs-lisp-mode 用に major-mode-hydra を設定している。けどそんなにしっかり Emacs Lisp を書いてるわけではないのがバレバレな感じである。</description>
    </item>
    
    <item>
      <title>emacs-w3m</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/emacs-w3m/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/emacs-w3m/</guid>
      <description>概要 w3m という和製のテキストブラウザを Emacs 上で使うためのパッケージ。つまり w3m 自体もインストールしておく必要がある。
インストール emacs-w3m は el-get で入れられるので以下のようにして入れている
(el-get-bundle emacs-w3m) 今はこれだけしか入れてない。昔の設定はどこかにいっちゃった……。</description>
    </item>
    
    <item>
      <title>Ember.js</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/ember-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/ember-js/</guid>
      <description>概要 Ember.js 用の Emacs の拡張としては ember-mode と handlebars-mode が存在する
ember-mode ember-mode は Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。実は麦汁さんは使えてない。
インストールするだけではダメで、 ember-mode を明示的に起動しないといけない。
そのためには dir-locals を使うとか projectile なんかがやってるようにフォルダ構成から判定させるみたいなことが必要そう。だるい。
というわけで死蔵中。
ついでにいうとキーバインドもだるい系なので使う時は Hydra を用意した方が良さそう
(el-get-bundle madnificent/ember-mode) handlebars-mode handlebars-mode は Ember.js のテンプレートエンジンとして採用されている Handlebars を書くためのモード。
syntax highlight と、いくつかの編集機能を備えている。が、今のところ麦汁さんは syntax highlight しか使えてない。
編集コマンドは major-mode-hydra で使えるようにしてあげれば良さそう
(el-get-bundle handlebars-mode) </description>
    </item>
    
    <item>
      <title>es6</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/es6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/es6/</guid>
      <description>概要 ES5 以前ではない JS を書くための設定。 es6 といいつつ ES2016(ES7) などもこの設定のまま書いている。
sprockets-es6 を使って ES6 対応をしていた時に es6 という拡張子を使っていたのでこのファイル名になっている。
インストール es6 はつまり JS なのでとりあえず el-get で js2-mode を入れている。
(el-get-bundle js2-mode) Hook  flycheck を有効にしてリアルタイムに文法チェックをしている  また javascript-eslint を使いたいので他2つは disable にしている   company-mode で補完できるようにしている smartparens-strict-mode でカッコなどの入力補助をしている インデントは空白2文字としている   (defun my/js2-mode-hook () (flycheck-mode 1) (setq flycheck-disabled-checkers &amp;#39;(javascript-standard javascript-jshint)) (company-mode 1) (turn-on-smartparens-strict-mode) (setq js2-basic-offset 2)) という Hook 用関数を用意しておいて
(add-hook &amp;#39;js2-mode-hook &amp;#39;my/js2-mode-hook) という感じで js2-mode-hook に追加している。
Lambda で一括でやる方法もあるけども、関数名つけて分離しておくと中身を簡単に入れ替えられて便利。</description>
    </item>
    
    <item>
      <title>exec-path</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/exec-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/exec-path/</guid>
      <description>概要 Emacs は通常最小限の環境変数しか利用しないようになっている。
が、それだと普段使う上で「ああ、このコマンドが使えなくてもどかしい……!」と感じてしまう。
そこで exec-path-from-shell というのを使って Emacs が見える PATH 環境変数をシェルが見てる PATH 環境変数と揃うようにしている。
インストール いつも通り el-get からインストールしている
(el-get-bundle exec-path-from-shell) 有効化 理由は忘れたが Mac の環境でのみ有効化している。その内 Linux 環境でも有効化を試みた方が良さそう
(when (memq window-system &amp;#39;(mac ns)) (exec-path-from-shell-initialize)) なお、これでシェルと共通の環境変数が使われるようになるのは デフォルトでは PATH と MANPATH のみである
その他 なぜか以下のようなコメントを書いていた。普段使っている zsh で持ってる PATH は使わないのだろうか? :thinking_face:
;; for exec path ;; use .bashrc setted path </description>
    </item>
    
    <item>
      <title>flycheck</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/flycheck/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/flycheck/</guid>
      <description>概要 flycheck はリアルタイムで文法チェックなんかをするのに便利なモード。 flymake よりモダンなやつだったんだけど最近は flymake に戻る人もいるっぽいのでどっちが良いかよくわかってない
インストール flycheck と同時にカーソルのそばに pos-tip で通知内容を表示してくれる flycheck-pos-tip をインストールしている
(el-get-bundle flycheck) (el-get-bundle flycheck-pos-tip) 設定 flycheck を読んだ後で flycheck-pos-tip-mode が有効になるようにしている。これは公式に書かれているやりかたに則っている https://github.com/flycheck/flycheck-pos-tip#installation
(with-eval-after-load &amp;#39;flycheck (flycheck-pos-tip-mode)) その他 flycheck-posframe flycheck-pos-tip は flycheck 公式のプラグインなので採用しているけど同じことを posframe でやってくれる flycheck-posframe に置き換えた方が見た目麗しくなりそうな気がしている。
言語毎の設定 各言語向けの設定もあるけどそれは各言語の設定ファイル内に書いているのでここでは書いてない
プログラミング関係の設定 &amp;gt; ruby とか プログラミング関係の設定 &amp;gt; scss とかに書いているはず</description>
    </item>
    
    <item>
      <title>font-config</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/font-config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/font-config/</guid>
      <description>概要 Emacs で利用するフォントの設定。それなりの設定をしないとガタついたりするので通常あまり手を入れないで済ませている。
設定 Mac では 14, それ以外(Linux) では 12 を基準としている。
Mac と Linux で基準のサイズを変えているがなぜかこの方がガタガタもしないし大き過ぎもしないしでいい感じになる。
(let* ((size (if (or (eq window-system &amp;#39;ns) (eq window-system &amp;#39;mac)) 14 12)) (asciifont &amp;#34;Ricty Diminished&amp;#34;) ; ASCII fonts (jpfont &amp;#34;Ricty Diminished&amp;#34;) ; Japanese fonts (h (* size 10)) (fontspec (font-spec :family asciifont)) (jp-fontspec (font-spec :family jpfont))) (set-face-attribute &amp;#39;default nil :family asciifont :height h) (set-fontset-font nil &amp;#39;japanese-jisx0213.2004-1 jp-fontspec) (set-fontset-font nil &amp;#39;japanese-jisx0213-2 jp-fontspec) (set-fontset-font nil &amp;#39;katakana-jisx0201 jp-fontspec) (set-fontset-font nil &amp;#39;(#x0080 .</description>
    </item>
    
    <item>
      <title>forge</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/forge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/forge/</guid>
      <description>概要 forge は magit と github を連携させるやつ。一応入れているけど実は使えてないのであまりこの設定を呼んでも意味はなさそう
インストール いつも通り el-get でインストール
(el-get-bundle forge) 読み込み magit の拡張なので magit を読み込んで後に読み込まれるようにしている
(with-eval-after-load &amp;#39;magit (require &amp;#39;forge)) その他 リポジトリのコミット数が多いとまともに使えない感じだけどどうしたらいいの。</description>
    </item>
    
    <item>
      <title>frame-cmds</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/frame-cmds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/frame-cmds/</guid>
      <description>概要 frame-cmds は Emacs のフレーム操作に関するコマンド集。上下左右に移動したり広げたりといったことができる。いや、他にもできそうなんだけど、私がそれを把握してない。
インストール el-get で以下のように書くと emacswiki からインストールされる。
(el-get-bundle frame-cmds) キーバインド 無論キーバインドは覚えられないので以下のように Hydra で定義している
(pretty-hydra-define window-control-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;Window Control&amp;#34; :exit nil :quit-key &amp;#34;q&amp;#34;) (&amp;#34;Move&amp;#34; ((&amp;#34;h&amp;#34; move-frame-left &amp;#34;Left&amp;#34;) (&amp;#34;j&amp;#34; move-frame-down &amp;#34;Down&amp;#34;) (&amp;#34;k&amp;#34; move-frame-up &amp;#34;Up&amp;#34;) (&amp;#34;l&amp;#34; move-frame-right &amp;#34;Right&amp;#34;)) &amp;#34;Resize&amp;#34; ((&amp;#34;H&amp;#34; shrink-frame-horizontally &amp;#34;H-&amp;#34;) (&amp;#34;J&amp;#34; enlarge-frame &amp;#34;V+&amp;#34;) (&amp;#34;K&amp;#34; shrink-frame &amp;#34;V-&amp;#34;) (&amp;#34;L&amp;#34; enlarge-frame-horizontally &amp;#34;H+&amp;#34;))))    Key 効果     h 左に移動   j 下に移動   k 上に移動   l 右いん移動   H 左右方向に縮める   J 上下方向に広げる   K 上下方向に縮める   L 左右方向に広げる    </description>
    </item>
    
    <item>
      <title>fullscreen</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/fullscreen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/fullscreen/</guid>
      <description>概要 起動時にフルスクリーンにする設定はここにまとめている
Mac の設定 Mac の場合にフルスクリーンにする設定を入れていた。けど 2020-01-08 に yabai WM を導入したことにより起動時はフルスクリーンじゃない方がよくなったので以下の処理は今は使ってない。
(if (or (eq window-system &amp;#39;ns) (eq window-system &amp;#39;mac)) (add-hook &amp;#39;window-setup-hook (lambda () (set-frame-parameter nil &amp;#39;fullscreen &amp;#39;fullboth)))) Linux(X Window system) の設定 X Window system の場合にはフルスクリーンにする。まあ Linux って書いているけど WSL2 用なのである。
(if (eq window-system &amp;#39;x) (add-hook &amp;#39;window-setup-hook (lambda () (set-frame-parameter nil &amp;#39;fullscreen &amp;#39;fullboth) (set-frame-position nil 0 0)))) 微妙に画面の下の方がちゃんとフルになってくれてないけどそこは今は我慢して使っている。</description>
    </item>
    
    <item>
      <title>git-gutter-fringe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/git-gutter-fringe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/git-gutter-fringe/</guid>
      <description>概要 git-gutter-fringe は git-gutter の派生版。最後のコミットからどの行を弄ったかを fringe 領域に表示してくれる。
他にも hunk の操作をできる機能とかあるみたいだけどそのあたりは使ったことがない……。
派生元の git-gutter は linum-mode と同じ領域を使って描画をしているようで併用ができなかったので git-gutter-fringe を利用している。
が、Emacs 26 から display-line-numbers-mode が搭載されて linum-mode が不要になったので git-gutter に乗り換えても良さそう
インストール いつも通り el-get でインストールしている
(el-get-bundle git-gutter-fringe) 有効化 Git 管理しているやつは全部差分情報が表示されて欲しいのでグローバルマイナーモードを有効にしている。
(global-git-gutter-mode t) その他 git-gutter ほどではないけど多少のカスタマイズはできるはずだがデフォルト設定で特に不満はないので何もしてない</description>
    </item>
    
    <item>
      <title>gnuplot-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/gnuplot-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/gnuplot-mode/</guid>
      <description>概要 gnuplot-mode はグラフ作成ソフトである gnuplot を Emacs で使うためのパッケージ。 Syntax Highlight や 補完機能 などを提供する。
まあほとんど使ってないんだけど。
インストール いつも通り el-get で入れている
(el-get-bundle gnuplot-mode) その他 org-mode から使ってた記憶があるのでそっちの方で何か設定があるかもしれない</description>
    </item>
    
    <item>
      <title>Google 連携</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/google-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/google-integration/</guid>
      <description>概要 Google と連携するパッケージとして google-this と google-translate を入れているが、どっちも Google を使うので1つの Hydra にまとめていた方が扱いやすいと思って統合している
キーバインド (with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define google-pretty-hydra (:foreign-keys warn :title &amp;#34;Google&amp;#34; :quit-key &amp;#34;q&amp;#34; :color blue :separator &amp;#34;-&amp;#34;) (&amp;#34;Current&amp;#34; ((&amp;#34;SPC&amp;#34; google-this-noconfirm &amp;#34;No Confirm&amp;#34;) (&amp;#34;RET&amp;#34; google-this &amp;#34;Auto&amp;#34;) (&amp;#34;w&amp;#34; google-this-word &amp;#34;Word&amp;#34;) (&amp;#34;l&amp;#34; google-this-line &amp;#34;Line&amp;#34;) (&amp;#34;s&amp;#34; google-this-symbol &amp;#34;Symbol&amp;#34;) (&amp;#34;r&amp;#34; google-this-region &amp;#34;Region&amp;#34;) (&amp;#34;e&amp;#34; google-this-error &amp;#34;Error&amp;#34;)) &amp;#34;Feeling Lucky&amp;#34; ((&amp;#34;L&amp;#34; google-this-lucky-search &amp;#34;Lucky&amp;#34;) (&amp;#34;i&amp;#34; google-this-lucky-and-insert-url &amp;#34;Insert URL&amp;#34;)) &amp;#34;Translate&amp;#34; ((&amp;#34;t&amp;#34; google-translate-at-point &amp;#34;EN =&amp;gt; JP&amp;#34;) (&amp;#34;T&amp;#34; google-translate-at-point-reverse &amp;#34;JP =&amp;gt; EN&amp;#34;)) &amp;#34;Tool&amp;#34; ((&amp;#34;W&amp;#34; google-this-forecast &amp;#34;Weather&amp;#34;)))))    Key 効果     SPC 確認なしで検索   RET どの範囲の情報で検索するか自動判定して検索   w 近くの単語で検索   l その行の内容で検索。エラーの検索とかに良いかも   s シンボルで検索。使うのは Emacs Lisp の関数調べる時ぐらいか?</description>
    </item>
    
    <item>
      <title>google-this</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/google-this/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/google-this/</guid>
      <description>概要 google-this は Google 検索を Emacs の中から行えるやつ。
インストール いつも通り el-get でインストール
(el-get-bundle google-this) で、本来の使い方だとこのあとに
(google-this-mode 1) とやって有効化することになるがそれをしても google-this のデフォルトキーバインドが設定されるぐらいで自分はそのデフォルトキーバインドを使う気がないので有効化はしてない。
キーバインド キーバインドは Hydra で設定しているが、 google-translate と統合したので キーバインド &amp;gt; Google 連携 に記載している。</description>
    </item>
    
    <item>
      <title>google-translate</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/google-translate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/google-translate/</guid>
      <description>概要 google-translate は Google 翻訳する機能を提供するパッケージ。
インストール いつも通り el-get でインストール
(el-get-bundle google-translate) 関数のオーバーライド どうも最新版でも壊れっぱなしのようなので https://github.com/atykhonov/google-translate/issues/52#issuecomment-727920888 にあるように関数を上書きしている。
(with-eval-after-load &amp;#39;google-translate-tk (defun google-translate--search-tkk () &amp;#34;Search TKK.&amp;#34; (list 430675 2721866130))) google-translate-tk に定義されていて、それが読まれた後に上書きしないといけないので with-eval-after-load を使っている。
default-ui の読み込み Google Translate は UI を defauult と smooth のどちらかから選べるようになっている。
default だと
 google-translate-default-source-language google-translate-default-target-language  を設定しておいて
 M-x google-translate-at-point source → target の翻訳 M-x google-translate-at-point-reverse target → source の翻訳  という使い方をする。
smooth だと翻訳の source, target を複数設定して多言語対応ができるが、英語以外を翻訳することがないので smooth でなくていいかという感じで default を採用している。</description>
    </item>
    
    <item>
      <title>helm</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/helm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/helm/</guid>
      <description>概要 helm は anything.el の後継であり、インクリメンタルに候補の絞り込みをしたりする UI を提供する便利なパッケージ。
peco とか fzf とかと似ているっちゃ似ているかな? fzf 使ったことないけど。
一時期開発が止まってるようだったけど最近(2021年)はまた更新が活発になっている。
ただ、麦汁さんは ivy に乗り換えようとしているので helm の設定は頑張っていない。 helm-for-files が便利なのでまだ捨てられてないけど……。
インストール helm で使いたい拡張として helm-descbinds と helm-ag というのがあるのでそれらも同時に入れている。
(el-get-bundle helm) (el-get-bundle helm-descbinds) (el-get-bundle helm-ag) ただ descbinds は counsel-descbinds に置き換えたし helm-ag ももう使ってない気がする
設定 オススメの設定が helm に同梱されている helm-config に入ってるのでまずはそれを読み込んでいる。
(require &amp;#39;helm-config) また helm-descbinds を使えるように有効にしている。けど、上にも書いたけどもう counsel-descbinds に置き換えちゃったのよね……。
(helm-descbinds-mode) あとは helm-migemo-mode というのを有効にしている。これがあると helm で検索する時に migemo れて便利。
(helm-migemo-mode 1) ivy の方でも migemo 対応したいけどまだできてない……。
その他 helm 系の設定は他の設定にも色々影響も大きそうなので読み込み順は結構早いタイミングにしている(init-loader で 20 を prefix にしている)</description>
    </item>
    
    <item>
      <title>helm-posframe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/helm-posframe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/helm-posframe/</guid>
      <description>概要 helm-posframe は helm の拡張で Helm のバッファの表示を posframe を使うようにしてくれるやつ。
実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなのでいずれ外すかもしれない。
ただ確か本体の方の挙動が気に入らなかったような気はする。
インストール いつも通り el-get でインストール。 GitHub にあるのでそれを取得するようにしている。
(el-get-bundle tumashu/helm-posframe) 有効化 (helm-posframe-enable) </description>
    </item>
    
    <item>
      <title>highlight-indent-guides</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/</guid>
      <description>概要 highlight-indent-guides はインデント毎にラインを引いたりして見易くしてくれるパッケージ。通常のプログラムを書く時にも便利だけど、 YAML などのインデントがそのまま構造になるような言語を弄る時にとても便利。
インストール これもいつも通り el-get でインストールしている。また GitHub にあるので、そこから直接インストールしている。
(el-get-bundle DarthFennec/highlight-indent-guides) 設定 今いる行がどのインデントにいるのかをわかりやすくするために responsive モードを有効にしている。
(setq highlight-indent-guides-responsive &amp;#34;stack&amp;#34;) defcustom で定義されてる変数なので custom-set-variables で設定した方がいいかもしれない。</description>
    </item>
    
    <item>
      <title>hydra</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/hydra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/hydra/</guid>
      <description>概要 Hydra は Emacs の貴重なキーバインドを節約できる便利なパッケージ。
自分で定義した各 Hydra コマンドを実行するとそれに紐付くサブコマンドとそれらのキーバインド一覧を表示させることができるというやつ。
インストール Hydra 本体と関連パッケージをここでインスコしている
Hydra 本体のインストール Hydra 本体は el-get で普通に入れている
(el-get-bundle hydra) hydra-posframe のインストール Hydra は通常だと minibuffer あたりに表示されるけど画面の真ん中に表示される方が視線移動が少なくて便利なので hydra-posframe を使って画面中央に表示されるようにしている。
インストールはいつも通り el-get で行っている。
(el-get-bundle hydra-posframe) そして Emacs の初期化処理が完了したタイミングでそれが使われるように after-init-hook で hydra-posframe を有効化している
(add-hook &amp;#39;after-init-hook &amp;#39;hydra-posframe-enable) major-mode-hydra のインストール 自分以外で使っている人を見たことはないけど麦汁さんは major-mode-hydra というものを利用している。
これは major mode 用に簡単に Hydra の設定ができるというやつ。なので emacs-lisp-mode 用の Hydra とか js2-mode 用の Hydra などを定義できて便利。
どちらの場合も M-x major-mode-hydra で起動するので迷わないで済むのも良い。
内部では同じリポジトリにある pretty-hydra というのを利用していてそいつが UI の定義をせずともそれなりの感じに Hydra のメニューを構築してくれるようになっている。これもズボラな麦汁さんは気に入っている。導入していても表示にこだわりたい場合は直接 defhydra したらいいだけだしね。</description>
    </item>
    
    <item>
      <title>ido-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/ido-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/ido-mode/</guid>
      <description>概要 Emacs に標準添付の補完インターフェース。 ivy 使ってるからこれ有効化している意味がない気はする。
拡張入れてない段階でもこいつを有効にしていると find-file とかが楽になって良い。
有効化 とりあえず昔からずっと有効化している
(ido-mode 1) 設定 ファイル名の補完とかを曖昧一致を有効にするっぽいい。
(setq ido-enable-flex-matching t) その他 https://qiita.com/tadsan/items/33ebb8db2271897a462b に書いていることだけど
 ido-everywhere を有効にするとファイル名とバッファ切替以外にも使えるようになるらしい smex 入れると M-x が強化される ido-ubiquitous を入れると ido-everywhere よりもさらに色々な他に使えるらしい ido-vertical-mode を入れたら候補が縦並びになって便利っぽい  </description>
    </item>
    
    <item>
      <title>key-chord</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/key-chord/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/key-chord/</guid>
      <description>概要 key-chord はキーを同時に押した時にコマンドを発動させるということができるようにしてくれるパッケージ。
なのですが本家の方だと誤爆が多いということなのでそれを改善した zk-phi/key-chord の方を利用している。
まあほとんど使えてないので改良版の恩恵をまだ受けてないけど……。
インストール いつも通り el-get でインストールしている。本家の方じゃないので GitHub のリポジトリから突っ込んでいる。
(el-get-bundle zk-phi/key-chord) 設定 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。
(setq key-chord-two-keys-delay 0.15 key-chord-safety-interval-backward 0.1 key-chord-safety-interval-forward 0.15) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。
改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動に使っている上に Hydra で叩けるやつでよく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。
有効化 設定を入れた後は有効にするだけである。
(key-chord-mode 1) 実際のキーバインド設定は各モードだったりグローバルキーバインドを設定しているファイルだったりで書く感じ。
といいつつ現状では Hydra 起動のやつしか使ってないので、グローバルキーバインド設定でしか書いてない。
その他 sticky-control も control 限定で似たようなことをしているので key-chord に全部置き換えできるかもしれない。</description>
    </item>
    
    <item>
      <title>load-path</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/load-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/load-path/</guid>
      <description>概要 load-path は Emacs の設定でも重要な項目でこのリストに追加されている path は load または require する際に走査される path となっている。
即ち load-path を通しておけば、そこに置いている emacs lisp のファイルは簡単に読み出せるようになる。
なお package-install や el-get を使っておけば基本的に自分で load-path を通す必要はない。
秘匿情報を入れてるフォルダを読み込み可能にする パスワードなどの秘匿情報を持っている部分は ~/.emacs.d/secret というフォルダで管理している。そのためここに入ってる emacs lisp のファイルも読み込めるように load-path に追加している。
(add-to-list &amp;#39;load-path (expand-file-name &amp;#34;~/.emacs.d/secret&amp;#34;)) my/load-config ~/.emacs.d/secret は個人マシンか会社マシンかによって置いてるデータが異なったりするためもしもファイルがなくてもエラーにならないような方法で load する方法が必要だった。
というわけでファイルがなかったら読み込まずにメッセージを出力して終了するような関数を用意している。
(defun my/load-config (file) (condition-case nil (load file) (file-missing (message &amp;#34;Load error: %s&amp;#34; file)))) ただ、これって結局
(load file nil t) で十分な気もするので、置き換えを検討した方が良さそう。</description>
    </item>
    
    <item>
      <title>magit</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/magit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/magit/</guid>
      <description>概要 magit は Emacs の上で Git の色々な操作ができるやつ。結構使いやすいのでオススメなやつ。
forge を使うと GitHub や GitLab とも連携できてさらに便利、なはず。
インストール (el-get-bundle magit) 使い方 Git 管理されてるファイルを開いている時に M-x magit とかすると Git 管理用のバッファが出て来るしそこで ? を叩いたらどういうコマンドが使えるのか教えてくれるよ(雑)</description>
    </item>
    
    <item>
      <title>markdown</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/markdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/markdown/</guid>
      <description>概要 Markdown を書くための設定。といいつつ markdown-mode を入れてるだけだけども。
手元でテキストドキュメントを弄るのは org-mode が多いからなあ……
インストール いつも通り el-get で入れている。
(el-get-bundle markdown-mode) </description>
    </item>
    
    <item>
      <title>multiple-cursors</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/multiple-cursors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/multiple-cursors/</guid>
      <description>概要 multiple-cursors はカーソルを増やせるやつ。複数箇所を同時に編集できるようになって便利。
インストール el-get からインストールしている
(el-get-bundle multiple-cursors) キーバインド キーバインドは別途定義している。もうちょっと真面目に定義したい</description>
    </item>
    
    <item>
      <title>Neotree</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/neotree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/neotree/</guid>
      <description>概要 Neotree は Emacs でフォルダのツリー表示ができるやつ。メンテは活発じゃないようなので、その内乗り換えたい。
レシピ Neotree でメンテされているのは dev ブランチだけど el-get の公式のレシピでは master ブランチを見ているので自前で recipe を用意してそれを使っている。
(:name emacs-neotree-dev :website &amp;#34;https://github.com/jaypei/emacs-neotree&amp;#34; :description &amp;#34;An Emacs tree plugin like NerdTree for Vim.&amp;#34; :type github :branch &amp;#34;dev&amp;#34; :pkgname &amp;#34;jaypei/emacs-neotree&amp;#34;) インストール 上に書いたレシピを使ってインストールしている。
(el-get-bundle emacs-neotree-dev) 使わなくなったコード 元々設定していたが、 counsel-projectile を使ってると projectile-switch-project-action を設定していても反映されず意味がないのに気付いたので使わなくなった
https://github.com/mugijiru/.emacs.d/pull/183/files#r541843206
(setq projectile-switch-project-action &amp;#39;neotree-projectile-action) テーマの設定 GUI で起動している時はアイコン表示しそうでない場合は ▾ とかで表示する
(setq neo-theme (if (display-graphic-p) &amp;#39;icons &amp;#39;arrow)) のだけど、実際に今使ってるやつだともっとグラフィカルな表示なので all-the-icons の設定で上書きしている気がするので要確認
major-mode-hydra いちいちキーバインドを覚えてられないので major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。
とはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。</description>
    </item>
    
    <item>
      <title>notify-slack</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/notify-slack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/notify-slack/</guid>
      <description>概要 Emacs から Slack に通知するための自作関数。実体は同じく自作の外部コマンドを叩いているだけである。
何に使ってるかというと org-clock-in, org-clock-out の時に作業の開始と終了を分報チャンネルに投稿しているだけである。作業の可視化である。
実装 送信するコマンド start-process を使って外部コマンドを叩いている。
(defun my/notify-slack (channel text) (if my/notify-slack-enable-p (start-process &amp;#34;my/org-clock-slack-notifier&amp;#34; &amp;#34;*my/org-clock-slack-notifier*&amp;#34; &amp;#34;my-slack-notifier&amp;#34; channel text))) my/notify-slack-enable-p という変数が nil だと大分コマンドが実行されないようになっている。
Slack 連携を Toggle するコマンド 連携したい時としたくない時があるので送信したりしなかったりを切り替えられるコマンドを用意している。
中身は何をしているかというと上に書いた my/notify-slack-enable-p という変数を切り替えているだけ。
(defun my/notify-slack-toggle () (interactive) (if my/notify-slack-enable-p (setq my/notify-slack-enable-p nil) (setq my/notify-slack-enable-p t))) 分報チャンネル投稿関数 「分報チャンネル投稿関数」としているけどデフォルト投稿先に投稿するための関数というような扱いの関数。
単純に前出の my/notify-slack 関数の第一引数に my/notify-slack-times-channel という変数を設定してそのチャンネルに向けて投稿するだけ。
(defun my/notify-slack-times (text) (my/notify-slack my/notify-slack-times-channel text)) 設定 あまり見せたくない設定ファイルを別ファイルに分離しているのでそれを読み出している。
内部では my/notify-slack-times-channel という変数を設定しているだけじゃないだろうか。職場の Slack のチャンネルを指定しているので隠したいという意図があった。
そのうち .</description>
    </item>
    
    <item>
      <title>plantuml-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/plantuml-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/plantuml-mode/</guid>
      <description>概要 plantuml-mode は PlantUML という、テキストだけで UML 図などが描けるツール用のモード。
インストール いつも通り el-get で入れてる
(el-get-bundle plantuml-mode) 設定 実行モードは &#39;jar を指定している。デフォルトは &#39;server なんだけどオフラインの時も使いたいししね。
(setq plantuml-default-exec-mode &amp;#39;jar) el-get でインスコすると jar ファイルも自動で拾って来て plantuml-mode と同じディレクトリに設置して plantuml-jar-path も通してくれるからそっち使う方が便利だしね。
その他 最新の develop ブランチだとインデントを調整できる機能が入っているので乗り換えたいけどそのためには el-get のレシピを書いてあげる必要がありそうで放置している。</description>
    </item>
    
    <item>
      <title>posframe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/posframe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/posframe/</guid>
      <description>概要 posframe は child frame を表示させるためのパッケージ。 Emacs のど真ん中に表示したり、今あるカーソル位置のすぐそばに出したりできる。
ivy なんかを使う時に ivy-posframe ど真ん中に出すと、いつもそこに表示されるし真ん中なの視線移動が少なくて済むし ddskk-posframe なんかで変換候補をカーソル位置のそばに出て来るので一般的な日本語変換ソフトと同様にこれまた視線移動が少なくて便利。
という感じで色々なものの拡張として使わているやつ。
インストール いつも通り el-get で入れているだけ。
(el-get-bundle posframe) こいつ自体には特に設定を入れてない。というか設定項目自体2個しか存在していない。
ま、こいつ単体で使うものでもないしね。</description>
    </item>
    
    <item>
      <title>projectile</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/projectile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/projectile/</guid>
      <description>概要 projectile はプロジェクト内のファイルを検索したりするのに便利なパッケージ
インストール いつも通り el-get からインストールする
(el-get-bundle projectile) helm との連携 helm-projectile を使って helm と連携できるようにしている。けど ivy に乗り換えを進めているので多分これ使ってないんだよな……。というわけでこの設定は消す候補に入っている。
(el-get-bundle helm-projectile) (helm-projectile-on) 有効化 このあたりで有効化しておいている。この順序に意味があったかは忘れた……。
(projectile-mode) 無視リスト 普段 Rails ばっかりやってるのでそれ関係のものを無視リストに入れている。けどあんまりメンテしてない。
無視するディレクトリ (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;tmp&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;.tmp&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;vendor&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;.sass-cache&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;coverage&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;cache&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;log&amp;#34;) node_modules もここに突っ込んでも良いかもしれない。
無視するファイル (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;gems.tags&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;project.tags&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;manifest.json&amp;#34;) tags ファイルは昔は使っていたけど、最近は dumb-jump が優秀なのと、面倒で使ってないのでそろそろ gems.tags と project.tags は不要かもしれない。
ivy/counsel との連携 上の方で helm との連携処理を入れていたが今は大体 ivy に乗り換えているので ivy 連携もしている。</description>
    </item>
    
    <item>
      <title>rails</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/rails/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/rails/</guid>
      <description>概要 Rails 開発関係だけど Ruby 開発とはちょっと違う設定をここに書いている。
関連パッケージのインストール テンプレートエンジンには haml を使っているので haml-mode を入れていてファイルナビゲーションには projectile の拡張である projectile-rails を利用している。
(el-get-bundle haml-mode) (el-get-bundle projectile-rails) (projectile-rails-global-mode 1) projectile-rails 用のコマンド追加 自身のプロジェクトだと少しナビゲーション用のコマンドが不足していたので projectile-rails の実装を参考にコマンドを追加している
Uploader Finder app/uploaders に格納している upload に関連するファイルを検索するコマンド
(defun my/projectile-rails-find-uploader () &amp;#34;Find a Uploader.&amp;#34; (interactive) (projectile-rails-find-resource &amp;#34;uploader: &amp;#34; &amp;#39;((&amp;#34;app/uploaders/&amp;#34; &amp;#34;\\(.+\\)\\.rb$&amp;#34;)) &amp;#34;app/uploaders/${filename}.rb&amp;#34;)) Admin Finder Active Admin 用のファイルを検索するためのコマンド
(defun my/projectile-rails-find-admin () &amp;#34;Find a ActiveAdmin file.&amp;#34; (interactive) (projectile-rails-find-resource &amp;#34;admin: &amp;#34; &amp;#39;((&amp;#34;app/admin/&amp;#34; &amp;#34;\\(.+\\)\\.rb$&amp;#34;)) &amp;#34;app/admin/${filename}.rb&amp;#34;)) Form Object Finder Form Object を探すためのコマンド</description>
    </item>
    
    <item>
      <title>rspec-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/rspec-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/rspec-mode/</guid>
      <description>概要 rspec-mode は Emacs で RSpec を実行したりする時に便利なパッケージ。といいつつ麦汁さんはちゃんと使いこなしていない……
インストール (el-get-bundle rspec-mode) 有効化 rspec 実行バッファで byebug などで止まった際に C-x C-q したら inf-ruby が動くようにしている。
(add-hook &amp;#39;after-init-hook &amp;#39;inf-ruby-switch-setup) binding.pry は何故かまともに動かないので byebug か binding.irb 推奨。麦汁さんはいつも debugger とコードに入れて使っている。
キーバインド C-c C-c で開いている rspec ファイルのカーソルがある行のテストを実行できるようにしている。
(define-key rspec-mode-map (kbd &amp;#34;C-c C-c&amp;#34;) &amp;#39;rspec-verify-single) 他にも色々な機能があるのだけどキーバインド未設定なのでこれだけしか使ってない。</description>
    </item>
    
    <item>
      <title>ruby</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/ruby/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/ruby/</guid>
      <description>概要 Ruby のコードを編集する上での設定をここには書いている。別の箇所で rspec-mode などの設定も書いているのでいつか記述場所を統合した方が良さそうな気もする
rbenv.el Ruby のバージョンを切り替えられる rbenv を使ってるので Emacs 上でもそれが使えるように rbenv.el を導入している。
インストール インストールはいつも通り el-get でやっている
(el-get-bundle rbenv) 有効化 そして global に有効化している。というか global じゃない有効化ってあるのかなってのと、あるとしても意味があるのかな的な。
(global-rbenv-mode) enh-ruby-mode メジャーモードは enhanced-ruby-mode を利用している。が、最近は ruby-mode の方がやっぱり良いみたいな話もどこかで見た気がするので戻ってみるのも手かもしれないと思っている。
インストール いつも通り el-get で入れている。
(el-get-bundle enh-ruby-mode) カスタム設定 enh-ruby-mode が読み込まれた後に setq で以下のように設定されている
(with-eval-after-load &amp;#39;enh-ruby-mode (setq enh-ruby-add-encoding-comment-on-save nil) (setq enh-ruby-deep-indent-paren nil) (setq enh-ruby-bounce-deep-indent t)) encoding のマジックコメントが入らないようにする enh-ruby-add-encoding-comment-on-save を nil にすることで encoding 設定のマジックコメントが入らないようにしている。
これは昔は有効にしておいた方が良かったけど最近の Ruby では設定しなくても UTF-8 が前提になるからむしろ無い方が良いというお話だったはず。
そういう状況に変わったのも大分前なので詳細は忘れた。
ただとりあえず 最新の enhanced-ruby-mode を見るとデフォルトが nil なのでわざわざ設定しなくて良さそう。</description>
    </item>
    
    <item>
      <title>savehist</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/savehist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/savehist/</guid>
      <description>概要 Emacs 標準でついている、ミニバッファの履歴などを保存してくれる機能。
有効化 標準でついているので以下のようにするだけで有効化可能。
(savehist-mode 1) 設定 標準で保存されるもの以外だと kill-ring だけを保存対象にしている。これで Emacs を終了させても kill-ring は残るようになるはず。だけど最近使えてない気がするな……。検証が必要そう。
(setq savehist-additional-variables &amp;#39;(kill-ring)) 他にも有効にしたら便利そうなのがあれば追加したい。が、ぱっとは思い付かない。</description>
    </item>
    
    <item>
      <title>scss</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/scss/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/scss/</guid>
      <description>概要 scss を使う上での設定をここではまとめている。長いこと手を入れてないので今はより良い設定がありそうな気がする。
rainbow-mode rainbow-mode はカラーコードを入力した際に、そのカラーコード部分の背景色をカラーコードの色に変化させるパッケージ。ぱっと見で大体どんな色かわかって便利なやつ
インストール 自分はel-get で入れている。
(el-get-bundle rainbow-mode) ELPA に登録されているので package-install でもいける
scss-mode scss-mode は Emacs 組込みの css-mode の中で定義されているメジャーモード。なのでインストール不要で使えるし .scss という拡張子なら自動的に scss-mode で開いてくれるようになっている。
設定 インデントはデフォルトだと半角空白 4 つとなっているが麦汁さん的には 2 の方が良いのでそのように変更している。
(with-eval-after-load &amp;#39;scss-mode (setq css-indent-offset 2)) with-eval-after-load を使っているが css-indent-offset は defcustom で定義されているので custom-set-variables を使うように修正した方が良さそう
hook scss を使う上で hook を使って色々有効化したりしている。
(defun my/scss-mode-hook () (flycheck-mode 1) (setq-local lsp-prefer-flymake nil) (lsp) (lsp-ui-mode -1) ;; lsp-ui とかより後に設定しないと上書きされるのでここに移動した (setq-local flycheck-checker &amp;#39;scss-stylelint) (setq-local flycheck-check-syntax-automatically &amp;#39;(save new-line idle-change)) (company-mode 1) (display-line-numbers-mode 1) (rainbow-mode)) (add-hook &amp;#39;scss-mode-hook &amp;#39;my/scss-mode-hook)  flycheck-mode の有効化  これによりリアルタイムに lint 結果が分かって便利になる   lsp-prefer-flymake の無効化  flycheck が有効にならない問題を防いでいる。どうも自分の設定の書き方が悪い気もするが……。   lsp-mode を有効化しつつ lsp-ui は無効にしている  lsp-ui が有効だと画面上でガチャガチャ height とかのプロパティの説明をしてうざいので   flycheck-checker, flycheck-check-syntax-automatically の設定  lsp-ui とかより後に設定しないと上書きされるので、それらより後に設定している 設定の書き方の悪さのせいな気もする   company-mode の有効化。これがないと補完できなくて厳しいよね display-line-numbers-mode の有効化。行数表示も欲しいよね。巨大ファイルだと邪魔だけど巨大にしなきゃいい rainbow-mode の有効化  キーバインド 設定しているけど使ってないなあ……。</description>
    </item>
    
    <item>
      <title>server</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/server/</guid>
      <description>概要 Emacs の起動後にサーバとして動くようにしている。
これにより emacsclient コマンドで接続するとサーバとして動いている Emacs に別端末から繋げられたりする。
けど麦汁さんは Firefox から org-capture を動かすためにだけ利用している。
設定 server.el を require しておいてサーバとして動いていなかったらサーバとして動くようにしている。多重起動の防止ですね。
(require &amp;#39;server) (unless (server-running-p) (server-start)) 関連ツール  org-capture-extension org-capture 連携するための Chrome 及び Firefox の拡張。麦汁さんはこれを Firefox で使ってる。 org-protocol-capture-html HTML コンテンツを org-mode の記述に変換して capture してくれるやつ。Pandoc 利用。  その他 起動処理の最後に動けばいいので init-loader で 99 を割り振っている。
init-loader をやめるなら多分 after-init-hook を使うことになるのかな。</description>
    </item>
    
    <item>
      <title>show-paren-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/show-paren-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/show-paren-mode/</guid>
      <description>概要 show-paren-mode は Emacs に標準で入っているやつで開き括弧と閉じ括弧の対応を示してくれたり括弧の中身を強調表示したりする機能を提供してくれるやつ。
有効化 デフォで入ってるので以下のようにするだけで有効化される。
(show-paren-mode 1) デフォ設定だと対応する括弧を強調表示するだけだけどまあそれで悪くないと思ってるので今のところデフォルト設定のままである。
その他 http://syohex.hatenablog.com/entry/20110331/1301584188
の記事へのリンクを設定ファイルの中に残していたけど設定は特に弄ってないのでまたその記事読んだりで設定弄ってみてもいいかもしれない。
また smartparens.el にも似た機能はあるようだけど Emacs 標準機能の方が軽そうなのでとりあえずこのままにするつもり。</description>
    </item>
    
    <item>
      <title>smartparens</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/smartparens/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/smartparens/</guid>
      <description>概要 smartparens はカッコとかクォートとかのペアになるようなものの入力補助をしてくれるやつ。
strict モードだとペアが崩れないように強制するので雑に C-k で行削除しててもペアが維持されて便利。
インストール いつも透り el-get で導入している
(el-get-bundle smartparens) 設定 実は導入して間もないので、提供されてるオススメ設定のみ突っ込んでいる。オススメ設定は別途 reqiure したら良いという作りなので、以下のようにして突っ込んでいる。
(require &amp;#39;smartparens-config) その他 各言語の hook で smartparens-strict-mode を有効にしている。なんか常に有効だと困りそうな気がしたので。</description>
    </item>
    
    <item>
      <title>sticky-control</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/</guid>
      <description>概要 指定したキーを2回叩いたら Control が押されてるような状態にしてくれるプラグイン。
その2回の間隔はデフォルトだと 0.5 秒以内となっている。そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる
さらに sticky-control-shortcuts に指定されてる一部のキーについては sticky 用のキーを押した直後に shortcuts のキーを押すと Control を押している状態でそのキーを押したことになる。
例えば私は , を sticky 用のキーにしていて shortcuts に c を入れているので ,c と素早くタイプをすればそれだけで C-c が押された状態になる。
インストール まずは el-get-bundle でインストール。
(el-get-bundle sticky-control) ちなみにレシピは公式ではなかったのでとりあえず自分の環境で使えるように自作レシピを置いている。
(:name sticky-control :description &amp;#34;save your left little finger&amp;#34; :type http :url &amp;#34;https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el&amp;#34; :features &amp;#34;sticky-control&amp;#34;) 元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど最近そこからは取得できなくなったので https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el から取得して利用している
設定 まずは「2回叩いたら Control を押している状態になる」キーを指定する。
(sticky-control-set-key &amp;#39;sticky-control-key ?,) 私は , を sticky-control のキーにしているのでこの指定。
そして次に sticky-control-shortuts の指定。ここに指定しておくと、例えば ,c と素早くタイプすることで C-c が入力された状態とすることができる。</description>
    </item>
    
    <item>
      <title>toolbar</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/toolbar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/toolbar/</guid>
      <description>概要 Emacs 標準の toolbar の設定。麦汁さんは使わないし幅を取るので隠す派。
設定 単に無効にして隠している
(tool-bar-mode -1) </description>
    </item>
    
    <item>
      <title>undo-fu</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/undo-fu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/undo-fu/</guid>
      <description>概要 undo-fu はシンプルな undo/redo 機能を提供してくれるやつ。
昔はもっと色々できる undo-tree を使っていたけどそっちにバグがあるっぽいので乗り換えた。
インストール (el-get-bundle undo-fu) キーバインド 別の場所で定義しているけど、以下のキーバインドにしている。
   Key 効果     C-/ undo   C-M-/ redo    </description>
    </item>
    
    <item>
      <title>uniquify</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/uniquify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/uniquify/</guid>
      <description>概要 同じ名前のファイルを開いている時に祖先のディレクトリ名を表示してくれてどこのファイルかわかりやすくしてくれるやつ。
すぐ親とかも同名でも、名前が違うところまで遡って表示してくれる。
有効化 Emacs に標準で入ってるので require するだけで有効にできる
(require &amp;#39;uniquify) 設定 自分は ファイル名&amp;lt;フォルダ名&amp;gt; みたいな表示になる形式にしている。その方がファイル名が主という感じになって使いやすそうだなって。
そういう意味では post-foward の方が幅を使わない分良いかもしれない。いつか検討しても良いかもしれない。
(setq uniquify-buffer-name-style &amp;#39;post-forward-angle-brackets) </description>
    </item>
    
    <item>
      <title>Vue.js</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/vue-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/vue-js/</guid>
      <description>概要 ここでは Vue.js アプリケーションを書く上での設定を書いている。
auto-insert の設定 Vue.js のコンポーネントファイルを新規作成する時にテンプレートが自動挿入できるようにしている
テンプレート Vue.js の単一ファイルコンポーネントなので template, script, style を出力している。
template には pug を、CSS には scss を使っている。
&amp;lt;template lang=&amp;#39;pug&amp;#39;&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { }; &amp;lt;/script&amp;gt; &amp;lt;style lang=&amp;#39;scss&amp;#39; scoped&amp;gt; &amp;lt;/style&amp;gt; テンプレートを適用可能にする .vue という拡張子のファイルを新規作成する時には上で定義したテンプレートが自動的に挿入されるようにする。
(define-auto-insert &amp;#34;\\.vue$&amp;#34; &amp;#34;template.vue&amp;#34;) パッケージのインストール ここでは Vue.js 開発に使っている関連パッケージを入れている。
vue-mode vue-mode は mmm-mode をベースにして作られた Vue.js の単一ファイルコンポーネント用のモード。 mmm-mode ベースなので template, script, css 部分でそれぞれ別のメジャーモードが動くようになっている。
インストール いつも透り el-get で入れている
(el-get-bundle vue-mode) 備考 あまり更新は活発でなく微妙な挙動もあるので mmm-mode に乗り換えたり web-mode を使うようにしている人も多い様子。</description>
    </item>
    
    <item>
      <title>wakatime-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/wakatime-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/wakatime-mode/</guid>
      <description>概要 wakatime-mode は WakaTime というサービスと連携するためのパッケージ。
WakaTime は自分がどのプロジェクトの作業をしているかを計測してくれるようなツール。普段の行動の改善に使えるかもしれないので、なんとなく連携してみている。
インストール いつも通り el-get から入れている
(el-get-bundle wakatime-mode) APIキーの設定 APIキーは .authinfo.gpg に保存しているのでそこから引っ張り出している。
(custom-set-variables &amp;#39;(wakatime-api-key (funcall (plist-get (nth 0 (auth-source-search :host &amp;#34;wakatime.com&amp;#34; :max 1)) :secret)))) 有効化 Emacs を使っている間は常に有効になっていて欲しいので global-wakatime-mode を有効にしている。
(global-wakatime-mode 1) APIキーが取れてない時はやたらエラーを吐くので何かしら調整はしてもいいかもしれない。
(if (boundp &amp;#39;wakatime-api-key) (global-wakatime-mode 1)) みたいにして API キーが取れている時だけ有効にするとかね。</description>
    </item>
    
    <item>
      <title>yaml-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/yaml-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/yaml-mode/</guid>
      <description>概要 yaml-mode は yaml を編集する時のメジャーモード。インデントを調整しやすい。
インストール いつも通り el-get でインストール
(el-get-bundle yaml-mode) hook mode に対する hook は関数を定義してその中で呼びたいコードを書いていくようにしている。
lambda で書いてしまうと hook を弄りたい時に結構面倒なのだけど関数を定義しておくと、その関数の中身を変更して評価しておくだけで hook で動作する中身が変更できて便利。
とりあえず yaml-mode では以下のようにして highlight-indent-guides を有効にしている。
(defun my/yaml-mode-hook () (highlight-indent-guides-mode 1)) で、その hook を最後に yaml-mode-hook に追加している。
(add-hook &amp;#39;yaml-mode-hook &amp;#39;my/yaml-mode-hook) </description>
    </item>
    
    <item>
      <title>yascroll</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/yascroll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/yascroll/</guid>
      <description>概要 yascroll は標準のスクロールバーとは異なるスクロールバーを表示するやつ。
デフォルトだと右側の fringe 領域に表示するのであまり邪魔にならないし表示領域を必要以上に狭めないので気に入っている。
最初に作られたっぽい記事は 主張しないスクロールバーモード、yascroll.elをリリースしました - Functional Emacser にある。タイトル通り、あまり主張しない感じで良い。
インストール いつも通り el-get でインストールしている
(el-get-bundle yascroll) これだけで大体いい感じに表示されるので便利。たまに表示されなくなることもあるが、まあそこまで重要なやつでもないのであまり気にしていない</description>
    </item>
    
    <item>
      <title>yasnippet</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/yasnippet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/yasnippet/</guid>
      <description>概要 yasnippet はテンプレートを挿入する機能を持ったパッケージ。 Emacs でそこそこ何かを書いている人なら大体知ってるような有名なやつだと思う。
インストール いつも通り el-get でインストール
(el-get-bundle yasnippet) 有効化 どこでも使いたいぐらい便利なやつなので global に有効化している
(yas-global-mode 1) キーバインド 基本的に覚えられないので Hydra を使って定義している
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define yasnippet-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;Yasnippet&amp;#34; :foreign-key warn :quit-key &amp;#34;q&amp;#34; :exit t) (&amp;#34;Edit&amp;#34; ((&amp;#34;n&amp;#34; yas-new-snippet &amp;#34;New&amp;#34;) (&amp;#34;v&amp;#34; yas-visit-snippet-file &amp;#34;Visit&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;i&amp;#34; yas-insert-snippet &amp;#34;Insert&amp;#34;) (&amp;#34;l&amp;#34; yas-describe-tables &amp;#34;List&amp;#34;) (&amp;#34;r&amp;#34; yas-reload-all &amp;#34;Reload all&amp;#34;)))))    Key 効果     n 現在のメジャーモード用に新しい snippet を作る   v 現在のメジャーモードの登録済 snippet ファイルを開く   i snippet の挿入。選択は ivy で行われる。   l 現在のメジャーモードの登録済 snippet の一覧表示   r snippet を全部 load し直す    その他 実は、どういう snippet があれば便利なのかよくわかってなくて snippet をほとんど登録してない。</description>
    </item>
    
    <item>
      <title>zoom</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/zoom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/zoom/</guid>
      <description>概要 zoom はフォーカスが当たっている Window が大きく表示されるようにするやつ。最近流行りのビデオチャットツールではない。
どこにフォーカスが当たっているかわかりやすくなるし、狭い画面でも見たい部分を広げて表示できるので便利。
インストール いつも通り el-get から入れる。 GitHub から直接取得するように設定している。
(el-get-bundle cyrus-and/zoom) 設定  起動時に有効化 1画面しか使えない時は必須なので 比率を黄金比に変更 この方が使いやすいっぽい。  という設定をしている。
(custom-set-variables &amp;#39;(zoom-mode t) &amp;#39;(zoom-size &amp;#39;(0.618 . 0.618))) </description>
    </item>
    
    <item>
      <title>zoom-window</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/zoom-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/zoom-window/</guid>
      <description>概要 zoom-window は tmux の prefix z のような動きをするやつ。表示している window をフレーム全体に広げたり戻したりすることができる。
インストール いつも通り el-get から入れている
(el-get-bundle zoom-window) その他 キーバインドは 80-global-keybinds に書いたけど C-x 1 に割り当てている。
ただそれだと tmux と使い勝手が違うなって感じているのでそのうち hydra の中の z にでもアサインしようかと思う。
あと、その window を最大化して戻すことよりも単に他の window が邪魔なことの方が多い気もしている。。。</description>
    </item>
    
    <item>
      <title>ガベージコレクション</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/gcmh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/gcmh/</guid>
      <description>概要 ガベージコレクションには gcmh というのを利用してみている。
https://github.com/emacsmirror/gcmh
普段は GC を控えめにしながら操作してない間に GC が走るような作りになっている。便利そう。
インストール (el-get-bundle gcmh) これだけで有効化もされる。
その他 以前の設定も折り畳んで残しておく
  使わなくなったコード  gcmh を入れる前に設定していたコード。 gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。
;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf ;; Increase threshold to fire garbage collection (setq gc-cons-threshold 1073741824) (setq garbage-collection-messages t) ;; Run GC every 60 seconds if emacs is idle. (run-with-idle-timer 60.0 t #&amp;#39;garbage-collect) 
 </description>
    </item>
    
  </channel>
</rss>
