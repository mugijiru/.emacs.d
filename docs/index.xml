<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>麦汁&#39;s Emacs Config</title>
    <link>https://mugijiru.github.io/.emacs.d/</link>
    <description>Recent content on 麦汁&#39;s Emacs Config</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language><atom:link href="https://mugijiru.github.io/.emacs.d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>with-simulated-input</title>
      <link>https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/</guid>
      <description>概要 with-simulated-input は入力処理をシミュレートするためのプラグイン。
公式のドキュメントにあるように
(with-simulated-input &amp;#34;hello SPC world RET&amp;#34; (read-string &amp;#34;Say hello to the world: &amp;#34;)) を評価すると read-string に対して「hello world」を入力したことになるので echo エリアに「hello world」と表示される。
これで何が嬉しいかというと Emacs Lisp でやっていることはインタラクティブな部分が大きいのでそういった要素をテストできるようになる。
具体的な使用例は test:my/org-todo で示す。
インストール el-get-bundle で GitHub からインストールしている
(el-get-bundle DarwinAwardWinner/with-simulated-input) </description>
    </item>
    
    <item>
      <title>実行方法</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/execution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/execution/</guid>
      <description>テストする時は以下のように叩いたら動く。
emacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el 今まで .emacs.d にいる状態でしか叩いたことないので他の場所にいる時に実行しても大丈夫かはわからない。
単体でテストしたい時は
-l ~/.emacs.d/inits/test/*-test.el の部分を書き換えたらいいんじゃないかな。やったことないけど。</description>
    </item>
    
    <item>
      <title>mocker.el</title>
      <link>https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/</guid>
      <description>概要 mocker.el は Emacs Lisp のテストで使う Mock ライブラリ。
使おうと思って導入したけど、自分のやりたいことはちょっと違ったので死蔵中
便利そうなのでとりあえず置いといている。
インストール el-get で GitHub から取得している。
(el-get-bundle sigma/mocker.el) </description>
    </item>
    
    <item>
      <title>run-tests</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/run-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/run-tests/</guid>
      <description>読み込んだテストをまるっとテストするためのコードをとりあえず置いている。
(if noninteractive (let ((ert-quiet t)) (ert-run-tests-batch-and-exit))) 後述の テストライブラリの読み込み などはここで担うべきかとも考えるが今はテストファイルが1つしかないので気にしないことにする。</description>
    </item>
    
    <item>
      <title>my-org-commands-test</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/</guid>
      <description>org-mode 用に定義したコマンドや関数のテストコード
Setup テストライブラリの読み込み 標準でついてくる ert を採用しているのでそれを読み込んでいる。
(require &amp;#39;ert) el-get の設定の読み込み プラグイン管理には el-get を利用しているのでその設定ファイルを読み込んでいる。
;; プラグイン読み込みの前準備 (load (expand-file-name (concat user-emacs-directory &amp;#34;/init-el-get.el&amp;#34;))) テスト補助のプラグイン読み込み with-simulated-input 上で説明しているが、入力をシミュレートするためのプラグインをテストで利用しているのでここで読み込んでいる。
;; 入力シミュレート用のプラグイン (load (expand-file-name (concat user-emacs-directory &amp;#34;/inits/99-with-simulated-input&amp;#34;))) 依存プラグインの読み込み テスト対象が依存しているプラグインを読み込んでいる。本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが現状だとその状態で GitHub Actions で動かせる方法がわからないので一旦個別に読み込むようにしている。
swiper ivy-read を使った機能のテストをするので読み込んでいる。
(el-get-bundle abo-abo/swiper) テスト対象の読み込み テストしたいファイルをここで読んでる。
;; テスト対象の読み込み (load (expand-file-name (concat user-emacs-directory &amp;#34;/inits/68-my-org-commands.el&amp;#34;))) ert-deftest test:my/org-todo-keyword-strings org-todo-keywords から &amp;ldquo;|&amp;rdquo; という区切りを除外したり &amp;ldquo;(s)&amp;rdquo; とかのような高速アクセスのためのキーワードは ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。
(ert-deftest test:my/org-todo-keyword-strings () &amp;#34;Test of `my/org-todo-keyword-strings&amp;#39;.&amp;#34; (let ((org-todo-keywords &amp;#39;((sequence &amp;#34;TODO&amp;#34; &amp;#34;DOING(!</description>
    </item>
    
    <item>
      <title>ace-window</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/ace-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/ace-window/</guid>
      <description>概要 Window 間の移動を ace-jump や avy のように表示されてる文字の Window に移動するやつ。
Window が2分割の時は文字も出ないで別の Window に移動してくれる。
C-x o にデフォルトで設定されている other-window は別の window に順番に移動するコマンドなので大量に分割していると移動がしんどいのだが ace-window を使うと起動して 1 ストロークで移動できるので C-x o をデフォルトの other-window から ace-window そのまま置き換えても便利に使える。
インストール いつも通り el-get でインストールしている。
(el-get-bundle ace-window) 設定 キーバインドは別の箇所で定義しているが C-x o で ace-window が起動するようにしている。
また Hydra からは ace-swap-window が起動できるようにしている。
ace-window には色々な機能があるからそれ用の Hydra を別途定義してもいいかもしれない。</description>
    </item>
    
    <item>
      <title>all-the-icons</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/all-the-icons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/all-the-icons/</guid>
      <description>概要 all-the-icons は Emacs で様々なアイコンを表示できるようにして華やかにしてくれるパッケージです。 Neotree などでも対応していてアイコンでファイルの種類が表示されるようになってモダンな雰囲気が出ます。
インストール いつも通り el-get-bundle で入れている。明示的に require している理由は忘れました。
(el-get-bundle all-the-icons) (require &amp;#39;all-the-icons) フォントのインストール 以下のコマンドを叩くことでフォントをインストールすることができる。 all-the-icons のインストール直後に叩いておいたら普段は叩かなくて良いはず。
(all-the-icons-install-fonts) all-the-icons の更新後は叩いた方がいいかもしれない
キーバインド キーバインドは覚えられないし、使えるキーも大分埋まってるので、 pretty-hydra を使って all-the-icons 用の Hydra を用意している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define all-the-icons-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;All the icons&amp;#34; :exit t :quit-key &amp;#34;q&amp;#34;) (&amp;#34;Insert&amp;#34; ((&amp;#34;a&amp;#34; all-the-icons-insert-alltheicon &amp;#34;All the icons&amp;#34;) (&amp;#34;f&amp;#34; all-the-icons-insert-fileicon &amp;#34;File icons&amp;#34;) (&amp;#34;F&amp;#34; all-the-icons-insert-faicons &amp;#34;FontAwesome&amp;#34;) (&amp;#34;m&amp;#34; all-the-icons-insert-material &amp;#34;Material&amp;#34;) (&amp;#34;o&amp;#34; all-the-icons-insert-octicon &amp;#34;Octicon&amp;#34;) (&amp;#34;w&amp;#34; all-the-icons-insert-wicon &amp;#34;Weather&amp;#34;) (&amp;#34;*&amp;#34; all-the-icons-insert &amp;#34;All&amp;#34;)))))    Key 効果     a all-the-icons で追加されてるアイコンを検索して挿入   f ファイルアイコンを検索して挿入   F FontAwesome アイコンを検索して挿入   m Material アイコンを検索して挿入   o Octicon のアイコンを検索して挿入   w 天気アイコンを検索して挿入   * 全てのアイコンを検索して挿入    フォントのインストールコマンドもここに収めてしまうのが良さそうな気がする</description>
    </item>
    
    <item>
      <title>auto-insert</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/auto-insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/auto-insert/</guid>
      <description>概要 auto-insert はファイルを新規作成した時にファイル名に応じたテンプレートを挿入する機能。
Emacs が標準で持ってるライブラリなのでインストールは不要
設定 Emacs の設定は .emacs.d の中に閉じ込めたいので auto-insert のテンプレートも ~/.emacs.d/insert に閉じ込める設定にしている。
(custom-set-variables &amp;#39;(auto-insert-directory &amp;#34;~/.emacs.d/insert/&amp;#34;)) 有効化 あとは単に有効化している。
(auto-insert-mode 1) 他の設定 ファイル名を正規表現でマッチさせてテンプレートが選択されるので各言語やフレームワーク毎に設定を入れることにしている。
実際は今のところ inits/41-vue.el でのみ追加設定を入れている。</description>
    </item>
    
    <item>
      <title>auto-save</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/auto-save/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/auto-save/</guid>
      <description>概要 編集中状態の自動保存や、編集前や保存直後の状態のバックアップに関する設定をここでは書いている。
Emacs ではデフォルトでも編集中ファイルの自動保存や、編集前の状態の自動バックアップもしてくれるが開いているファイルとは違う場所に保存したりすることで、より便利になるのでいくつかの設定を入れている。
設定 自動保存設定 デフォルトだと #hoge.txt# みたいなファイル名で作られる、自動保存に関する設定。
まあこの自動保存されてやつを活用できてる気がしないのでこの自動保存自体不要な気はしているが、とりあえず場所を移動して邪魔にはならないようにはしている。
自動保存のタイミング 自動保存のタイミングは
 auto-save-timeout auto-save-interval  で制御されている。
まず auto-save-timeout で設定した秒数が経過すると再度自動保存が実行される。
これがデフォルトだと 30 秒なのだが、ちょっと長いのでその半分の 15 秒で保存されるように設定を変更している。
(setq auto-save-timeout 15) また auto-save-interval で設定した回数のキーイベントが発生すると再度自動保存を実行する。
これもデフォルトだと 300 と結構なキーを叩く必要があるので 60 回としている。
(setq auto-save-interval 60) 自動保存先を変更する 自動保存はそのままだと弄ってるファイルの場所に作られる。が、これは以下のようにすると ~/.emacs.d/backup/ 一応変更可能。
(setq auto-save-file-name-transforms &amp;#39;((&amp;#34;.*&amp;#34; &amp;#34;~/.emacs.d/backup/&amp;#34; t))) ただ、デフォルト値が
((&amp;#34;\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\&amp;#39;&amp;#34; &amp;#34;/tmp/\\2&amp;#34; t)) なので .* にしているのは乱暴そうな気がしている。
というわけで https://masutaka.net/chalow/2014-05-11-1.html に書かれているのを真似して
((&amp;#34;~/\\([^/]*/\\)*\\([^/]*\\)$&amp;#34; &amp;#34;~/.emacs.d/backup/\\2&amp;#34; t)) とでもした方が良いかもしれない。
バックアップファイル 自動保存とは別に、ファイルを開いた時点のバージョンや保存した時点のバージョンを取っておいてくれる自動バックアップ機能もあるのでその設定も弄っている。
バックアップ先のフォルダ指定 デフォルトでは編集しているファイルと同じフォルダにバックアップファイルを作成するようになっている。
だけど、こいつが結構邪魔なのでバックアップファイルは ~/.emacs.d/backup/ に全部保存するようにしている。
また、普段 tramp は使っていないが何かの拍子で使った時にバックアップが取られると邪魔そうなのでそれは保存しないようにしている。</description>
    </item>
    
    <item>
      <title>avy</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/avy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/avy/</guid>
      <description>概要 avy は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。 Vimium の f とかに似てる。
インストール el-get で普通にインストールしている
(el-get-bundle avy) 設定 文字の上に重なると元の文字列がよくわからなくなるので、移動先の文字の前に表示するようにしている
(setq avy-style &amp;#39;pre) キーバインド グローバルなキーバインドを汚染したくなかったのでひとまず Hydra を定義している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define avy-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;avy&amp;#34; :foreign-key warn :quit-key &amp;#34;q&amp;#34; :exit t) (&amp;#34;Char&amp;#34; ((&amp;#34;c&amp;#34; avy-goto-char &amp;#34;Char&amp;#34;) (&amp;#34;C&amp;#34; avy-goto-char-2 &amp;#34;Char 2&amp;#34;) (&amp;#34;x&amp;#34; avy-goto-char-timer &amp;#34;Char Timer&amp;#34;)) &amp;#34;Word&amp;#34; ((&amp;#34;w&amp;#34; avy-goto-word-1 &amp;#34;Word&amp;#34;) (&amp;#34;W&amp;#34; avy-goto-word-0 &amp;#34;Word 0&amp;#34;)) &amp;#34;Line&amp;#34; ((&amp;#34;l&amp;#34; avy-goto-line &amp;#34;Line&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;r&amp;#34; avy-resume &amp;#34;Resume&amp;#34;)))))    Key 効果     c 1文字からの絞り込み   C 2文字から絞り込み   x 任意の文字列からの絞り込み   w 1文字絞り込んで単語先頭に移動   W 絞り込みなしの単語移動   l 列移動   r 繰り返し同じコマンドを実行    </description>
    </item>
    
    <item>
      <title>Ember.js</title>
      <link>https://mugijiru.github.io/.emacs.d/framework-config/ember-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/framework-config/ember-js/</guid>
      <description>概要 Ember.js 用の Emacs の拡張としては ember-mode と handlebars-mode が存在する
ember-mode ember-mode は Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。実は麦汁さんは使えてない。
インストールするだけではダメで、 ember-mode を明示的に起動しないといけない。
そのためには dir-locals を使うとか projectile なんかがやってるようにフォルダ構成から判定させるみたいなことが必要そう。だるい。
というわけで死蔵中。
ついでにいうとキーバインドもだるい系なので使う時は Hydra を用意した方が良さそう
(el-get-bundle madnificent/ember-mode) handlebars-mode handlebars-mode は Ember.js のテンプレートエンジンとして採用されている Handlebars を書くためのモード。
syntax highlight と、いくつかの編集機能を備えている。が、今のところ麦汁さんは syntax highlight しか使えてない。
編集コマンドは major-mode-hydra で使えるようにしてあげれば良さそう
(el-get-bundle handlebars-mode) </description>
    </item>
    
    <item>
      <title>exec-path</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/exec-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/exec-path/</guid>
      <description>概要 Emacs は通常最小限の環境変数しか利用しないようになっている。
が、それだと普段使う上で「ああ、このコマンドが使えなくてもどかしい……!」と感じてしまう。
そこで exec-path-from-shell というのを使って Emacs が見える PATH 環境変数をシェルが見てる PATH 環境変数と揃うようにしている。
インストール いつも通り el-get からインストールしている
(el-get-bundle exec-path-from-shell) 有効化 理由は忘れたが Mac の環境でのみ有効化している。その内 Linux 環境でも有効化を試みた方が良さそう
(when (memq window-system &amp;#39;(mac ns)) (exec-path-from-shell-initialize)) なお、これでシェルと共通の環境変数が使われるようになるのは デフォルトでは PATH と MANPATH のみである
その他 なぜか以下のようなコメントを書いていた。普段使っている zsh で持ってる PATH は使わないのだろうか? :thinking_face:
;; for exec path ;; use .bashrc setted path </description>
    </item>
    
    <item>
      <title>helm-posframe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/helm-posframe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/helm-posframe/</guid>
      <description>概要 helm-posframe は helm の拡張で Helm のバッファの表示を posframe を使うようにしてくれるやつ。
実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなのでいずれ外すかもしれない。
ただ確か本体の方の挙動が気に入らなかったような気はする。
インストール いつも通り el-get でインストール。 GitHub にあるのでそれを取得するようにしている。
(el-get-bundle tumashu/helm-posframe) 有効化 (helm-posframe-enable) </description>
    </item>
    
    <item>
      <title>highlight-indent-guides</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/</guid>
      <description>概要 highlight-indent-guides はインデント毎にラインを引いたりして見易くしてくれるパッケージ。通常のプログラムを書く時にも便利だけど、 YAML などのインデントがそのまま構造になるような言語を弄る時にとても便利。
インストール これもいつも通り el-get でインストールしている。また GitHub にあるので、そこから直接インストールしている。
(el-get-bundle DarthFennec/highlight-indent-guides) 設定 今いる行がどのインデントにいるのかをわかりやすくするために responsive モードを有効にしている。
(setq highlight-indent-guides-responsive &amp;#34;stack&amp;#34;) defcustom で定義されてる変数なので custom-set-variables で設定した方がいいかもしれない。</description>
    </item>
    
    <item>
      <title>load-path</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/load-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/load-path/</guid>
      <description>概要 load-path は Emacs の設定でも重要な項目でこのリストに追加されている path は load または require する際に走査される path となっている。
即ち load-path を通しておけば、そこに置いている emacs lisp のファイルは簡単に読み出せるようになる。
なお package-install や el-get を使っておけば基本的に自分で load-path を通す必要はない。
秘匿情報を入れてるフォルダを読み込み可能にする パスワードなどの秘匿情報を持っている部分は ~/.emacs.d/secret というフォルダで管理している。そのためここに入ってる emacs lisp のファイルも読み込めるように load-path に追加している。
(add-to-list &amp;#39;load-path (expand-file-name &amp;#34;~/.emacs.d/secret&amp;#34;)) my/load-config ~/.emacs.d/secret は個人マシンか会社マシンかによって置いてるデータが異なったりするためもしもファイルがなくてもエラーにならないような方法で load する方法が必要だった。
というわけでファイルがなかったら読み込まずにメッセージを出力して終了するような関数を用意している。
(defun my/load-config (file) (condition-case nil (load file) (file-missing (message &amp;#34;Load error: %s&amp;#34; file)))) ただ、これって結局
(load file nil t) で十分な気もするので、置き換えを検討した方が良さそう。</description>
    </item>
    
    <item>
      <title>Neotree</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/neotree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/neotree/</guid>
      <description>概要 Neotree は Emacs でフォルダのツリー表示ができるやつ。メンテは活発じゃないようなので、その内乗り換えたい。
レシピ Neotree でメンテされているのは dev ブランチだけど el-get の公式のレシピでは master ブランチを見ているので自前で recipe を用意してそれを使っている。
(:name emacs-neotree-dev :website &amp;#34;https://github.com/jaypei/emacs-neotree&amp;#34; :description &amp;#34;An Emacs tree plugin like NerdTree for Vim.&amp;#34; :type github :branch &amp;#34;dev&amp;#34; :pkgname &amp;#34;jaypei/emacs-neotree&amp;#34;) インストール 上に書いたレシピを使ってインストールしている。
(el-get-bundle emacs-neotree-dev) 使わなくなったコード 元々設定していたが、 counsel-projectile を使ってると projectile-switch-project-action を設定していても反映されず意味がないのに気付いたので使わなくなった
https://github.com/mugijiru/.emacs.d/pull/183/files#r541843206
(setq projectile-switch-project-action &amp;#39;neotree-projectile-action) テーマの設定 GUI で起動している時はアイコン表示しそうでない場合は ▾ とかで表示する
(setq neo-theme (if (display-graphic-p) &amp;#39;icons &amp;#39;arrow)) のだけど、実際に今使ってるやつだともっとグラフィカルな表示なので all-the-icons の設定で上書きしている気がするので要確認
major-mode-hydra いちいちキーバインドを覚えてられないので major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。
とはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。</description>
    </item>
    
    <item>
      <title>savehist</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/savehist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/savehist/</guid>
      <description>概要 Emacs 標準でついている、ミニバッファの履歴などを保存してくれる機能。
有効化 標準でついているので以下のようにするだけで有効化可能。
(savehist-mode 1) 設定 標準で保存されるもの以外だと kill-ring だけを保存対象にしている。これで Emacs を終了させても kill-ring は残るようになるはず。だけど最近使えてない気がするな……。検証が必要そう。
(setq savehist-additional-variables &amp;#39;(kill-ring)) 他にも有効にしたら便利そうなのがあれば追加したい。が、ぱっとは思い付かない。</description>
    </item>
    
    <item>
      <title>sticky-control</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/</guid>
      <description>概要 指定したキーを2回叩いたら Control が押されてるような状態にしてくれるプラグイン。
その2回の間隔はデフォルトだと 0.5 秒以内となっている。そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる
さらに sticky-control-shortcuts に指定されてる一部のキーについては sticky 用のキーを押した直後に shortcuts のキーを押すと Control を押している状態でそのキーを押したことになる。
例えば私は , を sticky 用のキーにしていて shortcuts に c を入れているので ,c と素早くタイプをすればそれだけで C-c が押された状態になる。
インストール まずは el-get-bundle でインストール。
(el-get-bundle sticky-control) ちなみにレシピは公式ではなかったのでとりあえず自分の環境で使えるように自作レシピを置いている。
(:name sticky-control :description &amp;#34;save your left little finger&amp;#34; :type http :url &amp;#34;https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el&amp;#34; :features &amp;#34;sticky-control&amp;#34;) 元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど最近そこからは取得できなくなったので https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el から取得して利用している
設定 まずは「2回叩いたら Control を押している状態になる」キーを指定する。
(sticky-control-set-key &amp;#39;sticky-control-key ?,) 私は , を sticky-control のキーにしているのでこの指定。
そして次に sticky-control-shortuts の指定。ここに指定しておくと、例えば ,c と素早くタイプすることで C-c が入力された状態とすることができる。</description>
    </item>
    
    <item>
      <title>toolbar</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/toolbar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/toolbar/</guid>
      <description>概要 Emacs 標準の toolbar の設定。麦汁さんは使わないし幅を取るので隠す派。
設定 単に無効にして隠している
(tool-bar-mode -1) </description>
    </item>
    
    <item>
      <title>ガベージコレクション</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/gcmh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/gcmh/</guid>
      <description>概要 ガベージコレクションには gcmh というのを利用してみている。
https://github.com/emacsmirror/gcmh
普段は GC を控えめにしながら操作してない間に GC が走るような作りになっている。便利そう。
インストール (el-get-bundle gcmh) これだけで有効化もされる。
その他 以前の設定も折り畳んで残しておく
  使わなくなったコード  gcmh を入れる前に設定していたコード。 gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。
;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf ;; Increase threshold to fire garbage collection (setq gc-cons-threshold 1073741824) (setq garbage-collection-messages t) ;; Run GC every 60 seconds if emacs is idle. (run-with-idle-timer 60.0 t #&amp;#39;garbage-collect) 
 </description>
    </item>
    
  </channel>
</rss>
