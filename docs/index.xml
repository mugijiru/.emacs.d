<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>麦汁&#39;s Emacs Config</title>
    <link>https://mugijiru.github.io/.emacs.d/</link>
    <description>Recent content on 麦汁&#39;s Emacs Config</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language><atom:link href="https://mugijiru.github.io/.emacs.d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>with-simulated-input</title>
      <link>https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing-tool/with-simulated-input/</guid>
      <description>概要 with-simulated-input は入力処理をシミュレートするためのプラグイン。
公式のドキュメントにあるように
(with-simulated-input &amp;#34;hello SPC world RET&amp;#34; (read-string &amp;#34;Say hello to the world: &amp;#34;)) を評価すると read-string に対して「hello world」を入力したことになるので echo エリアに「hello world」と表示される。
これで何が嬉しいかというと Emacs Lisp でやっていることはインタラクティブな部分が大きいのでそういった要素をテストできるようになる。
具体的な使用例は test:my/org-todo で示す。
インストール el-get-bundle で GitHub からインストールしている
(el-get-bundle DarwinAwardWinner/with-simulated-input) </description>
    </item>
    
    <item>
      <title>基本設定</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/editing-base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/editing-base/</guid>
      <description>概要 なんか編集周りの基本的な設定としてまとめられていたのでここに置いとく
インデントにタブを使わないようにする 最近の開発スタイルではインデントにタブを混ぜないスタイルなのでそのように設定している。
(setq indent-tabs-mode nil) 以前に開いていた位置を保存/復元する save-place-mode を有効にしていると以前に開いたことのあるファイルの、開いていた場所を覚えておいてくれる。
一度閉じてまた開いた時なんかに再度移動しないで済んで地味に便利なやつ
(save-place-mode 1) </description>
    </item>
    
    <item>
      <title>基本設定</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/base/</guid>
      <description>概要 ここでは org-mode 周りのベースとなる設定を書いているつもり。といいつつ、まだ書き方が雑だなと思っている。またその内にでも修正しよう
org-mode のインストール Emacs に標準で入っている org-mode は大体古過ぎるのでとりあえずデフォルトで入ってるやつは削除しちゃって el-get でインストールしている。
(el-get-bundle org-mode) なんか入れてるパッケージの問題か、依存関係が解決できなかったので Git から入れた上でバージョンを固定している。
バージョンぐらいはそのうち上げたいね
org 用ディレクトリの指定 org-mode のファイルを保存するデフォルトのディレクトリを指定している。
デフォルトだと ~/org なのだけどホームディレクトリを汚したくないのと基本的に Mac を使ってるので ~/Documents/org というディレクトリを用意してそこにファイルを置いている。
(setq org-directory (expand-file-name &amp;#34;~/Documents/org/&amp;#34;)) タスク管理ファイルのフォルダの指定 タスク管理ファイルがいくつかに分かれているがそれらをまとめて ~/Documents/org/tasks フォルダに置いている。
(setq my/org-tasks-directory (concat org-directory &amp;#34;tasks/&amp;#34;)) とりあえずこの my/org-tasks-directory という変数を用意することであちらこちらでこれを使い回している。
タスクの状態管理のキーワード指定 org-mode といえば TODO 管理で使ってる人も多いと思う。自分も最初はそういう使い方から始めたし、今でもそれをメインにして使っている。
そして TODO の状態がデフォルトでは
TODO DONE の2つしかないけど、それでは足りないので昔見たインターネットのどこかの記事を参考に以下のように設定している。
(setq org-todo-keywords &amp;#39;((sequence &amp;#34;TODO&amp;#34; &amp;#34;EXAMINATION(e)&amp;#34; &amp;#34;READY(r)&amp;#34; &amp;#34;DOING(!)&amp;#34; &amp;#34;WAIT&amp;#34; &amp;#34;|&amp;#34; &amp;#34;DONE(!)&amp;#34; &amp;#34;SOMEDAY(s)&amp;#34;))) 初期状態は TODO で、作業開始時点で DOING にして待ちが発生したら WAIT にして完了したら DONE にしている。</description>
    </item>
    
    <item>
      <title>実行方法</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/execution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/execution/</guid>
      <description>テストする時は以下のように叩いたら動く。
emacs -Q --batch -l ~/.emacs.d/inits/test/*-test.el -l ~/.emacs.d/inits/test/run-tests.el 今まで .emacs.d にいる状態でしか叩いたことないので他の場所にいる時に実行しても大丈夫かはわからない。
単体でテストしたい時は
-l ~/.emacs.d/inits/test/*-test.el の部分を書き換えたらいいんじゃないかな。やったことないけど。</description>
    </item>
    
    <item>
      <title>mocker.el</title>
      <link>https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing-tool/mocker-el/</guid>
      <description>概要 mocker.el は Emacs Lisp のテストで使う Mock ライブラリ。
使おうと思って導入したけど、自分のやりたいことはちょっと違ったので死蔵中
便利そうなのでとりあえず置いといている。
インストール el-get で GitHub から取得している。
(el-get-bundle sigma/mocker.el) </description>
    </item>
    
    <item>
      <title>org-babel</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-babel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-babel/</guid>
      <description>概要 ここでは org-babel の設定をまとめている。
org-babel で評価可能な言語の指定 なんか普段から使いそうな奴をとりあえず選定しているつもり。
(org-babel-do-load-languages &amp;#39;org-babel-load-languages &amp;#39;((plantuml . t) (sql . t) (gnuplot . t) (emacs-lisp . t) (shell . t) (js . t) (org . t) (ruby . t))) js, ruby 仕事でメインで使ってる言語なので入れている。 shell 入れてる方が便利そう、ぐらいの雑な理由。 sql メモしておいて手元から実行できると便利そう plantuml 図の出力。一番使ってる。 gnuplot 趣味で入れてみているけど実際使う機会ほとんどないよなって気がしてきている。 org-babel-execute 後に画像を再表示 PlantUML の処理をすることが多いので以下の hook を設定することで実行後に画像を再表示するようにしている
(add-hook &amp;#39;org-babel-after-execute-hook &amp;#39;org-redisplay-inline-images) org-babel の非同期実行 improvement 非同期に org-babel の source を実行するために ob-async を入れている
(el-get-bundle ob-async) (require &amp;#39;ob-async) で、ob-async を何のために入れているかというと PlantUML の図の出力である。画像まで作成するからね、時間かかりそうだしね。</description>
    </item>
    
    <item>
      <title>run-tests</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/run-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/run-tests/</guid>
      <description>読み込んだテストをまるっとテストするためのコードをとりあえず置いている。
(if noninteractive (let ((ert-quiet t)) (ert-run-tests-batch-and-exit))) 後述の テストライブラリの読み込み などはここで担うべきかとも考えるが今はテストファイルが1つしかないので気にしないことにする。</description>
    </item>
    
    <item>
      <title>my-org-commands-test</title>
      <link>https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/testing/my-org-commands-test/</guid>
      <description>org-mode 用に定義したコマンドや関数のテストコード
Setup テストライブラリの読み込み 標準でついてくる ert を採用しているのでそれを読み込んでいる。
(require &amp;#39;ert) el-get の設定の読み込み プラグイン管理には el-get を利用しているのでその設定ファイルを読み込んでいる。
;; プラグイン読み込みの前準備 (load (expand-file-name (concat user-emacs-directory &amp;#34;/init-el-get.el&amp;#34;))) テスト補助のプラグイン読み込み with-simulated-input 上で説明しているが、入力をシミュレートするためのプラグインをテストで利用しているのでここで読み込んでいる。
;; 入力シミュレート用のプラグイン (load (expand-file-name (concat user-emacs-directory &amp;#34;/inits/99-with-simulated-input&amp;#34;))) 依存プラグインの読み込み テスト対象が依存しているプラグインを読み込んでいる。本来は init.el などの設定ファイルを全部読み込んだ状態でテストをした方が良さそうだが現状だとその状態で GitHub Actions で動かせる方法がわからないので一旦個別に読み込むようにしている。
swiper ivy-read を使った機能のテストをするので読み込んでいる。
(el-get-bundle abo-abo/swiper) テスト対象の読み込み テストしたいファイルをここで読んでる。
;; テスト対象の読み込み (load (expand-file-name (concat user-emacs-directory &amp;#34;/inits/68-my-org-commands.el&amp;#34;))) ert-deftest test:my/org-todo-keyword-strings org-todo-keywords から &amp;ldquo;|&amp;rdquo; という区切りを除外したり &amp;ldquo;(s)&amp;rdquo; とかのような高速アクセスのためのキーワードは ivy で選択する時には邪魔なので除外したい、ということを表現したテスト。
(ert-deftest test:my/org-todo-keyword-strings () &amp;#34;Test of `my/org-todo-keyword-strings&amp;#39;.&amp;#34; (let ((org-todo-keywords &amp;#39;((sequence &amp;#34;TODO&amp;#34; &amp;#34;DOING(!</description>
    </item>
    
    <item>
      <title>予定のカレンダー表示</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/calendar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/calendar/</guid>
      <description>概要 普段の予定をカレンダー表示で見れると嬉しいな〜と思って calfw で予定が見れるようにしている。
が、今ここに書いているのはまだ設定の一部である。 agenda 部分と関わっていてまだうまく整理しきれてない。
日本の休日 calfw に日本の休日を表示できるように japanese-holidays を入れている。
(el-get-bundle japanese-holidays) (require &amp;#39;japanese-holidays) (setq calendar-holidays (append japanese-holidays)) もっとちゃんと設定したら Emacs のデフォルトのカレンダーでも休日表示がわかりやすくなって良いので今度設定し直す。
その時には多分 org-mode カテゴリではないところに移動するはず。
calfw calfw を el-get で入れた上で、 org-mode と連携するように calfw-org も require している。
(el-get-bundle calfw) (require &amp;#39;calfw) (require &amp;#39;calfw-org) ここではまだこれ以上のことはしてない</description>
    </item>
    
    <item>
      <title>Agenda 関係の設定</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/agenda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/agenda/</guid>
      <description>概要 org-mode の素晴らしい機能の1つに Agenda というものがある。
これは色々な org ファイルに散らばった情報を1つのビューに表示するための機能で、使いこなすとファイルがバラけていてもいい感じに情報が抽出できて便利なやつ。
まあ麦汁さんはまだ使いこなせてないけど。
それでもいくつか Agenda 用の View を用意したりして日常業務に役立てている。
org-super-agenda のインストール org-mode のデフォルトの agenda だと表示周りが物足りなかったので org-super-agenda を導入している。
(el-get-bundle org-super-agenda) 週の始まりを日曜日に設定 麦汁さんは週のスタートを日曜日とする派なので org-agenda の週の始まりも日曜日に設定している
(setq org-agenda-start-on-weekday 0) 1日単位をデフォルト表示に設定 1週間表示よりも「今日って何するんだっけ」みたいな使い方が多いので 1日を表示単位としている。
(setq org-agenda-span &amp;#39;day) 週単位で何をするかについては今のところ記憶力で対応している。
あと、基本的にカスタムビューを使ってるのでこれの影響は受けてるかどうか微妙。
agenda の対象ファイルを指定 org-agenda を使う時に抽出対象とする org ファイルを指定している。
(setq org-agenda-files &amp;#39;(&amp;#34;~/Documents/org/ical.org&amp;#34; &amp;#34;~/Documents/org/tasks/&amp;#34;)) けどカスタムビューを多用しているので多分この設定ちゃんと活かしてない。 ical.org とか更新してないし……。
agenda の表示周りの設定 agenda に時間の区切りを入れない org-agenda-use-time-grid を t にしていると 10:00 とかのキリがいいところに区切り線を表示してくれるのだが日報提出時には邪魔だし、普段使いでもその区切り線はあっても邪魔っぽいので nil にして表示しないようにしている。
(setq org-agenda-use-time-grid nil) ブロック間の区切り表示 ブロックとブロックの区切りをハイフン繋ぎの文字列で指定している。
文字列を指定することで固定の長さの区切り文字になるが実は ?</description>
    </item>
    
    <item>
      <title>org-capture</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-capture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-capture/</guid>
      <description>概要 org-capture は org-mode 用にさくっとメモを取るための機能。
org-capture-ical-file unused https://qiita.com/takaxp/items/0b717ad1d0488b74429d を参考に設定したやつ。
今は別で Google Calendar 連携しているので使ってない……。
;; org-capture (defvar org-capture-ical-file (concat org-directory &amp;#34;ical.org&amp;#34;)) (setq org-capture-ical-file (concat org-directory &amp;#34;ical.org&amp;#34;)) capture 用ファイルを変数定義 improvement 変数定義しなくてもいい気がしないでもないけどとりあえず変数定義している。バラバラの変数にするよりも alist とか plist とかにする方が適切な気がする
(setq my/org-capture-interrupted-file (concat my/org-tasks-directory &amp;#34;interrupted.org&amp;#34;)) (setq my/org-capture-inbox-file (concat my/org-tasks-directory &amp;#34;inbox.org&amp;#34;)) (setq my/org-capture-pointers-file (concat my/org-tasks-directory &amp;#34;pointers.org&amp;#34;)) (setq my/org-capture-impediments-file (concat org-directory &amp;#34;work/scrum/impediments.org&amp;#34;)) (setq my/org-capture-memo-file (concat org-directory &amp;#34;memo.org&amp;#34;)) (setq my/org-capture-sql-file (concat org-directory &amp;#34;work/sql.org&amp;#34;)) (setq my/org-capture-shopping-file (concat my/org-tasks-directory &amp;#34;shopping.org&amp;#34;)) (setq my/org-capture-2020-summary-file (concat org-directory &amp;#34;private/2020_summary.</description>
    </item>
    
    <item>
      <title>org-clock</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-clock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-clock/</guid>
      <description>概要 org-clock 関係の設定をここにまとめている
clocktable の設定 clocktable は report 表示などで使う表の設定。
(setq org-clock-clocktable-default-properties &amp;#39;(:maxlevel 10 :lang &amp;#34;ja&amp;#34; :scope agenda-with-archives :block today :level 4)) 項目名 設定内容 maxlevel ツリーの何段目まで表示するかの設定。隠さないで欲しいので大きい値を指定している lang 日本語ネイティブなので日本語で scope agenda とそのアーカイブもチェック。結構するアーカイブするので block 基本的に退勤前に実行するので today にしている level 最低限表示するレベル。まあ適当 hooks clock-in 時の hook clock-in のタイミングで以下の処理をするための hook を用意している
作業開始したことを Slack 通知する TODO ステータスを DOING に変更 (defun my/org-clock-in-hook () (let* ((task org-clock-current-task) (message (format &amp;#34;開始: %s&amp;#34; task))) (my/notify-slack-times message)) (if (org-clocking-p) (org-todo &amp;#34;DOING&amp;#34;))) (setq org-clock-in-hook &amp;#39;my/org-clock-in-hook) clock-out 時の hook clock-out のタイミングで以下の処理をするための hook を用意している</description>
    </item>
    
    <item>
      <title>org-export</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-export/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-export/</guid>
      <description>概要 ここではファイルへの出力用の設定をまとめている。というか昔書いた設定をとりあえずここに押し込めている
footnote や制作者などを出力しない HTML で記事を吐き出す時に邪魔だったの非表示にしている記憶。随分昔に設定したのであんまり覚えてない。
;; フッターなくしたり (setq org-export-html-footnotes-section &amp;#34;&amp;#34;) (setq org-export-html-footnote-format &amp;#34;&amp;#34;) (setq org-export-with-footnotes nil) (setq org-export-with-creator nil) (setq org-export-with-author nil) (setq org-html-validation-link nil) 以下は seesaa blog への吐き出し用設定なのだけどもう向こうを更新することはないので消しても良さそう
;; for seesaa blog settings (setq org-export-author-info nil) (setq org-export-email-info nil) (setq org-export-creator-info nil) (setq org-export-time-stamp-file nil) (setq org-export-with-timestamps nil) (setq org-export-with-section-numbers nil) (setq org-export-with-sub-superscripts nil) Table of Contents 出力抑制 これも自分の用途では要らなかったけどファイル単位とかで制御しても良い気がする
(setq org-export-with-toc nil) サイト名の出力 seesaa blog 用に記事を吐き出していた時はページ全体ではなく記事部分だけ出力したかったのでつまり h1 とかはもうテンプレート側に埋め込まれているので出す必要がなかった</description>
    </item>
    
    <item>
      <title>org-gcal</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-gcal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-gcal/</guid>
      <description>概要 org-gcal は org-mode と Google Calendar を連携させるためのパッケージ。
オリジナルは https://github.com/myuhe/org-gcal.el なのだけど今は fork されてるやつが MELPA にも登録されていて el-get のレシピもそっちを見ている。
インストール org-gcal が依存しているので parsist を入れている。
(el-get-bundle persist) あとは当然 org-gcal 本体を入れないと動かない
(el-get-bundle org-gcal) 設定 まずは org-gcal の設定が authinfo から読み込まれるようにする
(custom-set-variables &amp;#39;(org-gcal-client-id (plist-get (nth 0 (auth-source-search :host &amp;#34;googleusercontent.com&amp;#34;)) :client)) &amp;#39;(org-gcal-client-secret (funcall (plist-get (nth 0 (auth-source-search :host &amp;#34;googleusercontent.com&amp;#34; :max 1)) :secret)))) そして org-gcal 本体を require する。
(require &amp;#39;org-gcal) あとは passphrase を保存できるようにした方が良いみたいなのが確か README に比較的最近追加されたのでそれを入れている
(setq plstore-cache-passphrase-for-symmetric-encryption t) あとは設定ファイルは公開したくないので別ファイルに分けてる。</description>
    </item>
    
    <item>
      <title>org-ql</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-ql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-ql/</guid>
      <description>概要 org-ql は org-mode の情報を検索するためのパッケージ。柔軟な検索ができるようになるので貴方好みの検索で業務効率向上ができちゃうかも!?
インストール いつも透り el-get でインストールしている
(el-get-bundle org-ql) その他 一時期は色々試していたけどこれを利用している org-super-agenda の方でなんとかするようにしたのでもう直接は使ってないでござる</description>
    </item>
    
    <item>
      <title>org-refile</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-refile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-refile/</guid>
      <description>概要 org-refile は org-mode の1機能で org-mode のエントリを別のファイルなどに移動するための機能。実はコピーもできるけど、コピーは使ったことがない。
設定 org ファイル内の階層を選択候補に入れる これを nil に設定することでファイルの選択だけでなく、その中の PATH まで選択できるようになる
(setq org-outline-path-complete-in-steps nil) refile ターゲットにファイル名を含める 以下のように設定すると refile のターゲット候補としてファイル名とその中の PATH が表示されるようになる。
(setq org-refile-use-outline-path &amp;#39;file) nil だと移動先候補PATHの最後の部分しか表示されないのでどのファイルのどの場所かというのがわかりにくいのでこのように設定している。
refile 先の候補設定 いくつかの org ファイルを使っているのでターゲットを以下のように設定している。
(setq org-refile-targets `((,(concat org-directory &amp;#34;tasks/projects.org&amp;#34;) :level . 1) (,(concat org-directory &amp;#34;tasks/pointers.org&amp;#34;) :level . 1) (,(concat org-directory &amp;#34;work/scrum/impediments.org&amp;#34;) :level . 3) (,(concat org-directory &amp;#34;tasks/next-actions.org&amp;#34;) :regexp . &amp;#34;today&amp;#34;) (,(concat org-directory &amp;#34;tasks/next-actions.org&amp;#34;) :regexp . &amp;#34;C-&amp;#34;) (,(concat org-directory &amp;#34;private/2020_summary.org&amp;#34;) :level .</description>
    </item>
    
    <item>
      <title>org-trello</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-trello/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-trello/</guid>
      <description>概要 org-trello は org-mode を使って Trello のタスクを管理するためのパッケージ。
インストール いつも通り el-get でインストールしている
(el-get-bundle org-trello) 同期するコマンドの用意 バッファと Trello との同期する関数はあるのだけどコマンドにはなっていなかったので同期するためのコマンドを用意している
(defun my/org-trello-fetch-buffer () (interactive) (org-trello-sync-buffer t)) キーバインド設定 キーバインドは覚えられないので、いつも通り pretty-hydra で Hydra のやつを用意している
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define org-trello-hydra (:separator &amp;#34;-&amp;#34; :color teal :foreign-key warn :title (concat (all-the-icons-faicon &amp;#34;trello&amp;#34;) &amp;#34; Org Trello commands&amp;#34;) :quit-key &amp;#34;q&amp;#34;) (&amp;#34;Install&amp;#34; ((&amp;#34;i&amp;#34; org-trello-install-board-metadata &amp;#34;Board metadata&amp;#34;) (&amp;#34;I&amp;#34; org-trello-install-key-and-token &amp;#34;Setup&amp;#34;)) &amp;#34;Sync&amp;#34; ((&amp;#34;s&amp;#34; my/org-trello-fetch-buffer &amp;#34;← Trello&amp;#34;) (&amp;#34;S&amp;#34; org-trello-sync-buffer &amp;#34;→ Trello&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;V&amp;#34; org-trello-version &amp;#34;Version&amp;#34;))))) Key 効果 i Board のメタデータをインストールする I Key と トークンを設定する s Trello の情報を引っ張ってくる S Trello の情報を連携する V バージョン情報を表示 その他 まだ試していないが https://github.</description>
    </item>
    
    <item>
      <title>ox-hugo</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/ox-hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/ox-hugo/</guid>
      <description>概要 ox-hugo は org-mode から Hugo 用に md ファイルを出力できる便利なやつ。
設定にもよるけど、1つのorgファイルに全部の記事を書いておいてツリー毎に md ファイルが生成される、というのがデフォルトの動きなので 1ファイルに詰めておくとファイルが分散しないで済んで良い。
なお、この 麦汁&amp;rsquo;s Emacs Config も親サイトである 麦汁三昧 も ox-hugo を用いて構築している
インストール・読み込み レシピは自前で用意している
(:name ox-hugo :description &amp;#34;A carefully crafted Org exporter back-end for Hugo https://ox-hugo.scripter.co&amp;#34; :type github :pkgname &amp;#34;kaushalmodi/ox-hugo&amp;#34; :branch &amp;#34;main&amp;#34; :depends (org-mode tomelr)) そしていつも通り el-get でインスコしている。
(el-get-bundle ox-hugo) そして org-mode の ox が先に読まれてないといけないので with-eval-after-load を使って、ox が読まれてから require するようにしている。
(with-eval-after-load &amp;#39;ox (require &amp;#39;ox-hugo)) その他 デフォルト設定でいい感じに使えているので特に設定変更は加えていない。</description>
    </item>
    
    <item>
      <title>org-mode 用の独自コマンド</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-commands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-commands/</guid>
      <description>概要 org-mode を使う上で、標準で用意されているコマンド以外に自分でも適当にコマンドを用意しているのでここにまとめている。
org-mode 用のファイルを作成するコマンド unused 指定したフォルダに org-mode なファイルを作るためのコマンドを用意している。
が、使ってないし意味をあまり感じないし消して良さそう。
(setq my/org-document-dir (expand-file-name &amp;#34;~/Documents/org/&amp;#34;)) (defun my/create-org-document () (interactive) (find-file-other-window my/org-document-dir)) 各ツリーの所要時間表示/非表示切替 org-clock-display で各ツリーにおける org-clock で記録された所要時間が表示でき、 org-clock-remove-overlays でそれを非表示にできるが、それを Toggle できるようにコマンド/関数を定義している。
(defun my/org-clock-toggle-display () &amp;#34;各ツリーの末尾に掛かった作業時間を表示/非表示を切り替えるコマンド&amp;#34; (interactive) (if org-clock-overlays (org-clock-remove-overlays) (org-clock-display))) org-todo-keywords から装飾を省いた文字列のリストを返す関数 ivy で org-todo-keywords を選択可能にするために org-todo-keywords を加工してシンプルな文字列の配列にする関数を定義している。
後述の my/org-todo で利用している
(defun my/org-todo-keyword-strings () &amp;#34;org-todo-keywords から装飾を省いた文字列のリストを返す関数&amp;#34; (let* ((keywords (cl-rest (cl-first org-todo-keywords))) (without-delimiter (cl-remove-if (lambda (elm) (string= &amp;#34;|&amp;#34; elm)) keywords))) (mapcar (lambda (element) (replace-regexp-in-string &amp;#34;\(.</description>
    </item>
    
    <item>
      <title>org-mode 関係の keybinds</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/org-mode-keybinds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/org-mode-keybinds/</guid>
      <description>概要 ここでは org-mode 関係のキーバインド設定を書いている。キーバインドというか Hydra の設定になっているが。
Hydra を定義しておくことで様々なキーバインドを忘れることができるし左手小指を酷使しなくて済むので便利ということで Hydra で設定している。
major-mode-hydra major-mode-hydra で、org-mode のファイルを開いている時によく使いそうなコマンドのキーバインドを定義している
(with-eval-after-load &amp;#39;major-mode-hydra (major-mode-hydra-define org-mode (:separator &amp;#34;-&amp;#34; :quit-key &amp;#34;q&amp;#34; :title (concat (all-the-icons-fileicon &amp;#34;org&amp;#34;) &amp;#34; Org commands&amp;#34;)) (&amp;#34;Insert&amp;#34; ((&amp;#34;l&amp;#34; org-insert-link &amp;#34;Link&amp;#34;) (&amp;#34;T&amp;#34; org-insert-todo-heading &amp;#34;Todo&amp;#34;) (&amp;#34;h&amp;#34; org-insert-heading-respect-content &amp;#34;Heading&amp;#34;) (&amp;#34;P&amp;#34; org-set-property &amp;#34;Property&amp;#34;) (&amp;#34;.&amp;#34; org-time-stamp &amp;#34;Timestamp&amp;#34;) (&amp;#34;!&amp;#34; org-time-stamp-inactive &amp;#34;Timestamp(inactive)&amp;#34;) (&amp;#34;S&amp;#34; org-insert-structure-template &amp;#34;Snippet&amp;#34;)) &amp;#34;Edit&amp;#34; ((&amp;#34;a&amp;#34; org-archive-subtree &amp;#34;Archive&amp;#34;) (&amp;#34;r&amp;#34; org-refile &amp;#34;Refile&amp;#34;) (&amp;#34;Q&amp;#34; org-set-tags-command &amp;#34;Tag&amp;#34;)) &amp;#34;View&amp;#34; ((&amp;#34;N&amp;#34; org-toggle-narrow-to-subtree &amp;#34;Toggle Subtree&amp;#34;) (&amp;#34;C&amp;#34; org-columns &amp;#34;Columns&amp;#34;) (&amp;#34;O&amp;#34; org-global-cycle &amp;#34;Toggle open&amp;#34;) (&amp;#34;D&amp;#34; my/org-clock-toggle-display &amp;#34;Toggle Display&amp;#34;)) &amp;#34;Task&amp;#34; ((&amp;#34;s&amp;#34; org-schedule &amp;#34;Schedule&amp;#34;) (&amp;#34;d&amp;#34; org-deadline &amp;#34;Deadline&amp;#34;) (&amp;#34;t&amp;#34; my/org-todo &amp;#34;Change state&amp;#34;) (&amp;#34;c&amp;#34; org-toggle-checkbox &amp;#34;Toggle checkbox&amp;#34;)) &amp;#34;Clock&amp;#34; ((&amp;#34;i&amp;#34; org-clock-in &amp;#34;In&amp;#34;) (&amp;#34;o&amp;#34; org-clock-out &amp;#34;Out&amp;#34;) (&amp;#34;E&amp;#34; org-set-effort &amp;#34;Effort&amp;#34;) (&amp;#34;R&amp;#34; org-clock-report &amp;#34;Report&amp;#34;) (&amp;#34;p&amp;#34; org-pomodoro &amp;#34;Pomodoro&amp;#34;)) &amp;#34;Babel&amp;#34; ((&amp;#34;e&amp;#34; org-babel-confirm-evaluate &amp;#34;Eval&amp;#34;) (&amp;#34;x&amp;#34; org-babel-tangle &amp;#34;Export SRC&amp;#34;)) &amp;#34;Roam&amp;#34; ((&amp;#34;;&amp;#34; org-roam-hydra/body &amp;#34;Menu&amp;#34;)) &amp;#34;Trello&amp;#34; ((&amp;#34;K&amp;#34; org-trello-mode &amp;#34;On/Off&amp;#34; :toggle org-trello-mode) (&amp;#34;k&amp;#34; (if org-trello-mode (org-trello-hydra/body) (message &amp;#34;org-trello-mode is not enabled&amp;#34;)) &amp;#34;Menu&amp;#34;)) &amp;#34;Agenda&amp;#34; ((&amp;#34;,&amp;#34; org-cycle-agenda-files &amp;#34;Cycle&amp;#34;))))) Key 効果 使用頻度 l リンク挿入 C-c C-l で手が馴染んでるのでたまに使う程度 T TODO ヘッドライン挿入 なんかあまり使わない h ヘッドライン挿入 これも C-RET で慣れてるので使ってない P プロパティ設定 よく使う .</description>
    </item>
    
    <item>
      <title>日報用の設定(旧)</title>
      <link>https://mugijiru.github.io/.emacs.d/org-mode/nippou/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/org-mode/nippou/</guid>
      <description>概要 業務で日報を提出する必要があったのでそれっぽいのを作れるようにしていた。
今では org-super-agenda を使っているのでこれは使ってないが、とりあえず載せておく。
シークレット設定の読み込み 表に出したくない情報については別ファイルに分離して setq している。が、内容的に本名が露出する程度の情報ではある。
(my/load-config &amp;#34;my-nippou-config&amp;#34;) これの中で my/org-nippou-additional-files を定義していてそのファイル名に名前が含まれてるだけであった。
me.org とでもしておけば解決しそう……。
日報構築の対象となるファイルをリストアップする関数の定義 ~/Documenets/org/tasks に作業記録用ファイルなどを find コマンドを使ってリストアップする関数。
(defun my/org-nippou-files () (let* ((dir my/org-tasks-directory) (cmd (format &amp;#34;find \&amp;#34;%s\&amp;#34; -name &amp;#39;*.org&amp;#39; -or -name &amp;#39;*.org_archive&amp;#39;&amp;#34; dir)) (result (shell-command-to-string cmd)) (file-names (split-string result &amp;#34;\n&amp;#34;))) (-remove (lambda (file-name) (string= &amp;#34;&amp;#34; file-name)) file-names))) org-agenda-files を使えば要らないっぽいけどね。 agenda 全然使えてなかったらこんなことに。
日報構築元ファイルを取得する関数の定義 シークレット設定で定義した変数と上で定義した my/org-nippou-files を結合して 1つのリストにするだけの関数を用意している。 1つにまとまってる方が扱いやすいので。
(defun my/org-nippou-targets () (-concat (my/org-nippou-files) my/org-nippou-additional-files)) 日報を出力する関数 上記の関数群で target になるファイルから日報用に TODO 項目を引っ張り出してくる関数を用意している。</description>
    </item>
    
    <item>
      <title>ace-window</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/ace-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/ace-window/</guid>
      <description>概要 Window 間の移動を ace-jump や avy のように表示されてる文字の Window に移動するやつ。
Window が2分割の時は文字も出ないで別の Window に移動してくれる。
C-x o にデフォルトで設定されている other-window は別の window に順番に移動するコマンドなので大量に分割していると移動がしんどいのだが ace-window を使うと起動して 1 ストロークで移動できるので C-x o をデフォルトの other-window から ace-window そのまま置き換えても便利に使える。
インストール いつも通り el-get でインストールしている。
(el-get-bundle ace-window) 設定 キーバインドは別の箇所で定義しているが C-x o で ace-window が起動するようにしている。
また Hydra からは ace-swap-window が起動できるようにしている。
ace-window には色々な機能があるからそれ用の Hydra を別途定義してもいいかもしれない。
ace-window 起動時に選択可能な数字が各 buffer の中央にいい感じに表示されるようにするため ace-window-posfrme-mode を有効にしている
(with-eval-after-load &amp;#39;ace-window (ace-window-posframe-mode t)) </description>
    </item>
    
    <item>
      <title>alert</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/alert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/alert/</guid>
      <description>概要 alert は色々な通知システムに対応した通知を飛ばせるパッケージ。 Mac だと Growl だったり terminal-notifier だったり Win だと toast だったり Linux だと libnotify だったりを使ってその環境での標準的な通知機能を使って通知ができるやつ。
インストール いつも通りに el-get でインストール。
(el-get-bundle alert) 設定 業務では Mac を使ってるので terminal-notifier を設定している。他の環境では libnotify にしている。
(if (or (eq window-system &amp;#39;ns) (eq window-system &amp;#39;mac)) (setq alert-default-style &amp;#39;notifier) ;; use terminal-notifier (setq alert-default-style &amp;#39;libnotify)) 「他の環境」が WSL 上の Emacs と Manjaro 上の Emacs なのだけども、後者は最近使ってないので無視して libnotify で通知するように設定を変えた。
本当は WSL2 でもいい感じに通知されるようにしたいが WSLで通知を出すメモ - cobodoのブログ とかを見てるとちょっと面倒そう。</description>
    </item>
    
    <item>
      <title>all-the-icons</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/all-the-icons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/all-the-icons/</guid>
      <description>概要 all-the-icons は Emacs で様々なアイコンを表示できるようにして華やかにしてくれるパッケージです。 Neotree などでも対応していてアイコンでファイルの種類が表示されるようになってモダンな雰囲気が出ます。
インストール いつも通り el-get-bundle で入れている。明示的に require している理由は忘れました。
(el-get-bundle all-the-icons) (require &amp;#39;all-the-icons) フォントのインストール 以下のコマンドを叩くことでフォントをインストールすることができる。 all-the-icons のインストール直後に叩いておいたら普段は叩かなくて良いはず。
(all-the-icons-install-fonts) all-the-icons の更新後は叩いた方がいいかもしれない
キーバインド キーバインドは覚えられないし、使えるキーも大分埋まってるので、 pretty-hydra を使って all-the-icons 用の Hydra を用意している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define all-the-icons-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;All the icons&amp;#34; :exit t :quit-key &amp;#34;q&amp;#34;) (&amp;#34;Insert&amp;#34; ((&amp;#34;a&amp;#34; all-the-icons-insert-alltheicon &amp;#34;All the icons&amp;#34;) (&amp;#34;f&amp;#34; all-the-icons-insert-fileicon &amp;#34;File icons&amp;#34;) (&amp;#34;F&amp;#34; all-the-icons-insert-faicons &amp;#34;FontAwesome&amp;#34;) (&amp;#34;m&amp;#34; all-the-icons-insert-material &amp;#34;Material&amp;#34;) (&amp;#34;o&amp;#34; all-the-icons-insert-octicon &amp;#34;Octicon&amp;#34;) (&amp;#34;w&amp;#34; all-the-icons-insert-wicon &amp;#34;Weather&amp;#34;) (&amp;#34;*&amp;#34; all-the-icons-insert &amp;#34;All&amp;#34;))))) Key 効果 a all-the-icons で追加されてるアイコンを検索して挿入 f ファイルアイコンを検索して挿入 F FontAwesome アイコンを検索して挿入 m Material アイコンを検索して挿入 o Octicon のアイコンを検索して挿入 w 天気アイコンを検索して挿入 * 全てのアイコンを検索して挿入 フォントのインストールコマンドもここに収めてしまうのが良さそうな気がする</description>
    </item>
    
    <item>
      <title>auth-source</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/auth-source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/auth-source/</guid>
      <description>概要 auth-source は Emacs でパスワードのような秘匿情報を扱うための仕組み。 Emacs の各パッケージが認証情報を要求する時にこいつ経由で取得できるようにしておくと秘匿もできて便利っぽい。
パスワードの保存先はデフォルトだと (&amp;quot;~/.authinfo&amp;quot; &amp;quot;~/.authinfo.gpg&amp;quot; &amp;quot;~/.netrc&amp;quot;) となっている。
拡張子が gpg だと EagyPG Assistant で保存時に暗号化されるので便利。
ファイル指定 自分は Emacs でしか使わないであろう情報ということで /.emacs.d/.authinfo.gpg を指定している。
(custom-set-variables &amp;#39;(auth-sources (quote (&amp;#34;~/.emacs.d/.authinfo.gpg&amp;#34;)))) </description>
    </item>
    
    <item>
      <title>auto-format</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/auto-format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/auto-format/</guid>
      <description>概要 保存時に自動で整形してくれるように fork した auto-fix.el を使っている。
これを入れて各 major-mode で設定をするとファイル保存時に自動で整形してくれて便利だったりする
インストール fork しているので自前で recipe も用意している
(:name auto-fix :website &amp;#34;https://github.com/mugijiru/auto-fix.el&amp;#34; :description &amp;#34;Fix current buffer automatically&amp;#34; :type github :branch &amp;#34;accept-multiple-args&amp;#34; :pkgname &amp;#34;mugijiru/auto-fix.el&amp;#34;) これを以下のようにして el-get でインスコしている
(el-get-bundle auto-fix) </description>
    </item>
    
    <item>
      <title>auto-insert</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/auto-insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/auto-insert/</guid>
      <description>概要 auto-insert はファイルを新規作成した時にファイル名に応じたテンプレートを挿入する機能。
Emacs が標準で持ってるライブラリなのでインストールは不要
設定 Emacs の設定は .emacs.d の中に閉じ込めたいので auto-insert のテンプレートも ~/.emacs.d/insert に閉じ込める設定にしている。
(custom-set-variables &amp;#39;(auto-insert-directory &amp;#34;~/.emacs.d/insert/&amp;#34;)) 有効化 あとは単に有効化している。
(auto-insert-mode 1) 他の設定 ファイル名を正規表現でマッチさせてテンプレートが選択されるので各言語やフレームワーク毎に設定を入れることにしている。
実際は今のところ inits/41-vue.el でのみ追加設定を入れている。</description>
    </item>
    
    <item>
      <title>auto-save</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/auto-save/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/auto-save/</guid>
      <description>概要 編集中状態の自動保存や、編集前や保存直後の状態のバックアップに関する設定をここでは書いている。
Emacs ではデフォルトでも編集中ファイルの自動保存や、編集前の状態の自動バックアップもしてくれるが開いているファイルとは違う場所に保存したりすることで、より便利になるのでいくつかの設定を入れている。
設定 自動保存設定 デフォルトだと #hoge.txt# みたいなファイル名で作られる、自動保存に関する設定。
まあこの自動保存されてやつを活用できてる気がしないのでこの自動保存自体不要な気はしているが、とりあえず場所を移動して邪魔にはならないようにはしている。
自動保存のタイミング 自動保存のタイミングは
auto-save-timeout auto-save-interval で制御されている。
まず auto-save-timeout で設定した秒数が経過すると再度自動保存が実行される。
これがデフォルトだと 30 秒なのだが、ちょっと長いのでその半分の 15 秒で保存されるように設定を変更している。
(setq auto-save-timeout 15) また auto-save-interval で設定した回数のキーイベントが発生すると再度自動保存を実行する。
これもデフォルトだと 300 と結構なキーを叩く必要があるので 60 回としている。
(setq auto-save-interval 60) 自動保存先を変更する 自動保存はそのままだと弄ってるファイルの場所に作られる。が、これは以下のようにすると ~/.emacs.d/backup/ 一応変更可能。
(setq auto-save-file-name-transforms &amp;#39;((&amp;#34;.*&amp;#34; &amp;#34;~/.emacs.d/backup/&amp;#34; t))) ただ、デフォルト値が
((&amp;#34;\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\&amp;#39;&amp;#34; &amp;#34;/tmp/\\2&amp;#34; t)) なので .* にしているのは乱暴そうな気がしている。
というわけで https://masutaka.net/chalow/2014-05-11-1.html に書かれているのを真似して
((&amp;#34;~/\\([^/]*/\\)*\\([^/]*\\)$&amp;#34; &amp;#34;~/.emacs.d/backup/\\2&amp;#34; t)) とでもした方が良いかもしれない。
バックアップファイル 自動保存とは別に、ファイルを開いた時点のバージョンや保存した時点のバージョンを取っておいてくれる自動バックアップ機能もあるのでその設定も弄っている。
バックアップ先のフォルダ指定 デフォルトでは編集しているファイルと同じフォルダにバックアップファイルを作成するようになっている。
だけど、こいつが結構邪魔なのでバックアップファイルは ~/.emacs.d/backup/ に全部保存するようにしている。
また、普段 tramp は使っていないが何かの拍子で使った時にバックアップが取られると邪魔そうなのでそれは保存しないようにしている。</description>
    </item>
    
    <item>
      <title>avy</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/avy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/avy/</guid>
      <description>概要 avy は好きな文字とか単語など、表示されてる場所にさくっとジャンプするためのパッケージ。 Vimium の f とかに似てる。
インストール el-get で普通にインストールしている
(el-get-bundle avy) 設定 文字の上に重なると元の文字列がよくわからなくなるので、移動先の文字の前に表示するようにしている
(setq avy-style &amp;#39;pre) キーバインド グローバルなキーバインドを汚染したくなかったのでひとまず Hydra を定義している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define avy-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;avy&amp;#34; :foreign-key warn :quit-key &amp;#34;q&amp;#34; :exit t) (&amp;#34;Char&amp;#34; ((&amp;#34;c&amp;#34; avy-goto-char &amp;#34;Char&amp;#34;) (&amp;#34;C&amp;#34; avy-goto-char-2 &amp;#34;Char 2&amp;#34;) (&amp;#34;x&amp;#34; avy-goto-char-timer &amp;#34;Char Timer&amp;#34;)) &amp;#34;Word&amp;#34; ((&amp;#34;w&amp;#34; avy-goto-word-1 &amp;#34;Word&amp;#34;) (&amp;#34;W&amp;#34; avy-goto-word-0 &amp;#34;Word 0&amp;#34;)) &amp;#34;Line&amp;#34; ((&amp;#34;l&amp;#34; avy-goto-line &amp;#34;Line&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;r&amp;#34; avy-resume &amp;#34;Resume&amp;#34;))))) Key 効果 c 1文字からの絞り込み C 2文字から絞り込み x 任意の文字列からの絞り込み w 1文字絞り込んで単語先頭に移動 W 絞り込みなしの単語移動 l 列移動 r 繰り返し同じコマンドを実行 </description>
    </item>
    
    <item>
      <title>browse-at-remote</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/browse-at-remote/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/browse-at-remote/</guid>
      <description>概要 browse-at-remote は Emacs で見ているファイルについて GitHub や GitLab などのサービス上での該当ブランチ、該当ファイル、該当行を開いてくれる便利なやつ。
業務だとレビュー中に「ここにこういう関数あるよ」みたいに示すことがあるけどその時に Emacs 内で関数を探して browse-at-remote で GitHub 上の位置を開くことでそこへのリンクを拾いやすく便利。
インストール いつも透り el-get で入れている。
(el-get-bundle browse-at-remote) 使い方 ブラウザで見たい行の上で M-x browse-at-remote を実行する。
または Region を選択している状態で実行すると、その範囲を選択している状態で開いてくれる。便利。
その他 Hydra でいつでも使えるようにキーバインドを割り当てている。</description>
    </item>
    
    <item>
      <title>color-theme-molokai</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/color-theme-molokai/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/color-theme-molokai/</guid>
      <description>概要 color-theme-molokai は多分 vim の molokai をベースにしたテーマ。更に元はどうも TextMate っぽい。
ダークグレイ背景をベースにしたテーマでもう何年もこのテーマを使っている。
インストール いつも通り el-get で入れている。 MELPA に登録されてないのかわからんけど直接 GitHub から入れている。
(el-get-bundle alloy-d/color-theme-molokai) テーマへの PATH を通す インストールしただけでは custom-theme-load-path には追加されないので自分で add-to-list を使って PATH を通している。
(add-to-list &amp;#39;custom-theme-load-path (expand-file-name &amp;#34;~/.emacs.d/el-get/color-theme-molokai&amp;#34;)) テーマの読み込み 最後に load-theme で molokai を読み込んでいる。
(load-theme &amp;#39;molokai t) その他 もう長年これを使っているが、近年ではもっと良いテーマも出ているかもしれないのでそのうち乗り換えるかも。
なんだけど、テーマ乗り換えるのちょっとだるいのよね〜。</description>
    </item>
    
    <item>
      <title>company-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/company-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/company-mode/</guid>
      <description>概要 company-mode は Emacs での補完機能を提供してくれるパッケージです。プラグイン式に拡張しやすいのが特徴っぽい。
インストール いつも透り el-get から入れている
(el-get-bundle company-mode) 設定 ほとんど設定は入れていない。有効な時に C-s を入力すると検索ができる程度。
というのも最近の更新で、デフォルトが結構好みのキーバインドになったのでキーバインドはこだわる必要がなくなったのと、ついでに色もそこで好みな感じになってくれた。
というわけで設定は以下のようにとてもシンプル。
(with-eval-after-load &amp;#39;company ;; active (define-key company-active-map (kbd &amp;#34;C-s&amp;#34;) &amp;#39;company-search-candidates)) それと最近追加された company-show-quick-access を有効にしている。
(custom-set-variables &amp;#39;(company-show-quick-access t)) これを有効にしていると補完候補の末尾に quick access key が表示されて例えば4行目なら 4 とか表示されるのでそこで M-4 とか入力すると4行目が選択されて便利
company-quickhelp company-quickhelp は候補の補足情報が見れるようにするパッケージ。それを入れて、文字色とかぶらないように背景色を設定している。
(el-get-bundle company-quickhelp) (custom-set-variables &amp;#39;(company-quickhelp-color-background &amp;#34;#323445&amp;#34;)) (with-eval-after-load &amp;#39;pos-tip (company-quickhelp-mode 1)) なおレシピは公式ではなかったので自前で用意している
(:name company-quickhelp :description &amp;#34;Adds documentation popup to completion candidates&amp;#34; :type github :pkgname &amp;#34;company-mode/company-quickhelp&amp;#34;) company-posframe company-posframe は company-mode の表示に posframe を使うやつ。</description>
    </item>
    
    <item>
      <title>custom-file</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/custom-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/custom-file/</guid>
      <description>概要 Emacs では customize 機能などで設定したファイルを標準だと init.el の末尾に追記したりするが自動吐き出しされるものがあるとバージョン管理が難しくなるので別ファイルに出力するようにするなどの調整をしている。
出力先の設定 .emacs.d の中に閉じ込めておく方が管理が楽なので出力先として ~/.emacs.d/custom.el を指定している。
(setq custom-file (expand-file-name &amp;#34;~/.emacs.d/custom.el&amp;#34;)) カスタム設定の読み込み 起動時に、設定が入っているファイルが読み込まれないと保存した設定が有効にならないので load を使って読んでいる。
(load custom-file) その他 カスタムファイルは終盤で読み込む方がいいかと思って init-loader では 99 という最後の方で読まれる番号を振っている。
このあたりの設定を個別のパッケージの設定の方に移動したらこのファイルは空にできるんじゃないかなとも思っているが、それはゆっくり対応していくつもり</description>
    </item>
    
    <item>
      <title>dashboard</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/dashboard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/dashboard/</guid>
      <description>概要 emacs-dashboard は Emacs の起動時に色々な情報を表示してくれるパッケージ。
インストール いつも通り el-get で入れている
(el-get-bundle dashboard) 表示するアイコンをロゴに変更 ロゴ、画像にした方がカッコいいよねってことで logo に変更している
(setq dashboard-startup-banner &amp;#39;logo) なお CUI で起動すると自動でテキストでの表示になる
表示する情報の設定 dashboard-items を弄ることで表示する情報を設定している
(setq dashboard-items &amp;#39;((recents . 5) ;; (bookmarks . 5) ;; bookmarks は使ってない (projects . 5) (agenda . 5) ;; (registers . 5) ;; registers は使ってない )) Emacs の bookmarks と register は使ってない(使えてない)のでコメントアウトしている。
あとは最近開いたファイルとプロジェクトとagendaを表示するようにしているがイマイチ活用できてないので色々設定を詰める必要がありそう
各セクションのタイトル部の先頭にアイコンを表示 これは見た目をちょっとだけカッコよくするために all-the-icons で装飾するための設定
(setq dashboard-set-heading-icons t) 各ファイルの先頭にアイコンを表示 これも見た目をちょっとだエカッコよくするために all-the-icons で装飾するための設定。だけどファイルの種類がアイコンでわかるので便利。
(setq dashboard-set-file-icons t) 最後に設定を反映 多分設定を反映するための関数だと思ってる。</description>
    </item>
    
    <item>
      <title>ddskk</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/ddskk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/ddskk/</guid>
      <description>概要 ddskk は Emacs Lisp 版の SKK 実装。
一般的な日本語変換ソフトだと文法を自動で認識して変換をしてくれるけど SKK ではその自動認識がおかしくておかしな変換になるところを、単語の区切りなんかを一切判定せずに人間がそれを教えてあげることで、そういう自動的に変な挙動をしてしまう煩わしさから開放されるようになっている。
インストール いつも通り el-get で入れている。最近は最新版が GitHub で更新されているのでそちらから引っ張られてくる。
(el-get-bundle ddskk) 常時有効化 find-file-hooks で有効化することでファイルを開いた時には常に skk が使える状態にしている。また skk-latin-mode にしておくことで、基本は英語入力ですぐに日本語入力に切り替えられる状態にしている。
(defun my/always-enable-skk-latin-mode-hook () (skk-latin-mode 1)) (add-hook &amp;#39;find-file-hooks &amp;#39;my/always-enable-skk-latin-mode-hook) hook の設定 ddskk が呼び出された時に色々設定されるようにしている。
もしかしたら customize-variable とかあるかもしれないので今度見直した方が良さそう。
(add-hook &amp;#39;skk-load-hook (lambda () ;; コード中では自動的に英字にする。 (require &amp;#39;context-skk) (setq skk-comp-mode t) ;; 動的自動補完 (setq skk-auto-insert-paren t) (setq skk-delete-implies-kakutei nil) (setq skk-sticky-key &amp;#34;;&amp;#34;) (setq skk-henkan-strict-okuri-precedence t) (setq skk-show-annotation t) ;; 単語の意味をアノテーションとして表示。例) いぜん /以前;previous/依然;still/ (setq skk-compare-jisyo-size-when-saving nil) (setq skk-extra-jisyo-file-list `(,(expand-file-name &amp;#34;~/.</description>
    </item>
    
    <item>
      <title>dumb-jump</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/dumb-jump/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/dumb-jump/</guid>
      <description>概要 dumb-jump は関数とかの定義されてる場所にお手軽にジャンプできるようにするパッケージ。めっちゃ色々な言語をサポートしている。
インストール いつも通り el-get でインストールしている。
(el-get-bundle dumb-jump) 設定 デフォルトプロジェクトの変更 デフォルトだと ~/ がデフォルトプロジェクトらしいがそんなに上の階層から調べられてもしょうがない気がするのでソースコードを置いているフォルダを指定している。
(setq dumb-jump-default-project &amp;#34;~/projects&amp;#34;) 複数マッチした時に使う絞り込み 最近はできるだけ ivy を使うようにしているので dumb-jump でも ivy を使うように指定している。
(setq dumb-jump-selector &amp;#39;ivy) キーバインド README に書いている hydra の設定をほぼパクってるけど pretty-hydra を使ってキーを定義している
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define dumb-jump-pretty-hydra (:foreign-keys warn :title &amp;#34;Dumb jump&amp;#34; :quit-key &amp;#34;q&amp;#34; :color blue :separator &amp;#34;-&amp;#34;) (&amp;#34;Go&amp;#34; ((&amp;#34;j&amp;#34; dumb-jump-go &amp;#34;Jump&amp;#34;) (&amp;#34;o&amp;#34; dumb-jump-go-other-window &amp;#34;Other window&amp;#34;)) &amp;#34;External&amp;#34; ((&amp;#34;e&amp;#34; dumb-jump-go-prefer-external &amp;#34;Go external&amp;#34;) (&amp;#34;x&amp;#34; dumb-jump-go-prefer-external-other-window &amp;#34;Go external other window&amp;#34;)) &amp;#34;Lock&amp;#34; ((&amp;#34;l&amp;#34; dumb-jump-quick-look &amp;#34;Quick look&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;b&amp;#34; dumb-jump-back &amp;#34;Back&amp;#34;))))) Key 効果 j 定義場所にジャンプ o 定義場所を別 window で開く e 定義場所にジャンプ。ただし同じファイルより外部ファイルとのマッチを優先 x 定義場所を別 window で開く。ただし同じファイルより外部ファイルとのマッチを優先 l クイックルック。定義をツールチップ表示する b 最後にジャンプされた場所に戻る。今は既に obsolute 扱い </description>
    </item>
    
    <item>
      <title>emacs-lisp</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/emacs-lisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/emacs-lisp/</guid>
      <description>概要 Emacs Lisp を書くための設定。まあそんなにしっかり書いてないので、あんまり設定は入ってない
Hook Hook 用の関数を定義してその中に色々書いている。
とりあえず行数表示が欲しいので display-line-numbers-mode を有効化 当然補完もしたいので company-mode を有効にしている カッコの対応などもいい感じに動いて欲しいので smartparens-mode とその strict-mode を有効にしている (defun my/emacs-lisp-mode-hook () (display-line-numbers-mode 1) (origami-mode 1) (company-mode 1) (smartparens-mode 1) (turn-on-smartparens-strict-mode)) そんで最後にその関数を hook に突っ込んでる。
(add-hook &amp;#39;emacs-lisp-mode-hook &amp;#39;my/emacs-lisp-mode-hook) アイコン挿入コマンドの用意 時々 UI 設定目的で絵文字を使うことがあるので挿入できるコマンドを用意している。最近使った記憶ないけど。
(defun my/insert-all-the-icons-code (family) (interactive) (let* ((candidates (all-the-icons--read-candidates-for-family family)) (prompt (format &amp;#34;%s Icon: &amp;#34; (funcall (all-the-icons--family-name family)))) (selection (completing-read prompt candidates nil t))) (insert &amp;#34;(all-the-icons-&amp;#34; (symbol-name family) &amp;#34; \&amp;#34;&amp;#34; selection &amp;#34;\&amp;#34;)&amp;#34;))) キーバインド emacs-lisp-mode 用に major-mode-hydra を設定している。けどそんなにしっかり Emacs Lisp を書いてるわけではないのがバレバレな感じである。</description>
    </item>
    
    <item>
      <title>emacs-w3m</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/emacs-w3m/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/emacs-w3m/</guid>
      <description>概要 w3m という和製のテキストブラウザを Emacs 上で使うためのパッケージ。つまり w3m 自体もインストールしておく必要がある。
インストール emacs-w3m は el-get で入れられるので以下のようにして入れている
(el-get-bundle emacs-w3m) 今はこれだけしか入れてない。昔の設定はどこかにいっちゃった……。</description>
    </item>
    
    <item>
      <title>Ember.js</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/ember-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/ember-js/</guid>
      <description>概要 Ember.js 用の Emacs の拡張としては ember-mode と handlebars-mode が存在する
ember-mode unused ember-mode は Ember.js アプリケーションのファイルナビゲーションや生成を行ってくれるモード。実は麦汁さんは使えてない。
インストールするだけではダメで、 ember-mode を明示的に起動しないといけない。
そのためには dir-locals を使うとか projectile なんかがやってるようにフォルダ構成から判定させるみたいなことが必要そう。だるい。
というわけで死蔵中。
ついでにいうとキーバインドもだるい系なので使う時は Hydra を用意した方が良さそう
インストールは GitHub からできるが el-get.lock を用いたバージョン更新確認スクリプトのためレシピを追加している
(:name madnificent/ember-mode :website &amp;#34;https://github.com/madnificent/ember-mode&amp;#34; :description &amp;#34;Ember-mode speeds up navigation in EmberJS projects.&amp;#34; :type github :pkgname &amp;#34;madnificent/ember-mode&amp;#34;) このレシピを用意した上で以下でインストール
(el-get-bundle ember-mode) handlebars-mode improvement handlebars-mode は Ember.js のテンプレートエンジンとして採用されている Handlebars を書くためのモード。
syntax highlight と、いくつかの編集機能を備えている。が、今のところ麦汁さんは syntax highlight しか使えてない。
編集コマンドは major-mode-hydra で使えるようにしてあげれば良さそう
(el-get-bundle handlebars-mode) </description>
    </item>
    
    <item>
      <title>emojify</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/emojify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/emojify/</guid>
      <description>概要 emojify は :smile: のような入力を笑顔の絵文字が表示されたりするようにするパッケージ。
文書を書く時に emojify で絵文字に置き換わるような文字列を入れておくと文書が華やかになって良いぞ!
インストール いつも通り el-get で入れている。何か依存でもあるのが別途 dash.el も読み込んでる。
(el-get-bundle emojify) (el-get-bundle dash) dash.el は他でも使うので、ライブラリの読み込みのところで対応した方が良さそうだな。今度対応しよう。
有効化 emojify がグローバルに有効になるようにしている。
mode-line でも有効になるようにしているので mode-line のカスタマイズ時に emojify で装飾することもできる。今そんなことやってないけど。
(global-emojify-mode 1) (global-emojify-mode-line-mode 1) </description>
    </item>
    
    <item>
      <title>es6</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/es6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/es6/</guid>
      <description>概要 ES5 以前ではない JS を書くための設定。 es6 といいつつ ES2016(ES7) などもこの設定のまま書いている。
sprockets-es6 を使って ES6 対応をしていた時に es6 という拡張子を使っていたのでこのファイル名になっている。
インストール es6 はつまり JS なのでとりあえず el-get で js2-mode を入れている。
(el-get-bundle js2-mode) Hook flycheck を有効にしてリアルタイムに文法チェックをしている また javascript-eslint を使いたいので他2つは disable にしている company-mode で補完できるようにしている smartparens-strict-mode でカッコなどの入力補助をしている インデントは空白2文字としている (defun my/js2-mode-hook () (flycheck-mode 1) (setq flycheck-disabled-checkers &amp;#39;(javascript-standard javascript-jshint)) (company-mode 1) (turn-on-smartparens-strict-mode) (setq js2-basic-offset 2)) という Hook 用関数を用意しておいて
(add-hook &amp;#39;js2-mode-hook &amp;#39;my/js2-mode-hook) という感じで js2-mode-hook に追加している。
Lambda で一括でやる方法もあるけども、関数名つけて分離しておくと中身を簡単に入れ替えられて便利。
es6 を js2-mode で扱うようにする (add-to-list &amp;#39;auto-mode-alist &amp;#39;(&amp;#34;\\.</description>
    </item>
    
    <item>
      <title>esa.el</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/esa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/esa/</guid>
      <description>概要 esa.el は esa.io と連携するためのパッケージ。大体直接 Web で書くので活用はできてない……
インストール・設定 いつも通り el-get で入れている。
設定は別ファイルに分離している。authinfo に移動したい
(el-get-bundle esa) (my/load-config &amp;#34;my-esa-config&amp;#34;) </description>
    </item>
    
    <item>
      <title>exec-path</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/exec-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/exec-path/</guid>
      <description>概要 Emacs は通常最小限の環境変数しか利用しないようになっている。
が、それだと普段使う上で「ああ、このコマンドが使えなくてもどかしい……!」と感じてしまう。
そこで exec-path-from-shell というのを使って Emacs が見える PATH 環境変数をシェルが見てる PATH 環境変数と揃うようにしている。
インストール いつも通り el-get からインストールしている
(el-get-bundle exec-path-from-shell) 有効化 理由は忘れたが Mac の環境でのみ有効化している。その内 Linux 環境でも有効化を試みた方が良さそう
(when (memq window-system &amp;#39;(mac ns)) (exec-path-from-shell-initialize)) なお、これでシェルと共通の環境変数が使われるようになるのは デフォルトでは PATH と MANPATH のみである
その他 なぜか以下のようなコメントを書いていた。普段使っている zsh で持ってる PATH は使わないのだろうか? :thinking_face:
;; for exec path ;; use .bashrc setted path </description>
    </item>
    
    <item>
      <title>flycheck</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/flycheck/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/flycheck/</guid>
      <description>概要 flycheck はリアルタイムで文法チェックなんかをするのに便利なモード。 flymake よりモダンなやつだったんだけど最近は flymake に戻る人もいるっぽいのでどっちが良いかよくわかってない
インストール flycheck と同時にカーソルのそばに pos-tip で通知内容を表示してくれる flycheck-pos-tip をインストールしている
(el-get-bundle flycheck) (el-get-bundle flycheck-pos-tip) 設定 flycheck を読んだ後で flycheck-pos-tip-mode が有効になるようにしている。これは公式に書かれているやりかたに則っている https://github.com/flycheck/flycheck-pos-tip#installation
また web-mode はデフォルトでは flycheck が使えないので flycheck-add-mode を使って web-mode でも flycheck が使えるようにしている
(with-eval-after-load &amp;#39;flycheck (flycheck-pos-tip-mode) (flycheck-add-mode &amp;#39;javascript-eslint &amp;#39;web-mode)) その他 flycheck-posframe flycheck-pos-tip は flycheck 公式のプラグインなので採用しているけど同じことを posframe でやってくれる flycheck-posframe に置き換えた方が見た目麗しくなりそうな気がしている。
言語毎の設定 各言語向けの設定もあるけどそれは各言語の設定ファイル内に書いているのでここでは書いてない
プログラミング関係の設定 &amp;gt; ruby とか プログラミング関係の設定 &amp;gt; scss とかに書いているはず</description>
    </item>
    
    <item>
      <title>font-config</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/font-config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/font-config/</guid>
      <description>概要 Emacs で利用するフォントの設定。それなりの設定をしないとガタついたりするので通常あまり手を入れないで済ませている。
設定 Mac では 14, それ以外(Linux) では 18 を基準としている。
Mac と Linux で基準のサイズを変えているがなぜかこの方がガタガタもしないし大き過ぎもしないしでいい感じになる。
といいつつ元々 Linux の方は WSL2 環境に合わせて 12 にしていたが Manjaro 環境に合わせて 18 に変更しているのでまたその内 WSL2 でも Manjaro でもどっちいい感じに使えるように調整するかもしれない
(defun my/set-font-size (size) (let* ((asciifont &amp;#34;Ricty Diminished&amp;#34;) ; ASCII fonts (jpfont &amp;#34;Ricty Diminished&amp;#34;) ; Japanese fonts (h (* size 10)) (fontspec (font-spec :family asciifont)) (jp-fontspec (font-spec :family jpfont))) (set-face-attribute &amp;#39;default nil :family asciifont :height h) (set-fontset-font nil &amp;#39;japanese-jisx0213.2004-1 jp-fontspec) (set-fontset-font nil &amp;#39;japanese-jisx0213-2 jp-fontspec) (set-fontset-font nil &amp;#39;katakana-jisx0201 jp-fontspec) (set-fontset-font nil &amp;#39;(#x0080 .</description>
    </item>
    
    <item>
      <title>forge</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/forge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/forge/</guid>
      <description>概要 forge は magit と github を連携させるやつ。一応入れているけど実は使えてないのであまりこの設定を呼んでも意味はなさそう
インストール いつも通り el-get でインストールする。ただし依存関係で必要なので emacs-sqlite3-api も合わせて入れている
(el-get-bundle emacs-sqlite3-api) (el-get-bundle forge) 読み込み magit の拡張なので magit を読み込んで後に読み込まれるようにしている。依存で必要な sqlite3 も合わせて require している。
(with-eval-after-load &amp;#39;magit (require &amp;#39;sqlite3) (require &amp;#39;forge)) flycheck の有効化 Pull Request を作る時に text-lint で指摘されたいのでそのタイミングで flycheck を有効化している
(defun my/forge-post-mode-hook () (flycheck-mode 1)) (with-eval-after-load &amp;#39;forge (add-hook &amp;#39;forge-post-mode-hook &amp;#39;my/forge-post-mode-hook)) その他 リポジトリのコミット数が多いとまともに使えない感じだけどどうしたらいいの。</description>
    </item>
    
    <item>
      <title>frame-cmds</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/frame-cmds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/frame-cmds/</guid>
      <description>概要 frame-cmds は Emacs のフレーム操作に関するコマンド集。上下左右に移動したり広げたりといったことができる。いや、他にもできそうなんだけど、私がそれを把握してない。
インストール el-get で以下のように書くと emacswiki からインストールされる。
(el-get-bundle frame-cmds) キーバインド 無論キーバインドは覚えられないので以下のように Hydra で定義している
(pretty-hydra-define window-control-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;Window Control&amp;#34; :exit nil :quit-key &amp;#34;q&amp;#34;) (&amp;#34;Move&amp;#34; ((&amp;#34;h&amp;#34; move-frame-left &amp;#34;Left&amp;#34;) (&amp;#34;j&amp;#34; move-frame-down &amp;#34;Down&amp;#34;) (&amp;#34;k&amp;#34; move-frame-up &amp;#34;Up&amp;#34;) (&amp;#34;l&amp;#34; move-frame-right &amp;#34;Right&amp;#34;)) &amp;#34;Resize&amp;#34; ((&amp;#34;H&amp;#34; shrink-frame-horizontally &amp;#34;H-&amp;#34;) (&amp;#34;J&amp;#34; enlarge-frame &amp;#34;V+&amp;#34;) (&amp;#34;K&amp;#34; shrink-frame &amp;#34;V-&amp;#34;) (&amp;#34;L&amp;#34; enlarge-frame-horizontally &amp;#34;H+&amp;#34;)))) Key 効果 h 左に移動 j 下に移動 k 上に移動 l 右いん移動 H 左右方向に縮める J 上下方向に広げる K 上下方向に縮める L 左右方向に広げる </description>
    </item>
    
    <item>
      <title>fullscreen</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/fullscreen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/fullscreen/</guid>
      <description>概要 起動時にフルスクリーンにする設定はここにまとめている
Mac の設定 Mac の場合にフルスクリーンにする設定を入れていた。けど 2020-01-08 に yabai WM を導入したことにより起動時はフルスクリーンじゃない方がよくなったので以下の処理は今は使ってない。
(if (or (eq window-system &amp;#39;ns) (eq window-system &amp;#39;mac)) (add-hook &amp;#39;window-setup-hook (lambda () (set-frame-parameter nil &amp;#39;fullscreen &amp;#39;fullboth)))) WSL の設定 X Window system の場合かつ WSLENV という環境変数が設定されている場合にはフルスクリーンにする。新しく Linux マシンを導入したらこれの影響を受けていたので後から WSLENV による判定を追加した次第。
(if (and (eq window-system &amp;#39;x) (getenv &amp;#34;WSLENV&amp;#34;)) (add-hook &amp;#39;window-setup-hook (lambda () (set-frame-parameter nil &amp;#39;fullscreen &amp;#39;fullboth) (set-frame-position nil 0 0)))) 微妙に画面の下の方がちゃんとフルになってくれてないけどそこは今は我慢して使っている。ちなみにその病はどうやら WSLg になっても残りそう。 https://w.atwiki.jp/ntemacs/pages/69.html</description>
    </item>
    
    <item>
      <title>git-gutter-fringe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/git-gutter-fringe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/git-gutter-fringe/</guid>
      <description>概要 git-gutter-fringe は git-gutter の派生版。最後のコミットからどの行を弄ったかを fringe 領域に表示してくれる。
他にも hunk の操作をできる機能とかあるみたいだけどそのあたりは使ったことがない……。
派生元の git-gutter は linum-mode と同じ領域を使って描画をしているようで併用ができなかったので git-gutter-fringe を利用している。
が、Emacs 26 から display-line-numbers-mode が搭載されて linum-mode が不要になったので git-gutter に乗り換えても良さそう
インストール いつも通り el-get でインストールしている
(el-get-bundle git-gutter-fringe) 有効化 Git 管理しているやつは全部差分情報が表示されて欲しいのでグローバルマイナーモードを有効にしている。
(global-git-gutter-mode t) その他 git-gutter ほどではないけど多少のカスタマイズはできるはずだがデフォルト設定で特に不満はないので何もしてない</description>
    </item>
    
    <item>
      <title>gnuplot-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/gnuplot-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/gnuplot-mode/</guid>
      <description>概要 gnuplot-mode はグラフ作成ソフトである gnuplot を Emacs で使うためのパッケージ。 Syntax Highlight や 補完機能 などを提供する。
まあほとんど使ってないんだけど。
インストール レシピは自前で用意している
(:name gnuplot-mode :description &amp;#34;Drive gnuplot from within emacs&amp;#34; :type github :pkgname &amp;#34;emacs-gnuplot/gnuplot&amp;#34; :branch &amp;#34;main&amp;#34; :build `((&amp;#34;make&amp;#34; ,(concat &amp;#34;EMACS=&amp;#34; el-get-emacs)))) そしていつも通り el-get で入れている
(el-get-bundle gnuplot-mode) その他 org-mode から使ってた記憶があるのでそっちの方で何か設定があるかもしれない</description>
    </item>
    
    <item>
      <title>Google 連携</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/google-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/google-integration/</guid>
      <description>概要 Google と連携するパッケージとして google-this と google-translate を入れているが、どっちも Google を使うので1つの Hydra にまとめていた方が扱いやすいと思って統合している
キーバインド (with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define google-pretty-hydra (:foreign-keys warn :title &amp;#34;Google&amp;#34; :quit-key &amp;#34;q&amp;#34; :color blue :separator &amp;#34;-&amp;#34;) (&amp;#34;Current&amp;#34; ((&amp;#34;SPC&amp;#34; google-this-noconfirm &amp;#34;No Confirm&amp;#34;) (&amp;#34;RET&amp;#34; google-this &amp;#34;Auto&amp;#34;) (&amp;#34;w&amp;#34; google-this-word &amp;#34;Word&amp;#34;) (&amp;#34;l&amp;#34; google-this-line &amp;#34;Line&amp;#34;) (&amp;#34;s&amp;#34; google-this-symbol &amp;#34;Symbol&amp;#34;) (&amp;#34;r&amp;#34; google-this-region &amp;#34;Region&amp;#34;) (&amp;#34;e&amp;#34; google-this-error &amp;#34;Error&amp;#34;)) &amp;#34;Feeling Lucky&amp;#34; ((&amp;#34;L&amp;#34; google-this-lucky-search &amp;#34;Lucky&amp;#34;) (&amp;#34;i&amp;#34; google-this-lucky-and-insert-url &amp;#34;Insert URL&amp;#34;)) &amp;#34;Translate&amp;#34; ((&amp;#34;t&amp;#34; google-translate-at-point &amp;#34;EN =&amp;gt; JP&amp;#34;) (&amp;#34;T&amp;#34; google-translate-at-point-reverse &amp;#34;JP =&amp;gt; EN&amp;#34;)) &amp;#34;Tool&amp;#34; ((&amp;#34;W&amp;#34; google-this-forecast &amp;#34;Weather&amp;#34;))))) Key 効果 SPC 確認なしで検索 RET どの範囲の情報で検索するか自動判定して検索 w 近くの単語で検索 l その行の内容で検索。エラーの検索とかに良いかも s シンボルで検索。使うのは Emacs Lisp の関数調べる時ぐらいか?</description>
    </item>
    
    <item>
      <title>google-this</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/google-this/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/google-this/</guid>
      <description>概要 google-this は Google 検索を Emacs の中から行えるやつ。
インストール いつも通り el-get でインストール
(el-get-bundle google-this) で、本来の使い方だとこのあとに
(google-this-mode 1) とやって有効化することになるがそれをしても google-this のデフォルトキーバインドが設定されるぐらいで自分はそのデフォルトキーバインドを使う気がないので有効化はしてない。
キーバインド キーバインドは Hydra で設定しているが、 google-translate と統合したので キーバインド &amp;gt; Google 連携 に記載している。</description>
    </item>
    
    <item>
      <title>google-translate</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/google-translate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/google-translate/</guid>
      <description>概要 google-translate は Google 翻訳する機能を提供するパッケージ。
インストール レシピは自前で用意している
(:name google-translate :description &amp;#34;Emacs interface to Google Translate&amp;#34; :type github :pkgname &amp;#34;atykhonov/google-translate&amp;#34;) そして el-get でインストール
(el-get-bundle google-translate) 関数のオーバーライド どうも最新版でも壊れっぱなしのようなので https://github.com/atykhonov/google-translate/issues/52#issuecomment-727920888 にあるように関数を上書きしている。
(with-eval-after-load &amp;#39;google-translate-tk (defun google-translate--search-tkk () &amp;#34;Search TKK.&amp;#34; (list 430675 2721866130))) google-translate-tk に定義されていて、それが読まれた後に上書きしないといけないので with-eval-after-load を使っている。
default-ui の読み込み Google Translate は UI を defauult と smooth のどちらかから選べるようになっている。
default だと
google-translate-default-source-language google-translate-default-target-language を設定しておいて
M-x google-translate-at-point source → target の翻訳 M-x google-translate-at-point-reverse target → source の翻訳 という使い方をする。</description>
    </item>
    
    <item>
      <title>helm</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/helm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/helm/</guid>
      <description>概要 helm は anything.el の後継であり、インクリメンタルに候補の絞り込みをしたりする UI を提供する便利なパッケージ。
peco とか fzf とかと似ているっちゃ似ているかな? fzf 使ったことないけど。
一時期開発が止まってるようだったけど最近(2021年)はまた更新が活発になっている。
ただ、麦汁さんは ivy に乗り換えようとしているので helm の設定は頑張っていない。 helm-for-files が便利なのでまだ捨てられてないけど……。
インストール helm で使いたい拡張として helm-descbinds と helm-ag というのがあるのでそれらも同時に入れている。
(el-get-bundle helm) (el-get-bundle helm-descbinds) (el-get-bundle helm-ag) ただ descbinds は counsel-descbinds に置き換えたし helm-ag ももう使ってない気がする
設定 オススメの設定が helm に同梱されている helm-config に入ってるのでまずはそれを読み込んでいる。
(require &amp;#39;helm-config) また helm-descbinds を使えるように有効にしている。けど、上にも書いたけどもう counsel-descbinds に置き換えちゃったのよね……。
(helm-descbinds-mode) あとは helm-migemo-mode というのを有効にしている。これがあると helm で検索する時に migemo れて便利。
(helm-migemo-mode 1) ivy の方でも migemo 対応したいけどまだできてない……。
その他 helm 系の設定は他の設定にも色々影響も大きそうなので読み込み順は結構早いタイミングにしている(init-loader で 20 を prefix にしている)</description>
    </item>
    
    <item>
      <title>helm-posframe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/helm-posframe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/helm-posframe/</guid>
      <description>概要 helm-posframe は helm の拡張で Helm のバッファの表示を posframe を使うようにしてくれるやつ。
実は helm 本体の方でも posframe 対応しているのであまり使う必要もなさそうなのでいずれ外すかもしれない。
ただ確か本体の方の挙動が気に入らなかったような気はする。
インストール いつも通り el-get でインストール。 GitHub にあるのでそれを取得するようにしている。
(el-get-bundle tumashu/helm-posframe) 有効化 (helm-posframe-enable) </description>
    </item>
    
    <item>
      <title>highlight-indent-guides</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/highlight-indent-guides/</guid>
      <description>概要 highlight-indent-guides はインデント毎にラインを引いたりして見易くしてくれるパッケージ。通常のプログラムを書く時にも便利だけど、 YAML などのインデントがそのまま構造になるような言語を弄る時にとても便利。
インストール これもいつも通り el-get でインストールしている。 GitHub にあるのでそこを直接指定してインストールもできるのだけど el-get.lock からアップデートをチェックする都合上、レシピを用意してそれを使ってインストールしている
(:name highlight-indent-guides :website &amp;#34;https://github.com/DarthFennec/highlight-indent-guides&amp;#34; :description &amp;#34;This minor mode highlights indentation levels via font-lock&amp;#34; :type github :pkgname &amp;#34;DarthFennec/highlight-indent-guides&amp;#34;) (el-get-bundle highlight-indent-guides) 設定 improvement 今いる行がどのインデントにいるのかをわかりやすくするために responsive モードを有効にしている。
(setq highlight-indent-guides-responsive &amp;#34;stack&amp;#34;) defcustom で定義されてる変数なので custom-set-variables で設定した方がいいかもしれない。</description>
    </item>
    
    <item>
      <title>hydra</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/hydra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/hydra/</guid>
      <description>概要 Hydra は Emacs の貴重なキーバインドを節約できる便利なパッケージ。
自分で定義した各 Hydra コマンドを実行するとそれに紐付くサブコマンドとそれらのキーバインド一覧を表示させることができるというやつ。
インストール Hydra 本体と関連パッケージをここでインスコしている
Hydra 本体のインストール Hydra 本体は el-get で普通に入れている
(el-get-bundle hydra) hydra-posframe のインストール Hydra は通常だと minibuffer あたりに表示されるけど画面の真ん中に表示される方が視線移動が少なくて便利なので hydra-posframe を使って画面中央に表示されるようにしている。
インストールはいつも通り el-get で行っている。
(el-get-bundle hydra-posframe) そして Emacs の初期化処理が完了したタイミングでそれが使われるように after-init-hook で hydra-posframe を有効化している
(add-hook &amp;#39;after-init-hook &amp;#39;hydra-posframe-enable) WebDAV Sync download の設定 作業管理用の org-mode のドキュメントは WebDAV サーバにも上げて beorg でも使えるようにしているがそれを拾って来るためのコマンドを用意している。
(defun my/download-from-beorg () (interactive) (async-shell-command &amp;#34;java -jar ~/bin/webdav_sync1_1_9.jar -c ~/.config/webdav-sync/download.xml &amp;amp;&amp;amp; notify-send &amp;#39;WebDAV Sync&amp;#39; &amp;#39;Downloaded from WebDAV&amp;#39;&amp;#34;)) 簡単に async-shell-command を使って済ませている</description>
    </item>
    
    <item>
      <title>ido-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/ido-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/ido-mode/</guid>
      <description>概要 Emacs に標準添付の補完インターフェース。 ivy 使ってるからこれ有効化している意味がない気はする。
拡張入れてない段階でもこいつを有効にしていると find-file とかが楽になって良い。
有効化 とりあえず昔からずっと有効化している
(ido-mode 1) 設定 ファイル名の補完とかを曖昧一致を有効にするっぽいい。
(setq ido-enable-flex-matching t) その他 https://qiita.com/tadsan/items/33ebb8db2271897a462b に書いていることだけど
ido-everywhere を有効にするとファイル名とバッファ切替以外にも使えるようになるらしい smex 入れると M-x が強化される ido-ubiquitous を入れると ido-everywhere よりもさらに色々な他に使えるらしい ido-vertical-mode を入れたら候補が縦並びになって便利っぽい </description>
    </item>
    
    <item>
      <title>ivy</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/ivy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/ivy/</guid>
      <description>概要 インストール el-get を使って GitHub のリポジトリから直で入れている。
(el-get-bundle abo-abo/swiper) ;; ivy, swiper, counsel が同時に入って来る MELPA 経由だと org-mode 関係のパッケージ周りでハマったことがあるので GitHub から直で入れる運用にしている。
が、やっぱり MELPA とかに寄せるべきかなって気になってきているところだったりもする。
なんか設定 便利に使えるようにするための設定を書いている。が、何を設定しているのかよく覚えてないので今度調べておこう……
(when (require &amp;#39;ivy nil t) ;; M-o を ivy-dispatching-done-hydra に割り当てる． (require &amp;#39;ivy-hydra) ;; `ivy-switch-buffer&amp;#39; (C-x b) のリストに recent files と bookmark を含める． (setq ivy-use-virtual-buffers t) ;; ミニバッファでコマンド発行を認める (when (setq enable-recursive-minibuffers t) (minibuffer-depth-indicate-mode 1)) ;; 何回層入ったかプロンプトに表示． ;; ESC連打でミニバッファを閉じる (define-key ivy-minibuffer-map (kbd &amp;#34;&amp;lt;escape&amp;gt;&amp;#34;) &amp;#39;minibuffer-keyboard-quit) ;; (index/総数) 表示で何番目の候補かわかりやすくする (setq ivy-count-format &amp;#34;(%d/%d) &amp;#34;) ;; アクティベート (ivy-mode 1)) counsel の有効化 counsel は ivy で提供されているやつで、既存の Emacs のコマンドを置き換えてくれるやつ。</description>
    </item>
    
    <item>
      <title>key-chord</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/key-chord/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/key-chord/</guid>
      <description>概要 key-chord はキーを同時に押した時にコマンドを発動させるということができるようにしてくれるパッケージ。
なのですが本家の方だと誤爆が多いということなのでそれを改善した zk-phi/key-chord の方を利用している。
まあほとんど使えてないので改良版の恩恵をまだ受けてないけど……。
インストール いつも通り el-get でインストールしている。本家の方じゃないので GitHub のリポジトリから突っ込んでいる。
(el-get-bundle zk-phi/key-chord) 設定 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。
(setq key-chord-two-keys-delay 0.25 key-chord-safety-interval-backward 0.1 key-chord-safety-interval-forward 0.15) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。
改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動に使っている上に Hydra で叩けるやつでよく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。
有効化 設定を入れた後は有効にするだけである。
(key-chord-mode 1) 実際のキーバインド設定は各モードだったりグローバルキーバインドを設定しているファイルだったりで書く感じ。
といいつつ現状では Hydra 起動のやつしか使ってないので、グローバルキーバインド設定でしか書いてない。
sticky-shift セミコロン2つでシフトを押した状態にする セミコロンを2回叩くことで shift が押されてるという状態を実現する。
これにより magit で P などを入力したい時にも ;;p で入力できるし通常の英字入力時にも大文字にできるので左手小指が痛い時には Shift を使わずに操作ができるようになる。
(key-chord-define-global &amp;#34;;;&amp;#34; &amp;#39;event-apply-shift-modifier) (key-chord-define key-translation-map &amp;#34;;;&amp;#34; &amp;#39;event-apply-shift-modifier) global-key-map と key-translation-map の両方に定義しないと動かないがその原因はよく分かってない。一旦動くから良しとしている。</description>
    </item>
    
    <item>
      <title>load-path</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/load-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/load-path/</guid>
      <description>概要 load-path は Emacs の設定でも重要な項目でこのリストに追加されている path は load または require する際に走査される path となっている。
即ち load-path を通しておけば、そこに置いている emacs lisp のファイルは簡単に読み出せるようになる。
なお package-install や el-get を使っておけば基本的に自分で load-path を通す必要はない。
秘匿情報を入れてるフォルダを読み込み可能にする パスワードなどの秘匿情報を持っている部分は ~/.emacs.d/secret というフォルダで管理している。そのためここに入ってる emacs lisp のファイルも読み込めるように load-path に追加している。
(add-to-list &amp;#39;load-path (expand-file-name &amp;#34;~/.emacs.d/secret&amp;#34;)) my/load-config ~/.emacs.d/secret は個人マシンか会社マシンかによって置いてるデータが異なったりするためもしもファイルがなくてもエラーにならないような方法で load する方法が必要だった。
というわけでファイルがなかったら読み込まずにメッセージを出力して終了するような関数を用意している。
(defun my/load-config (file) (condition-case nil (load file) (file-missing (message &amp;#34;Load error: %s&amp;#34; file)))) ただ、これって結局
(load file nil t) で十分な気もするので、置き換えを検討した方が良さそう。</description>
    </item>
    
    <item>
      <title>lsp-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/lsp-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/lsp-mode/</guid>
      <description>概要 lsp-mode は Emacs で Language server protocol が使えるようにするパッケージ。
より軽そうなやつに eglot というのもあるがこっちは試したことがない。
インストール lsp-mode 本体と UI 周りを担当する lsp-ui-mode の両方をインストールしている。また lsp-mode が有効になる際に lsp-ui-mode も同時に有効になるようにしている。
(el-get-bundle lsp-mode) (el-get-bundle lsp-ui) (add-hook &amp;#39;lsp-mode-hook &amp;#39;lsp-ui-mode) カスタム変数 lsp-ui-doc はカーソル位置にある変数や関数などの説明を child frame で表示してくれるやつ。
これがデフォルトではフレーム基準で右上に表示するのだが大きめの画面を分割して使っていると大分遠くに表示されてしまうので window 基準で表示するように設定を変更している
(custom-set-variables &amp;#39;(lsp-diagnostics-provider :flycheck) &amp;#39;(lsp-ui-doc-show-with-cursor t) &amp;#39;(lsp-ui-doc-alignment &amp;#39;window)) パッチ 文字を拡大している時の折り返しがおかしくならないようにするパッチ
;; Patch ;; https://github.com/emacs-lsp/lsp-ui/issues/184#issuecomment-1158057166 (with-eval-after-load &amp;#39;lsp-ui-sideline (defun lsp-ui-sideline--align (&amp;amp;rest lengths) &amp;#34;Align sideline string by LENGTHS from the right of the window.&amp;#34; (cons (+ (apply &amp;#39;+ lengths) (if (display-graphic-p) 1 2)) &amp;#39;width)) (defun lsp-ui-sideline--compute-height () nil)) Hydra の設定 (with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define pretty-hydra-lsp (:separator &amp;#34;-&amp;#34; :color blue :foreign-keys warn :title &amp;#34;LSP&amp;#34; :quit-key &amp;#34;q&amp;#34;) (&amp;#34;Find&amp;#34; ((&amp;#34;x&amp;#34; lsp-find-definition &amp;#34;definition&amp;#34;) (&amp;#34;r&amp;#34; lsp-find-references &amp;#34;references&amp;#34;) (&amp;#34;t&amp;#34; lsp-find-type-definition &amp;#34;type&amp;#34;) (&amp;#34;i&amp;#34; lsp-find-implementation &amp;#34;implementation&amp;#34;) (&amp;#34;D&amp;#34; lsp-find-declaration &amp;#34;declaration&amp;#34;)) &amp;#34;Code&amp;#34; ((&amp;#34;m&amp;#34; lsp-rename &amp;#34;Rename&amp;#34;)) &amp;#34;UI&amp;#34; ((&amp;#34;I&amp;#34; lsp-ui-imenu &amp;#34;imenu&amp;#34;) (&amp;#34;X&amp;#34; lsp-ui-peek-find-definitions &amp;#34;def&amp;#34;) (&amp;#34;R&amp;#34; lsp-ui-peek-find-references &amp;#34;refs&amp;#34;))))) TSX のインデント調整 tab 押下時は web-mode-code-indent-offset 等の設定で動いていたが indent-region ではそれと違う値(4)でインデントされていて indent-region を使えずにいた</description>
    </item>
    
    <item>
      <title>magit</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/magit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/magit/</guid>
      <description>概要 magit は Emacs の上で Git の色々な操作ができるやつ。結構使いやすいのでオススメなやつ。
forge を使うと GitHub や GitLab とも連携できてさらに便利、なはず。
インストール (el-get-bundle magit) その他設定 ghub を load-path に入れないとうまくいかなかった時があったので入れてたり、 orgit を入れていたり
(with-eval-after-load &amp;#39;magit (add-to-list &amp;#39;load-path (expand-file-name &amp;#34;~/.emacs.d/el-get/ghub/lisp&amp;#34;))) (el-get-bundle orgit) 使い方 Git 管理されてるファイルを開いている時に M-x magit とかすると Git 管理用のバッファが出て来るしそこで ? を叩いたらどういうコマンドが使えるのか教えてくれるよ(雑)</description>
    </item>
    
    <item>
      <title>markdown</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/markdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/markdown/</guid>
      <description>概要 Markdown を書くための設定。といいつつ markdown-mode を入れてるだけだけども。
手元でテキストドキュメントを弄るのは org-mode が多いからなあ……
インストール いつも通り el-get で入れている。
(el-get-bundle markdown-mode) </description>
    </item>
    
    <item>
      <title>migemo</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/migemo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/migemo/</guid>
      <description>概要 migemo.el は cmigemo などと通信して、日本語入力オフのままローマ字入力をして日本語検索ができるようにするパッケージ。
これとても便利で抜け出せない。
インストール いつも通り el-get でインストール。
(el-get-bundle migemo) (load &amp;#34;migemo&amp;#34;) load はする必要あるのかわからんけど、そういう設定が既に入ってるのでそのままにしている。
Mac での辞書の位置の指定 Homebrew で cmigemo を入れているのでそれに合わせて辞書の位置を指定している。
;; Mac (let ((path &amp;#34;/usr/local/share/migemo/utf-8/migemo-dict&amp;#34;)) (if (file-exists-p path) (setq migemo-dictionary path))) Ubuntu での辞書の位置の指定 apt で cmigemo を入れているのでそれに合わせて辞書の位置を指定している。
;; Ubuntu (let ((path &amp;#34;/usr/share/cmigemo/utf-8/migemo-dict&amp;#34;)) (if (file-exists-p path) (setq migemo-dictionary path))) Manjaro での辞書の位置の指定 yay で cmigemo-git を入れているのでそれに合わせて辞書の位置を指定している。
;; Manjaro (let ((path &amp;#34;/usr/share/migemo/utf-8/migemo-dict&amp;#34;)) (if (file-exists-p path) (setq migemo-dictionary path))) cmigemo コマンドの PATH 指定 環境で PATH が変わるので which コマンドの結果を migemo-command に設定している。</description>
    </item>
    
    <item>
      <title>mode-line</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/mode-line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/mode-line/</guid>
      <description>概要 Emacs のバッファ下部に表示されるモードライン関連の設定をここにまとめている。このメニューの並びとかはどこかで直した方が良さそう。
hide-mode-line hide-mode-line は mode-line を隠してくれるパッケージ。ここでは neotree-mode-hook で引っ掛けて Neotree では mode-line を隠すように設定している
(el-get-bundle hlissner/emacs-hide-mode-line) (add-hook &amp;#39;neotree-mode-hook #&amp;#39;hide-mode-line-mode) 他にも mode-line の表示が不要なモードとかってありそうだけど特に思い付かないから今のところ Neotree 専用になっている。
日時を mode-line では表示しない 今だと i3bar に時計が表示されていていつもそれを見るので mode-line の日時表示は要らないな〜と思ったので非表示にした
(custom-set-variables &amp;#39;(display-time-24hr-format t)) (display-time-mode -1) 表示していたころの名残りで時計の表示形式は24時間表記の設定。表示する場合、「午前」とか「午後」とかの表示邪魔だしね。
smart-mode-line 関連の設定 unused smart-mode-line は mode-line をセクシーな感じにしてくれるパッケージ。というわけで昔入れていたけどもう使ってない。一応コードの残骸があったから一旦残しておく。
多分アイコン表示周りをゴリゴリ設定するのがだるくなって doom-modeline に乗り換えたんだと思う。
;; (el-get-bundle smart-mode-line) ;; (defvar sml/no-confirm-load-theme t) ;; (defvar sml/theme &amp;#39;dark) ;; (sml/setup) ;; major-mode ;; (add-hook &amp;#39;emacs-lisp-mode-hook (lambda () (setq mode-name (all-the-icons-fileicon &amp;#34;elisp&amp;#34;)))) ;; (add-hook &amp;#39;enh-ruby-mode-hook (lambda () (setq mode-name (concat &amp;#34;e&amp;#34; (all-the-icons-alltheicon &amp;#34;ruby-alt&amp;#34;))))) ;; (add-hook &amp;#39;ruby-mode-hook (lambda () (setq mode-name (all-the-icons-alltheicon &amp;#34;ruby-alt&amp;#34;)))) ;; (add-hook &amp;#39;vue-mode-hook (lambda () ;; (make-local-variable &amp;#39;mmm-submode-mode-line-format) ;; (setq mmm-submode-mode-line-format &amp;#34;~M:~m&amp;#34;) ;; (make-local-variable &amp;#39;mmm-buffer-mode-display-name) ;; (setq mmm-buffer-mode-display-name &amp;#34;V&amp;#34;))) ;; (add-hook &amp;#39;js-mode-hook (lambda () (setq mode-name &amp;#34;&amp;#34;))) ;; (add-hook &amp;#39;pug-mode-hook (lambda () (setq mode-name (all-the-icons-fileicon &amp;#34;pug&amp;#34;)))) ;; (add-hook &amp;#39;css-mode-hook (lambda () (setq mode-name (all-the-icons-faicon &amp;#34;css3&amp;#34;)))) ;; (add-hook &amp;#39;twittering-mode-hook (lambda () (setq mode-name (all-the-icons-faicon &amp;#34;twitter-square&amp;#34;)))) ;; (add-hook &amp;#39;org-mode-hook (lambda () (setq mode-name (all-the-icons-fileicon &amp;#34;org&amp;#34;)))) diminish diminish は minor-mode の表示をカスタマイズするためのモード。</description>
    </item>
    
    <item>
      <title>multiple-cursors</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/multiple-cursors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/multiple-cursors/</guid>
      <description>概要 multiple-cursors はカーソルを増やせるやつ。複数箇所を同時に編集できるようになって便利。
インストール el-get からインストールしている
(el-get-bundle multiple-cursors) キーバインド キーバインドは別途定義している。もうちょっと真面目に定義したい</description>
    </item>
    
    <item>
      <title>Neotree</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/neotree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/neotree/</guid>
      <description>概要 Neotree は Emacs でフォルダのツリー表示ができるやつ。メンテは活発じゃないようなので、その内乗り換えたい。
レシピ Neotree でメンテされているのは dev ブランチだけど el-get の公式のレシピでは master ブランチを見ているので自前で recipe を用意してそれを使っている。
(:name emacs-neotree-dev :website &amp;#34;https://github.com/jaypei/emacs-neotree&amp;#34; :description &amp;#34;An Emacs tree plugin like NerdTree for Vim.&amp;#34; :type github :branch &amp;#34;dev&amp;#34; :pkgname &amp;#34;jaypei/emacs-neotree&amp;#34;) インストール 上に書いたレシピを使ってインストールしている。
(el-get-bundle emacs-neotree-dev) 使わなくなったコード 元々設定していたが、 counsel-projectile を使ってると projectile-switch-project-action を設定していても反映されず意味がないのに気付いたので使わなくなった
https://github.com/mugijiru/.emacs.d/pull/183/files#r541843206
(setq projectile-switch-project-action &amp;#39;neotree-projectile-action) テーマの設定 GUI で起動している時はアイコン表示しそうでない場合は ▾ とかで表示する
(setq neo-theme (if (display-graphic-p) &amp;#39;icons &amp;#39;arrow)) のだけど、実際に今使ってるやつだともっとグラフィカルな表示なので all-the-icons の設定で上書きしている気がするので要確認
major-mode-hydra いちいちキーバインドを覚えてられないので major-mode-hydra を使って主要なキーバインドは hydra で使えるようにしている。
とはいえ、この文書を書く前日ぐらいに設定しているのでまだ使い慣れてないというか、ほとんど使えてない。</description>
    </item>
    
    <item>
      <title>notify-slack</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/notify-slack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/notify-slack/</guid>
      <description>概要 Emacs から Slack に通知するための自作関数。実体は同じく自作の外部コマンドを叩いているだけである。
何に使ってるかというと org-clock-in, org-clock-out の時に作業の開始と終了を分報チャンネルに投稿しているだけである。作業の可視化である。
実装 分報チャンネル設定用の変数 通知先のチャンネル名を格納する変数が必要なので defvar で定義しておく
(defvar my/notify-slack-times-channel nil) 送信するコマンド start-process を使って外部コマンドを叩いている。
(defun my/notify-slack (channel text) (if my/notify-slack-enable-p (start-process &amp;#34;my/org-clock-slack-notifier&amp;#34; &amp;#34;*my/org-clock-slack-notifier*&amp;#34; &amp;#34;my-slack-notifier&amp;#34; channel text))) my/notify-slack-enable-p という変数が nil だと大分コマンドが実行されないようになっている。
Slack 連携を Toggle するコマンド 連携したい時としたくない時があるので送信したりしなかったりを切り替えられるコマンドを用意している。
中身は何をしているかというと上に書いた my/notify-slack-enable-p という変数を切り替えているだけ。
(defun my/notify-slack-toggle () (interactive) (if my/notify-slack-enable-p (setq my/notify-slack-enable-p nil) (setq my/notify-slack-enable-p t))) 分報チャンネル投稿関数 「分報チャンネル投稿関数」としているけどデフォルト投稿先に投稿するための関数というような扱いの関数。
単純に前出の my/notify-slack 関数の第一引数に my/notify-slack-times-channel という変数を設定してそのチャンネルに向けて投稿するだけ。
(defun my/notify-slack-times (text) (if my/notify-slack-times-channel (my/notify-slack my/notify-slack-times-channel text))) 設定 あまり見せたくない設定ファイルを別ファイルに分離しているのでそれを読み出している。</description>
    </item>
    
    <item>
      <title>origami</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/origami/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/origami/</guid>
      <description>概要 origami はコードの折り畳み機能を提供するやつ。メジャーな言語は大体サポートしている感じ。大きいファイルを見る時に便利。
インストール el-get 公式にはレシピがないので自前でレシピを用意している。
(:name origami :website &amp;#34;https://github.com/elp-revive/origami.el&amp;#34; :description &amp;#34;A text folding minor mode for Emacs.&amp;#34; :type github :pkgname &amp;#34;elp-revive/origami.el&amp;#34; :depends (s dash)) そしてそれを使ってインストール
(el-get-bundle origami) キーバインド origami-mode-map では以下のように動くように設定している。
Key 効果 &amp;lt;backtab&amp;gt; 再帰的に折り畳んだり開いたりするやつ。org-mode の fold と似た感じ M-&amp;lt;backtab&amp;gt; そのノードだけ表示する (with-eval-after-load &amp;#39;origami (define-key origami-mode-map (kbd &amp;#34;&amp;lt;backtab&amp;gt;&amp;#34;) &amp;#39;origami-recursively-toggle-node) (define-key origami-mode-map (kbd &amp;#34;M-&amp;lt;backtab&amp;gt;&amp;#34;) &amp;#39;origami-show-only-node)) ただこれだけだと多分足りないので Hydra で色々定義している。
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define origami-hydra (:separator &amp;#34;-&amp;#34; :quit-key &amp;#34;q&amp;#34; :title &amp;#34;Origami&amp;#34;) (&amp;#34;Node&amp;#34; ((&amp;#34;o&amp;#34; origami-open-node &amp;#34;Open&amp;#34;) (&amp;#34;c&amp;#34; origami-close-node &amp;#34;Close&amp;#34;) (&amp;#34;s&amp;#34; origami-show-node &amp;#34;Show&amp;#34;) (&amp;#34;t&amp;#34; origami-toggle-node &amp;#34;Toggle&amp;#34;) (&amp;#34;S&amp;#34; origami-forward-toggle-node &amp;#34;Foward toggle&amp;#34;) (&amp;#34;r&amp;#34; origami-recursively-toggle-node &amp;#34;Recursive toggle&amp;#34;)) &amp;#34;All&amp;#34; ((&amp;#34;O&amp;#34; origami-open-all-nodes &amp;#34;Open&amp;#34;) (&amp;#34;C&amp;#34; origami-close-all-nodes &amp;#34;Close&amp;#34;) (&amp;#34;T&amp;#34; origami-toggle-all-nodes &amp;#34;Toggle&amp;#34;)) &amp;#34;Move&amp;#34; ((&amp;#34;n&amp;#34; origami-next-fold &amp;#34;Next&amp;#34;) (&amp;#34;p&amp;#34; origami-previous-fold &amp;#34;Previous&amp;#34;)) &amp;#34;Undo/Redo&amp;#34; ((&amp;#34;/&amp;#34; origami-undo &amp;#34;Undo&amp;#34;) (&amp;#34;?</description>
    </item>
    
    <item>
      <title>plantuml-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/plantuml-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/plantuml-mode/</guid>
      <description>概要 plantuml-mode は PlantUML という、テキストだけで UML 図などが描けるツール用のモード。
インストール el-get のレシピは自前で用意。
(:name plantuml-mode :description &amp;#34;Major mode for PlantUML.&amp;#34; :type github :branch &amp;#34;develop&amp;#34; :pkgname &amp;#34;skuro/plantuml-mode&amp;#34; :post-init (let ((plantuml-url &amp;#34;http://sourceforge.net/projects/plantuml/files/plantuml.jar/download&amp;#34;) (plantuml-jar (expand-file-name &amp;#34;plantuml.jar&amp;#34; default-directory))) (when (not (file-exists-p plantuml-jar)) (url-copy-file plantuml-url plantuml-jar))) :prepare (setq plantuml-jar-path (expand-file-name &amp;#34;plantuml.jar&amp;#34; default-directory))) そして el-get で入れてる
(el-get-bundle plantuml-mode) 設定 実行モードは &#39;jar を指定している。デフォルトは &#39;server なんだけどオフラインの時も使いたいししね。
(setq plantuml-default-exec-mode &amp;#39;jar) el-get でインスコすると jar ファイルも自動で拾って来て plantuml-mode と同じディレクトリに設置して plantuml-jar-path も通してくれるからそっち使う方が便利だしね。
その他 最新の develop ブランチだとインデントを調整できる機能が入っているので乗り換えたいけどそのためには el-get のレシピを書いてあげる必要がありそうで放置している。</description>
    </item>
    
    <item>
      <title>posframe</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/posframe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/posframe/</guid>
      <description>概要 posframe は child frame を表示させるためのパッケージ。 Emacs のど真ん中に表示したり、今あるカーソル位置のすぐそばに出したりできる。
ivy なんかを使う時に ivy-posframe をど真ん中に出すと、いつもそこに表示されるし真ん中なの視線移動が少なくて済むし ddskk-posframe なんかで変換候補をカーソル位置のそばに出て来るので一般的な日本語変換ソフトと同様にこれまた視線移動が少なくて便利。
という感じで色々なものの拡張として使わているやつ。
インストール いつも通り el-get で入れているだけ。
(el-get-bundle posframe) こいつ自体には特に設定を入れてない。というか設定項目自体2個しか存在していない。
ま、こいつ単体で使うものでもないしね。</description>
    </item>
    
    <item>
      <title>projectile</title>
      <link>https://mugijiru.github.io/.emacs.d/nav/projectile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/nav/projectile/</guid>
      <description>概要 projectile はプロジェクト内のファイルを検索したりするのに便利なパッケージ
インストール いつも通り el-get からインストールする
(el-get-bundle projectile) 有効化 このあたりで有効化しておいている。この順序に意味があったかは忘れた……。
(projectile-mode) 無視リスト 普段 Rails ばっかりやってるのでそれ関係のものを無視リストに入れている。けどあんまりメンテしてない。
無視するディレクトリ (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;tmp&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;.tmp&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;vendor&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;.sass-cache&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;coverage&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;cache&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-directories &amp;#34;log&amp;#34;) node_modules もここに突っ込んでも良いかもしれない。
無視するファイル (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;gems.tags&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;project.tags&amp;#34;) (add-to-list &amp;#39;projectile-globally-ignored-files &amp;#34;manifest.json&amp;#34;) tags ファイルは昔は使っていたけど、最近は dumb-jump が優秀なのと、面倒で使ってないのでそろそろ gems.tags と project.tags は不要かもしれない。
ivy/counsel との連携 上の方で helm との連携処理を入れていたが今は大体 ivy に乗り換えているので ivy 連携もしている。
(setq projectile-completion-system &amp;#39;ivy) (el-get-bundle counsel-projectile) counsel-projectile はいくつかの絞り込み処理を提供してくれて便利。それでも足りなかったら自前で何か作ることになるのかなと思っている。</description>
    </item>
    
    <item>
      <title>rails</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/rails/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/rails/</guid>
      <description>概要 Rails 開発関係だけど Ruby 開発とはちょっと違う設定をここに書いている。
関連パッケージのインストール テンプレートエンジンには haml を使っているので haml-mode を入れていてファイルナビゲーションには projectile の拡張である projectile-rails を利用している。
(el-get-bundle haml-mode) (el-get-bundle projectile-rails) (projectile-rails-global-mode 1) projectile-rails 用のコマンド追加 自身のプロジェクトだと少しナビゲーション用のコマンドが不足していたので projectile-rails の実装を参考にコマンドを追加している
TS/TSX Finder client に格納しているフロントエンドのファイルを検索するコマンド
(defun my/projectile-rails-find-typescript () &amp;#34;Find a TS/TSX files.&amp;#34; (interactive) (projectile-rails-find-resource &amp;#34;ts/tsx: &amp;#34; &amp;#39;((&amp;#34;client/&amp;#34; &amp;#34;\\(.+\\.tsx?\\)$&amp;#34;)) &amp;#34;client/${filename}&amp;#34;)) TS/TSX test files Finder spec/javascript に格納しているフロントエンドのテストファイルを検索するコマンド
(defun my/projectile-rails-find-typescript-spec () &amp;#34;Find a TS/TSX test files.&amp;#34; (interactive) (projectile-rails-find-resource &amp;#34;ts/tsx spec: &amp;#34; &amp;#39;((&amp;#34;spec/javascripts/&amp;#34; &amp;#34;\\(.+\\.spec.tsx?\\)$&amp;#34;)) &amp;#34;spec/javascripts/${filename}&amp;#34;)) キーバインド もちろん基本的にコマンドなんて覚えられないのでいつも通り Hydra を定義して大体キーバインドは忘れている。</description>
    </item>
    
    <item>
      <title>React.js</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/react-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/react-js/</guid>
      <description>概要 React.js を書くための設定をここにまとめている
dap-mode Debug Adapter Protocol をサポートするモード。入れておいた方がきっとデバッグしやすいんだろうということで入れている。
lsp-mode の仲間なので、本当はそっち側で入れるようにした方が良さそうだけどひとまず React のために入れているので React 用の設定ファイルに書いている。
(el-get-bundle dap-mode) 同時に treemacs や lsp-treemacs も入ってくる罠がある。 Neotree 使ってるからちょっとアレだなあ。いずれ乗り換えようとはしていたけども。
web-mode とりあえず tsx を弄る上では web-mode が良いという話もあるので入れておく。
(el-get-bundle web-mode) メジャーモードの紐付け jsx/tsx ファイルを開いた時には web-mode で動いてほしいので auto-mode-alist で関連付けをする
(add-to-list &amp;#39;auto-mode-alist &amp;#39;(&amp;#34;\\.[jt]sx&amp;#34; . web-mode)) キーバインドの追加 テスト用のファイルを開いたら C-c C-c でテストを実行できるようにするためキーバインドを設定
(defun my/setup-web-mode-map () (let ((keymap web-mode-map)) (define-key keymap (kbd &amp;#34;C-c C-c&amp;#34;) &amp;#39;my/mocha-test-file))) 自動フォーマット hook の用意 tsx の保存時に自動でフォーマットしてほしいのでそれ用に hook を追加
(defun my/web-mode-auto-fix-hook () (when (string-equal (file-name-extension buffer-file-name) &amp;#34;tsx&amp;#34;) (lsp-eslint-fix-all))) lsp-mode などの有効化 jsx/tsx ファイルを開く時に web-mode が有効になるようにしているのでその web-mode の hook で</description>
    </item>
    
    <item>
      <title>rspec-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/rspec-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/rspec-mode/</guid>
      <description>概要 rspec-mode は Emacs で RSpec を実行したりする時に便利なパッケージ。といいつつ麦汁さんはちゃんと使いこなしていない……
インストール (el-get-bundle rspec-mode) 有効化 rspec 実行バッファで byebug などで止まった際に C-x C-q したら inf-ruby が動くようにしている。
(add-hook &amp;#39;after-init-hook &amp;#39;inf-ruby-switch-setup) binding.pry は何故かまともに動かないので byebug か binding.irb 推奨。麦汁さんはいつも debugger とコードに入れて使っている。
キーバインド C-c C-c で開いている rspec ファイルのカーソルがある行のテストを実行できるようにしている。
(define-key rspec-mode-map (kbd &amp;#34;C-c C-c&amp;#34;) &amp;#39;rspec-verify-single) 他にも色々な機能があるのだけどキーバインド未設定なのでこれだけしか使ってない。
Docker 連携 Docker と連携するように調整
(custom-set-variables &amp;#39;(rspec-use-docker-when-possible t)) </description>
    </item>
    
    <item>
      <title>ruby</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/ruby/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/ruby/</guid>
      <description>概要 Ruby のコードを編集する上での設定をここには書いている。別の箇所で rspec-mode などの設定も書いているのでいつか記述場所を統合した方が良さそうな気もする
rbenv.el Ruby のバージョンを切り替えられる rbenv を使ってるので Emacs 上でもそれが使えるように rbenv.el を導入している。
インストール インストールはいつも通り el-get でやっている
(el-get-bundle rbenv) 有効化 そして global に有効化している。というか global じゃない有効化ってあるのかなってのと、あるとしても意味があるのかな的な。
(global-rbenv-mode) enh-ruby-mode メジャーモードは enhanced-ruby-mode を利用している。が、最近は ruby-mode の方がやっぱり良いみたいな話もどこかで見た気がするので戻ってみるのも手かもしれないと思っている。
インストール いつも通り el-get で入れている。
(el-get-bundle enh-ruby-mode) カスタム設定 enh-ruby-mode が読み込まれた後に setq で以下のように設定されている
(with-eval-after-load &amp;#39;enh-ruby-mode (setq enh-ruby-add-encoding-comment-on-save nil) (setq enh-ruby-deep-indent-paren nil) (setq enh-ruby-deep-indent-construct nil) (setq enh-ruby-bounce-deep-indent nil)) encoding のマジックコメントが入らないようにする enh-ruby-add-encoding-comment-on-save を nil にすることで encoding 設定のマジックコメントが入らないようにしている。
これは昔は有効にしておいた方が良かったけど最近の Ruby では設定しなくても UTF-8 が前提になるからむしろ無い方が良いというお話だったはず。</description>
    </item>
    
    <item>
      <title>savehist</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/savehist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/savehist/</guid>
      <description>概要 Emacs 標準でついている、ミニバッファの履歴などを保存してくれる機能。
有効化 標準でついているので以下のようにするだけで有効化可能。
(savehist-mode 1) 設定 標準で保存されるもの以外だと kill-ring だけを保存対象にしている。これで Emacs を終了させても kill-ring は残るようになるはず。だけど最近使えてない気がするな……。検証が必要そう。
(setq savehist-additional-variables &amp;#39;(kill-ring)) 他にも有効にしたら便利そうなのがあれば追加したい。が、ぱっとは思い付かない。</description>
    </item>
    
    <item>
      <title>scratch-log</title>
      <link>https://mugijiru.github.io/.emacs.d/buffer-management/scratch-log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/buffer-management/scratch-log/</guid>
      <description>概要 scratch-log は、Emacs でちょっとした Emacs Lisp なんかを試し書きする時に使う *scratch* バッファを永続化してくれるパッケージ。
自分なんかは Emacs Lisp だけでなくちょっとメモを置いといたりもするので勝手に永続化してくれるこいつにはとてもお世話になっている。
GitHub の README には作者のブログへのリンクしかないしそのブログは消えてるので一番まともに解説しているのは http://emacs.rubikitch.com/scratch-log/ だと思う。
インストール el-get から入れるだけ。
(el-get-bundle mori-dev/scratch-log) 有効化 どうも明示的に require しないといけないっぽくて、そうしている。ちょっと本当にそうなのか検証したい気はする。
(require &amp;#39;scratch-log) 類似品など persistent-scratch これも scratch を永続化させるやつ。カスタマイズ性はこっちがありそう unkillable-scratch scratch バッファを kill させないやつ。同じような機能が scratch-log にもある auto-save-buffers-enhanced 自動保存機能がメインだけど scratch を自動保存する機能もある </description>
    </item>
    
    <item>
      <title>scss</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/scss/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/scss/</guid>
      <description>概要 scss を使う上での設定をここではまとめている。長いこと手を入れてないので今はより良い設定がありそうな気がする。
rainbow-mode rainbow-mode はカラーコードを入力した際に、そのカラーコード部分の背景色をカラーコードの色に変化させるパッケージ。ぱっと見で大体どんな色かわかって便利なやつ
インストール 自分はel-get で入れている。
(el-get-bundle rainbow-mode) ELPA に登録されているので package-install でもいける
scss-mode scss-mode は Emacs 組込みの css-mode の中で定義されているメジャーモード。なのでインストール不要で使えるし .scss という拡張子なら自動的に scss-mode で開いてくれるようになっている。
設定 improvement インデントはデフォルトだと半角空白 4 つとなっているが麦汁さん的には 2 の方が良いのでそのように変更している。
(with-eval-after-load &amp;#39;scss-mode (setq css-indent-offset 2)) with-eval-after-load を使っているが css-indent-offset は defcustom で定義されているので custom-set-variables を使うように修正した方が良さそう
flycheck の scss-stylelint を上書き stylelint v14 以降は &amp;ndash;style オプションが使えないので上書き https://github.com/flycheck/flycheck/pull/1944 が取り込まれたらこれも要らなさそうだけど。
(with-eval-after-load &amp;#39;flycheck (flycheck-define-checker scss-stylelint &amp;#34;A SCSS syntax and style checker using stylelint. See URL `http://stylelint.</description>
    </item>
    
    <item>
      <title>server</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/server/</guid>
      <description>概要 Emacs の起動後にサーバとして動くようにしている。
これにより emacsclient コマンドで接続するとサーバとして動いている Emacs に別端末から繋げられたりする。
けど麦汁さんは Firefox から org-capture を動かすためにだけ利用している。
設定 server.el を require しておいてサーバとして動いていなかったらサーバとして動くようにしている。多重起動の防止ですね。
(require &amp;#39;server) (unless (server-running-p) (server-start)) 関連ツール org-capture-extension org-capture 連携するための Chrome 及び Firefox の拡張。麦汁さんはこれを Firefox で使ってる。 org-protocol-capture-html HTML コンテンツを org-mode の記述に変換して capture してくれるやつ。Pandoc 利用。 その他 起動処理の最後に動けばいいので init-loader で 99 を割り振っている。
init-loader をやめるなら多分 after-init-hook を使うことになるのかな。</description>
    </item>
    
    <item>
      <title>show-paren-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/show-paren-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/show-paren-mode/</guid>
      <description>概要 show-paren-mode は Emacs に標準で入っているやつで開き括弧と閉じ括弧の対応を示してくれたり括弧の中身を強調表示したりする機能を提供してくれるやつ。
有効化 デフォで入ってるので以下のようにするだけで有効化される。
(show-paren-mode 1) デフォ設定だと対応する括弧を強調表示するだけだけどまあそれで悪くないと思ってるので今のところデフォルト設定のままである。
その他 http://syohex.hatenablog.com/entry/20110331/1301584188
の記事へのリンクを設定ファイルの中に残していたけど設定は特に弄ってないのでまたその記事読んだりで設定弄ってみてもいいかもしれない。
また smartparens.el にも似た機能はあるようだけど Emacs 標準機能の方が軽そうなのでとりあえずこのままにするつもり。</description>
    </item>
    
    <item>
      <title>smartparens</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/smartparens/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/smartparens/</guid>
      <description>概要 smartparens はカッコとかクォートとかのペアになるようなものの入力補助をしてくれるやつ。
strict モードだとペアが崩れないように強制するので雑に C-k で行削除しててもペアが維持されて便利。
インストール いつも透り el-get で導入している
(el-get-bundle smartparens) 設定 実は導入して間もないので、提供されてるオススメ設定のみ突っ込んでいる。オススメ設定は別途 reqiure したら良いという作りなので、以下のようにして突っ込んでいる。
(require &amp;#39;smartparens-config) その他 各言語の hook で smartparens-strict-mode を有効にしている。なんか常に有効だと困りそうな気がしたので。</description>
    </item>
    
    <item>
      <title>sticky-control</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/sticky-control/</guid>
      <description>概要 指定したキーを2回叩いたら Control が押されてるような状態にしてくれるプラグイン。
その2回の間隔はデフォルトだと 0.5 秒以内となっている。そのため、そのキーを押して 0.5 秒が経過したら、普通にそのキーが押されたことになる
さらに sticky-control-shortcuts に指定されてる一部のキーについては sticky 用のキーを押した直後に shortcuts のキーを押すと Control を押している状態でそのキーを押したことになる。
例えば私は , を sticky 用のキーにしていて shortcuts に c を入れているので ,c と素早くタイプをすればそれだけで C-c が押された状態になる。
インストール まずは el-get-bundle でインストール。
(el-get-bundle sticky-control) ちなみにレシピは公式ではなかったのでとりあえず自分の環境で使えるように自作レシピを置いている。
(:name sticky-control :description &amp;#34;save your left little finger&amp;#34; :type http :url &amp;#34;https://raw.githubusercontent.com/martialboniou/emacs-revival/master/sticky-control.el&amp;#34; :features &amp;#34;sticky-control&amp;#34;) 元々は http://www.cs.toronto.edu/~ryanjohn/sticky-control.el にあったのだけど最近そこからは取得できなくなったので https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el から取得して利用している
設定 まずは「2回叩いたら Control を押している状態になる」キーを指定する。
(sticky-control-set-key &amp;#39;sticky-control-key ?,) 私は , を sticky-control のキーにしているのでこの指定。
そして次に sticky-control-shortuts の指定。ここに指定しておくと、例えば ,c と素早くタイプすることで C-c が入力された状態とすることができる。</description>
    </item>
    
    <item>
      <title>tempbuf</title>
      <link>https://mugijiru.github.io/.emacs.d/buffer-management/tempbuf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/buffer-management/tempbuf/</guid>
      <description>概要 tempbuf-mode は不要になったと思われるバッファを自動的に kill してくれるパッケージ。使っていた時間が長い程、裏に回った時には長い時間保持してくれる。
つまり、一瞬開いただけのファイルは明示的に kill しなくても勝手にやってくれるのでファイルを開いてそのまま放置みたいなことをしがちなズボラな人間には便利なやつ。
インストール いつも通り el-get で入れている。
(el-get-bundle tempbuf-mode) 勝手に kill させないファイルの指定 org-clock を使うようなファイルは kill されると org-clock が狂って面倒なことになるのでそれらのファイルは勝手に kill されないように ignore リストに突っ込んでいる
(setq my/tempbuf-ignore-files &amp;#39;(&amp;#34;~/Documents/org/tasks/reviews.org&amp;#34; &amp;#34;~/Documents/org/tasks/interrupted.org&amp;#34; &amp;#34;~/Documents/org/tasks/next-actions.org&amp;#34; )) find-file への hook find-file した時に上でリストアップしたファイルだった場合は kill されないように tempbuf-mode が自動的に無効になるような hook を用意している。
(defun my/find-file-tempbuf-hook () (let ((ignore-file-names (mapcar &amp;#39;expand-file-name my/tempbuf-ignore-files))) (unless (member (buffer-file-name) ignore-file-names) (turn-on-tempbuf-mode)))) hook の設定 find-file では上で作成した hook を使うことで kill されたくないファイルは kill されないようにしている
(add-hook &amp;#39;find-file-hook &amp;#39;my/find-file-tempbuf-hook) また dired buffer も邪魔になりがちだけど、デフォルトだと対象にならないのでこいつらも tempbuf-mode の管理対象となるように tempbuf-mode を有効にしている。</description>
    </item>
    
    <item>
      <title>todoist</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/todoist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/todoist/</guid>
      <description>概要 emacs-todoist は Todo 管理サービスである Todoist と連携するためのパッケージ。 org-mode に依存している。
インストール まず以下のレシピを用意している
(:name emacs-todoist :website &amp;#34;https://github.com/abrochard/emacs-todoist&amp;#34; :description &amp;#34;Emacs interface to Todoist&amp;#34; :type github :pkgname &amp;#34;abrochard/emacs-todoist&amp;#34;) その上で以下のようにしてインストールしている
(el-get-bundle emacs-todoist) 設定 API キーを設定するので別ファイルに分離している。いつか .authinfo.gpg に移動しようかなと思っているけどそもそも最近 TODOIST 使ってない……
(with-eval-after-load &amp;#39;todoist (setq todoist-token (funcall (plist-get (nth 0 (auth-source-search :host &amp;#34;todoist.com&amp;#34; :max 1)) :secret)))) </description>
    </item>
    
    <item>
      <title>toolbar</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/toolbar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/toolbar/</guid>
      <description>概要 Emacs 標準の toolbar の設定。麦汁さんは使わないし幅を取るので隠す派。
設定 単に無効にして隠している
(tool-bar-mode -1) </description>
    </item>
    
    <item>
      <title>twmode</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/twmode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/twmode/</guid>
      <description>概要 twmode は Emacs 上で動く Twitter クライアント。
今でもたまーに使っている。勉強会に参加して実況する時などに。
インストール いつも通り el-get でインスコしている。
(el-get-bundle twittering-mode) 設定 (setq twittering-username &amp;#34;mugijiru&amp;#34;) (setq twittering-jojo-mode t) (setq twittering-timer-interval 60) ;(setq twittering-auth-method &amp;#39;xauth) (setq twittering-auth-method &amp;#39;oauth) (setq twittering-update-status-function &amp;#39;twittering-update-status-from-minibuffer) (setq twittering-status-format &amp;#34;%i %S(%s)%p, %@:\n%FILL{ %T // from %f%L%r%R}\n &amp;#34;) (setq twittering-retweet-format &amp;#34;RT @%s %t&amp;#34;) (setq twittering-display-remaining t) なんか色々設定しているけど、まあ大体こんな感じ。
ユーザー名の指定 twittering-jojo-mode を有効化 自動リロードの間隔を60秒に設定 OAuth で認証するように設定 投稿時にミニバッファから投稿するように設定 各ツイートのフォーマット指定 旧式の Retweet 時のフォーマット指定 late limit をmode-line に表示 キーバインド (let ((km twittering-mode-map)) (define-key km (kbd &amp;#34;SPC&amp;#34;) &amp;#39;scroll-up) (define-key km (kbd &amp;#34;b&amp;#34;) &amp;#39;scroll-down) (define-key km (kbd &amp;#34;g&amp;#34;) &amp;#39;beginning-of-buffer) (define-key km (kbd &amp;#34;G&amp;#34;) &amp;#39;end-of-buffer) (define-key km (kbd &amp;#34;&amp;lt;&amp;#34;) &amp;#39;beginning-of-buffer) (define-key km (kbd &amp;#34;&amp;gt;&amp;#34;) &amp;#39;end-of-buffer) (define-key km (kbd &amp;#34;R&amp;#34;) &amp;#39;twittering-current-timeline) (define-key km (kbd &amp;#34;F&amp;#34;) &amp;#39;twittering-favorite) (define-key km (kbd &amp;#34;\C-cfd&amp;#34;) &amp;#39;twittering-unfavorite) (define-key km (kbd &amp;#34;\C-c[&amp;#34;) &amp;#39;twittering-follow) (define-key km (kbd &amp;#34;\C-c]&amp;#34;) &amp;#39;twittering-unfollow) nil) Key 効果 SPC スクロールする b 上にスクロールする g, &amp;lt; バッファの先頭に移動 G, &amp;gt; バッファの末尾に移動 R 現在のタイムラインを更新 F ふぁぼる C-c f d ふぁぼ取り消し C-c [ フォローする C-c ] アンフォロー </description>
    </item>
    
    <item>
      <title>TypeScript</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/typescript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/typescript/</guid>
      <description>概要 TypeScript ファイル(.ts) を使う上での設定を書いている。とりあえず簡単な設定だけ。
typescript-mode typescript-mode は TypeScript 向けの Syntax Highlight とかを提供してくれるメジャーモード。
インストール 自分はいつも通り el-get で入れている
(el-get-bundle typescript-mode) カスタム変数 indent は2文字がいいのでデフォルトから変更 言語設定を ja にする。エラーが日本語で出るようになるとか……? inlay-hint を有効にする。何が変わるかわかってないけど Node.js の使用メモリも 2048 MB に増加。メモリ足らんってなる時があったので 保存時の自動フォーマット などを設定している。
(custom-set-variables &amp;#39;(typescript-indent-level 2) &amp;#39;(lsp-typescript-locale &amp;#34;ja&amp;#34;) &amp;#39;(lsp-inlay-hint-enable t) &amp;#39;(lsp-javascript-display-parameter-name-hints t) &amp;#39;(lsp-javascript-display-enum-member-value-hints t) &amp;#39;(lsp-clients-typescript-max-ts-server-memory 2048) &amp;#39;(lsp-eslint-auto-fix-on-save t)) キーマップ関数 C-c C-c でテストを実行できるようにするように keymap を設定する関数を追加。
(defun my/setup-ts-mode-keymap () (let ((keymap typescript-mode-map)) (define-key keymap (kbd &amp;#34;C-c C-c&amp;#34;) &amp;#39;my/mocha-test-file))) auto-fix の hook 関数 保存した時に自動で整形してほしいなと思ったので自動で保存されるように hook 関数を用意している</description>
    </item>
    
    <item>
      <title>undo-fu</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/undo-fu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/undo-fu/</guid>
      <description>概要 undo-fu はシンプルな undo/redo 機能を提供してくれるやつ。
昔はもっと色々できる undo-tree を使っていたけどそっちにバグがあるっぽいので乗り換えた。
インストール レシピは自前で用意している
(:name undo-fu :website &amp;#34;https://codeberg.org/ideasman42/emacs-undo-fu&amp;#34; :description &amp;#34;Simple, stable linear undo with redo for Emacs.&amp;#34; :type git :url &amp;#34;https://codeberg.org/ideasman42/emacs-undo-fu.git&amp;#34;) そしていつも通り el-get-bundle でインストールしている
(el-get-bundle undo-fu) キーバインド 別の場所で定義しているけど、以下のキーバインドにしている。
Key 効果 C-/ undo C-M-/ redo </description>
    </item>
    
    <item>
      <title>uniquify</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/uniquify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/uniquify/</guid>
      <description>概要 同じ名前のファイルを開いている時に祖先のディレクトリ名を表示してくれてどこのファイルかわかりやすくしてくれるやつ。
すぐ親とかも同名でも、名前が違うところまで遡って表示してくれる。
有効化 Emacs に標準で入ってるので require するだけで有効にできる
(require &amp;#39;uniquify) 設定 自分は ファイル名&amp;lt;フォルダ名&amp;gt; みたいな表示になる形式にしている。その方がファイル名が主という感じになって使いやすそうだなって。
そういう意味では post-foward の方が幅を使わない分良いかもしれない。いつか検討しても良いかもしれない。
(setq uniquify-buffer-name-style &amp;#39;post-forward-angle-brackets) </description>
    </item>
    
    <item>
      <title>view-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/view-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/view-mode/</guid>
      <description>概要 view-mode は Emacs に標準で組込まれているモードで、バッファを閲覧専用にする機能を提供してくれるやつ。コードを眺めたい時などに使っている。
キーバインド view-mode の時は文字入力をする必要がないので通常のモードの時とは違うキーバインドが使えるようにしている。
(defun my/setup-view-mode-keymap () (let ((keymap view-mode-map)) (define-key keymap (kbd &amp;#34;h&amp;#34;) &amp;#39;backward-char) (define-key keymap (kbd &amp;#34;j&amp;#34;) &amp;#39;next-line) (define-key keymap (kbd &amp;#34;k&amp;#34;) &amp;#39;previous-line) (define-key keymap (kbd &amp;#34;l&amp;#34;) &amp;#39;forward-char) (define-key keymap (kbd &amp;#34;e&amp;#34;) &amp;#39;forward-word) (define-key keymap (kbd &amp;#34;b&amp;#34;) &amp;#39;scroll-down) (define-key keymap (kbd &amp;#34;SPC&amp;#34;) &amp;#39;scroll-up) (define-key keymap (kbd &amp;#34;g&amp;#34;) &amp;#39;beginning-of-buffer) (define-key keymap (kbd &amp;#34;G&amp;#34;) &amp;#39;end-of-buffer) (define-key keymap (kbd &amp;#34;&amp;lt;&amp;#34;) &amp;#39;beginning-of-buffer) (define-key keymap (kbd &amp;#34;&amp;gt;&amp;#34;) &amp;#39;end-of-buffer))) Key 効果 h 1文字戻る j 1行下がる k 1行上がる l 1文字進む e 単語の直後に移動 b 1スクロール戻る SPC 1スクロール進む g, &amp;lt; バッファの先頭に移動 G, &amp;gt; バッファの末尾に移動 適当だけど Vim の通常モードの時みたいな操作ができるようにしている。</description>
    </item>
    
    <item>
      <title>Vue.js</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/vue-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/vue-js/</guid>
      <description>概要 ここでは Vue.js アプリケーションを書く上での設定を書いている。
auto-insert の設定 Vue.js のコンポーネントファイルを新規作成する時にテンプレートが自動挿入できるようにしている
テンプレート Vue.js の単一ファイルコンポーネントなので template, script, style を出力している。
template には pug を、CSS には scss を使っている。
&amp;lt;template lang=&amp;#39;pug&amp;#39;&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { }; &amp;lt;/script&amp;gt; &amp;lt;style lang=&amp;#39;scss&amp;#39; scoped&amp;gt; &amp;lt;/style&amp;gt; テンプレートを適用可能にする .vue という拡張子のファイルを新規作成する時には上で定義したテンプレートが自動的に挿入されるようにする。
(define-auto-insert &amp;#34;\\.vue$&amp;#34; &amp;#34;template.vue&amp;#34;) パッケージのインストール ここでは Vue.js 開発に使っている関連パッケージを入れている。
vue-mode vue-mode は mmm-mode をベースにして作られた Vue.js の単一ファイルコンポーネント用のモード。 mmm-mode ベースなので template, script, css 部分でそれぞれ別のメジャーモードが動くようになっている。
インストール いつも透り el-get で入れている
(el-get-bundle vue-mode) 備考 あまり更新は活発でなく微妙な挙動もあるので mmm-mode に乗り換えたり web-mode を使うようにしている人も多い様子。</description>
    </item>
    
    <item>
      <title>wakatime-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/wakatime-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/wakatime-mode/</guid>
      <description>概要 wakatime-mode は WakaTime というサービスと連携するためのパッケージ。
WakaTime は自分がどのプロジェクトの作業をしているかを計測してくれるようなツール。普段の行動の改善に使えるかもしれないので、なんとなく連携してみている。
インストール いつも通り el-get から入れている
(el-get-bundle wakatime-mode) APIキーの設定 APIキーは .authinfo.gpg に保存しているのでそこから引っ張り出している。
(custom-set-variables &amp;#39;(wakatime-cli-path &amp;#34;/usr/bin/wakatime&amp;#34;) &amp;#39;(wakatime-api-key (funcall (plist-get (nth 0 (auth-source-search :host &amp;#34;wakatime.com&amp;#34; :max 1)) :secret)))) 有効化 Emacs を使っている間は常に有効になっていて欲しいので global-wakatime-mode を有効にしている。
(global-wakatime-mode 1) APIキーが取れてない時はやたらエラーを吐くので何かしら調整はしてもいいかもしれない。
(if (boundp &amp;#39;wakatime-api-key) (global-wakatime-mode 1)) みたいにして API キーが取れている時だけ有効にするとかね。</description>
    </item>
    
    <item>
      <title>whitespace</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/whitespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/whitespace/</guid>
      <description>概要 whitespace-mode は Emacs に標準添付されている、空白文字を可視化したりするためのモード。
全角空白を可視化したり、行末の空白を可視化したりしておくと便利なので入れている。
設定 (require &amp;#39;whitespace) 可視化対象 可視化対象の空白について設定している。
(setq whitespace-style &amp;#39;(face trailing tabs spaces empty space-mark tab-mark)) 値 意味 face face による可視化を有効にする。これがないと *-mark 以外が有効にならない trailing 行末の空白を可視化する tabs タブ文字の可視化 spaces 空白の可視化。ただし後の設定で全角のみを可視化するようにている empty バッファの前後に空行があれば可視化 space-mark 空白文字を別の文字に置き換える設定。置き換え文字は後述 tab-mark タブ文字を別の文字に置き換える設定。置き換え文字は後述 他にも lines, lines-tail, indentation, big-indent, newline-mark などがある
lines-tail あたりを使うと1行80文字制限でコーディングする時などに便利かもしれないなって思ってる。設定したことがないからわからんが……。
置き換え表示用の文字の設定 (setq whitespace-display-mappings &amp;#39;((space-mark ?\u3000 [?\u25a1]) ;; WARNING: the mapping below has a problem. ;; When a TAB occupies exactly one column, it will display the ;; character ?</description>
    </item>
    
    <item>
      <title>yaml-mode</title>
      <link>https://mugijiru.github.io/.emacs.d/programming/yaml-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/programming/yaml-mode/</guid>
      <description>概要 yaml-mode は yaml を編集する時のメジャーモード。インデントを調整しやすい。
インストール いつも通り el-get でインストール
(el-get-bundle yaml-mode) hook mode に対する hook は関数を定義してその中で呼びたいコードを書いていくようにしている。
lambda で書いてしまうと hook を弄りたい時に結構面倒なのだけど関数を定義しておくと、その関数の中身を変更して評価しておくだけで hook で動作する中身が変更できて便利。
とりあえず yaml-mode では以下のようにして highlight-indent-guides を有効にしている。
(defun my/yaml-mode-hook () (lsp 1) (highlight-indent-guides-mode 1)) で、その hook を最後に yaml-mode-hook に追加している。
(add-hook &amp;#39;yaml-mode-hook &amp;#39;my/yaml-mode-hook) </description>
    </item>
    
    <item>
      <title>yascroll</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/yascroll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/yascroll/</guid>
      <description>概要 yascroll は標準のスクロールバーとは異なるスクロールバーを表示するやつ。
デフォルトだと右側の fringe 領域に表示するのであまり邪魔にならないし表示領域を必要以上に狭めないので気に入っている。
最初に作られたっぽい記事は 主張しないスクロールバーモード、yascroll.elをリリースしました - Functional Emacser にある。タイトル通り、あまり主張しない感じで良い。
インストール いつも通り el-get でインストールしている
(el-get-bundle yascroll) これだけで大体いい感じに表示されるので便利。たまに表示されなくなることもあるが、まあそこまで重要なやつでもないのであまり気にしていない</description>
    </item>
    
    <item>
      <title>yasnippet</title>
      <link>https://mugijiru.github.io/.emacs.d/editing/yasnippet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/editing/yasnippet/</guid>
      <description>概要 yasnippet はテンプレートを挿入する機能を持ったパッケージ。 Emacs でそこそこ何かを書いている人なら大体知ってるような有名なやつだと思う。
インストール いつも通り el-get でインストール
(el-get-bundle yasnippet) 有効化 どこでも使いたいぐらい便利なやつなので global に有効化している
(yas-global-mode 1) キーバインド 基本的に覚えられないので Hydra を使って定義している
(with-eval-after-load &amp;#39;pretty-hydra (pretty-hydra-define yasnippet-hydra (:separator &amp;#34;-&amp;#34; :title &amp;#34;Yasnippet&amp;#34; :foreign-key warn :quit-key &amp;#34;q&amp;#34; :exit t) (&amp;#34;Edit&amp;#34; ((&amp;#34;n&amp;#34; yas-new-snippet &amp;#34;New&amp;#34;) (&amp;#34;v&amp;#34; yas-visit-snippet-file &amp;#34;Visit&amp;#34;)) &amp;#34;Other&amp;#34; ((&amp;#34;i&amp;#34; yas-insert-snippet &amp;#34;Insert&amp;#34;) (&amp;#34;l&amp;#34; yas-describe-tables &amp;#34;List&amp;#34;) (&amp;#34;r&amp;#34; yas-reload-all &amp;#34;Reload all&amp;#34;))))) Key 効果 n 現在のメジャーモード用に新しい snippet を作る v 現在のメジャーモードの登録済 snippet ファイルを開く i snippet の挿入。選択は ivy で行われる。 l 現在のメジャーモードの登録済 snippet の一覧表示 r snippet を全部 load し直す その他 実は、どういう snippet があれば便利なのかよくわかってなくて snippet をほとんど登録してない。</description>
    </item>
    
    <item>
      <title>zoom</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/zoom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/zoom/</guid>
      <description>概要 zoom はフォーカスが当たっている Window が大きく表示されるようにするやつ。最近流行りのビデオチャットツールではない。
どこにフォーカスが当たっているかわかりやすくなるし、狭い画面でも見たい部分を広げて表示できるので便利。
インストール el-get のレシピは自前で用意している
(:name zoom :type github :description &amp;#34;Fixed and automatic balanced window layout.&amp;#34; :pkgname &amp;#34;cyrus-and/zoom&amp;#34; :minimum-emacs-version (24 4)) そして el-get で入れる。 GitHub から直接取得するように設定している。
(el-get-bundle cyrus-and/zoom) 設定 起動時に有効化 1画面しか使えない時は必須なので 比率を黄金比に変更 この方が使いやすいっぽい。 という設定をしている。
(custom-set-variables &amp;#39;(zoom-mode t) &amp;#39;(zoom-size &amp;#39;(0.618 . 0.618))) </description>
    </item>
    
    <item>
      <title>zoom-window</title>
      <link>https://mugijiru.github.io/.emacs.d/ui/zoom-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/ui/zoom-window/</guid>
      <description>概要 zoom-window は tmux の prefix z のような動きをするやつ。表示している window をフレーム全体に広げたり戻したりすることができる。
インストール いつも通り el-get から入れている
(el-get-bundle zoom-window) その他 キーバインドは 80-global-keybinds に書いたけど C-x 1 に割り当てている。
ただそれだと tmux と使い勝手が違うなって感じているのでそのうち hydra の中の z にでもアサインしようかと思う。
あと、その window を最大化して戻すことよりも単に他の window が邪魔なことの方が多い気もしている。。。</description>
    </item>
    
    <item>
      <title>ガベージコレクション</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/gcmh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/gcmh/</guid>
      <description>概要 ガベージコレクションには gcmh というのを利用してみている。
https://github.com/emacsmirror/gcmh
普段は GC を控えめにしながら操作してない間に GC が走るような作りになっている。便利そう。
インストール (el-get-bundle gcmh) これだけで有効化もされる。
その他 以前の設定も折り畳んで残しておく
使わなくなったコード gcmh を入れる前に設定していたコード。 gcmh を入れたらこれよりもいい感じに対応してくれそうなので入れ替えた。
;; https://gist.github.com/garaemon/8851900ef27d8cb28200ac8d92ebacdf ;; Increase threshold to fire garbage collection (setq gc-cons-threshold 1073741824) (setq garbage-collection-messages t) ;; Run GC every 60 seconds if emacs is idle. (run-with-idle-timer 60.0 t #&amp;#39;garbage-collect) </description>
    </item>
    
    <item>
      <title>グローバルキーバインド</title>
      <link>https://mugijiru.github.io/.emacs.d/keybinds/global-keybinds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/keybinds/global-keybinds/</guid>
      <description>概要 Emacs では様々なグローバルマイナーモードが存在したりしていていつでも使えるようなコマンドが多数存在するのでここでまとめて定義している。
が、Hydra 関係もここに書くと項目が大きくなりすぎるので、それはまた別途定義している。
Mac での修飾キー変更 (if (eq window-system &amp;#39;ns) (progn (setq ns-alternate-modifier (quote super)) ;; option =&amp;gt; super (setq ns-command-modifier (quote meta)))) ;; command =&amp;gt; meta C-h を backspace に変更 C-h で文字を消せないと不便なのでずっと昔からこの設定は入れている。
(keyboard-translate ?\C-h ?\C-?) (global-set-key &amp;#34;\C-h&amp;#34; nil) M-g rをstring-replaceに割り当て string-replace はよく使うのでそれなりに使いやすいキーにアサインしている
(global-set-key (kbd &amp;#34;M-g r&amp;#34;) &amp;#39;replace-string) replace-regexp もまあまあ使うけどそれはキーを当ててないのでどこかでなんとかしたい。 Hydra 使う?
C-\ で SKK が有効になるようにする C-\ で skk-mode を起動できるようにしている。 C-x C-j の方も設定は生きているが使ってない。っていうか忘れてた。
(global-set-key (kbd &amp;#34;C-\\&amp;#34;) &amp;#39;skk-mode) 余談だけど org-mode とか commit message 書く時とかは自動で有効になるようにしたい気はする。</description>
    </item>
    
    <item>
      <title>ブラウザ設定</title>
      <link>https://mugijiru.github.io/.emacs.d/external-tool/browse-url/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/external-tool/browse-url/</guid>
      <description>browse-url の時の開くプログラムの指定。
(setq browse-url-generic-program &amp;#34;vivaldi&amp;#34;) Vivaldi を指定しているが、最近 Emacs から何かブラウザ立ち上げても Firefox がいつも開いているし、この設定ほんとうに生きてる? って感じ。
WSL2 を入れてる Windows の方は Vivladi 入れてないし Mac の方は入れてるけど別に Emacs から Vivaldi が立ち上がるのも観測してないしほんと謎……。</description>
    </item>
    
    <item>
      <title>ライブラリの読み込み</title>
      <link>https://mugijiru.github.io/.emacs.d/basics/load-libraries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mugijiru.github.io/.emacs.d/basics/load-libraries/</guid>
      <description>設定ファイル内で文字列操作をするだろうということで s.el を読み込んでいる。
(el-get-bundle s) (require &amp;#39;s) けど、どういう関数があったか覚えてないぐらいには使ってない……。ま、あると便利なのでそのまま入れておくつもり。</description>
    </item>
    
  </channel>
</rss>
